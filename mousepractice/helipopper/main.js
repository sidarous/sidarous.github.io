require = function t(e, i, s) {
    function n(o, a) {
        if (!i[o]) {
            if (!e[o]) {
                var h = "function" == typeof require && require;
                if (!a && h) return h(o, !0);
                if (r) return r(o, !0);
                throw new Error("Cannot find module '" + o + "'")
            }
            var l = i[o] = {
                exports: {}
            };
            e[o][0].call(l.exports, function(t) {
                var i = e[o][1][t];
                return n(i ? i : t)
            }, l, l.exports, t, e, i, s)
        }
        return i[o].exports
    }
    for (var r = "function" == typeof require && require, o = 0; o < s.length; o++) n(s[o]);
    return n
}({
    p2: [function(t, e) {
        e.exports = t("AC+g40")
    }, {}],
    "AC+g40": [function(t, e) {
        (function(i) {
            (function(e, s, n, r) {
                ! function(t) {
                    "object" == typeof s ? e.exports = t() : "function" == typeof n && n.amd ? n("p2", function() {
                        return this.p2 = t()
                    }()) : "undefined" != typeof window ? window.p2 = t() : "undefined" != typeof i ? self.p2 = t() : "undefined" != typeof self && (self.p2 = t())
                }(function() {
                    return function e(i, s, n) {
                        function r(a, h) {
                            if (!s[a]) {
                                if (!i[a]) {
                                    var l = "function" == typeof t && t;
                                    if (!h && l) return l(a, !0);
                                    if (o) return o(a, !0);
                                    throw new Error("Cannot find module '" + a + "'")
                                }
                                var c = s[a] = {
                                    exports: {}
                                };
                                i[a][0].call(c.exports, function(t) {
                                    var e = i[a][1][t];
                                    return r(e ? e : t)
                                }, c, c.exports, e, i, s, n)
                            }
                            return s[a].exports
                        }
                        for (var o = "function" == typeof t && t, a = 0; a < n.length; a++) r(n[a]);
                        return r
                    }({
                        1: [function(t, e, i) {
                            if (!s) var s = 1e-6;
                            if (!n) var n = "undefined" != typeof Float32Array ? Float32Array : Array;
                            var r = {};
                            r.setMatrixArrayType = function(t) {
                                n = t
                            }, "undefined" != typeof i && (i.glMatrix = r);
                            var o = {};
                            o.create = function() {
                                var t = new n(2);
                                return t[0] = 0, t[1] = 0, t
                            }, o.clone = function(t) {
                                var e = new n(2);
                                return e[0] = t[0], e[1] = t[1], e
                            }, o.fromValues = function(t, e) {
                                var i = new n(2);
                                return i[0] = t, i[1] = e, i
                            }, o.copy = function(t, e) {
                                return t[0] = e[0], t[1] = e[1], t
                            }, o.set = function(t, e, i) {
                                return t[0] = e, t[1] = i, t
                            }, o.add = function(t, e, i) {
                                return t[0] = e[0] + i[0], t[1] = e[1] + i[1], t
                            }, o.subtract = function(t, e, i) {
                                return t[0] = e[0] - i[0], t[1] = e[1] - i[1], t
                            }, o.sub = o.subtract, o.multiply = function(t, e, i) {
                                return t[0] = e[0] * i[0], t[1] = e[1] * i[1], t
                            }, o.mul = o.multiply, o.divide = function(t, e, i) {
                                return t[0] = e[0] / i[0], t[1] = e[1] / i[1], t
                            }, o.div = o.divide, o.min = function(t, e, i) {
                                return t[0] = Math.min(e[0], i[0]), t[1] = Math.min(e[1], i[1]), t
                            }, o.max = function(t, e, i) {
                                return t[0] = Math.max(e[0], i[0]), t[1] = Math.max(e[1], i[1]), t
                            }, o.scale = function(t, e, i) {
                                return t[0] = e[0] * i, t[1] = e[1] * i, t
                            }, o.distance = function(t, e) {
                                var i = e[0] - t[0],
                                    s = e[1] - t[1];
                                return Math.sqrt(i * i + s * s)
                            }, o.dist = o.distance, o.squaredDistance = function(t, e) {
                                var i = e[0] - t[0],
                                    s = e[1] - t[1];
                                return i * i + s * s
                            }, o.sqrDist = o.squaredDistance, o.length = function(t) {
                                var e = t[0],
                                    i = t[1];
                                return Math.sqrt(e * e + i * i)
                            }, o.len = o.length, o.squaredLength = function(t) {
                                var e = t[0],
                                    i = t[1];
                                return e * e + i * i
                            }, o.sqrLen = o.squaredLength, o.negate = function(t, e) {
                                return t[0] = -e[0], t[1] = -e[1], t
                            }, o.normalize = function(t, e) {
                                var i = e[0],
                                    s = e[1],
                                    n = i * i + s * s;
                                return n > 0 && (n = 1 / Math.sqrt(n), t[0] = e[0] * n, t[1] = e[1] * n), t
                            }, o.dot = function(t, e) {
                                return t[0] * e[0] + t[1] * e[1]
                            }, o.cross = function(t, e, i) {
                                var s = e[0] * i[1] - e[1] * i[0];
                                return t[0] = t[1] = 0, t[2] = s, t
                            }, o.lerp = function(t, e, i, s) {
                                var n = e[0],
                                    r = e[1];
                                return t[0] = n + s * (i[0] - n), t[1] = r + s * (i[1] - r), t
                            }, o.transformMat2 = function(t, e, i) {
                                var s = e[0],
                                    n = e[1];
                                return t[0] = i[0] * s + i[2] * n, t[1] = i[1] * s + i[3] * n, t
                            }, o.transformMat2d = function(t, e, i) {
                                var s = e[0],
                                    n = e[1];
                                return t[0] = i[0] * s + i[2] * n + i[4], t[1] = i[1] * s + i[3] * n + i[5], t
                            }, o.transformMat3 = function(t, e, i) {
                                var s = e[0],
                                    n = e[1];
                                return t[0] = i[0] * s + i[3] * n + i[6], t[1] = i[1] * s + i[4] * n + i[7], t
                            }, o.transformMat4 = function(t, e, i) {
                                var s = e[0],
                                    n = e[1];
                                return t[0] = i[0] * s + i[4] * n + i[12], t[1] = i[1] * s + i[5] * n + i[13], t
                            }, o.forEach = function() {
                                var t = o.create();
                                return function(e, i, s, n, r, o) {
                                    var a, h;
                                    for (i || (i = 2), s || (s = 0), h = n ? Math.min(n * i + s, e.length) : e.length, a = s; h > a; a += i) t[0] = e[a], t[1] = e[a + 1], r(t, t, o), e[a] = t[0], e[a + 1] = t[1];
                                    return e
                                }
                            }(), o.str = function(t) {
                                return "vec2(" + t[0] + ", " + t[1] + ")"
                            }, "undefined" != typeof i && (i.vec2 = o)
                        }, {}],
                        2: [function(t, e) {
                            function i() {}
                            var s = t("./Scalar");
                            e.exports = i, i.lineInt = function(t, e, i) {
                                i = i || 0;
                                var n, r, o, a, h, l, c, u = [0, 0];
                                return n = t[1][1] - t[0][1], r = t[0][0] - t[1][0], o = n * t[0][0] + r * t[0][1], a = e[1][1] - e[0][1], h = e[0][0] - e[1][0], l = a * e[0][0] + h * e[0][1], c = n * h - a * r, s.eq(c, 0, i) || (u[0] = (h * o - r * l) / c, u[1] = (n * l - a * o) / c), u
                            }, i.segmentsIntersect = function(t, e, i, s) {
                                var n = e[0] - t[0],
                                    r = e[1] - t[1],
                                    o = s[0] - i[0],
                                    a = s[1] - i[1];
                                if (o * r - a * n == 0) return !1;
                                var h = (n * (i[1] - t[1]) + r * (t[0] - i[0])) / (o * r - a * n),
                                    l = (o * (t[1] - i[1]) + a * (i[0] - t[0])) / (a * n - o * r);
                                return h >= 0 && 1 >= h && l >= 0 && 1 >= l
                            }
                        }, {
                            "./Scalar": 5
                        }],
                        3: [function(t, e) {
                            function i() {}
                            e.exports = i, i.area = function(t, e, i) {
                                return (e[0] - t[0]) * (i[1] - t[1]) - (i[0] - t[0]) * (e[1] - t[1])
                            }, i.left = function(t, e, s) {
                                return i.area(t, e, s) > 0
                            }, i.leftOn = function(t, e, s) {
                                return i.area(t, e, s) >= 0
                            }, i.right = function(t, e, s) {
                                return i.area(t, e, s) < 0
                            }, i.rightOn = function(t, e, s) {
                                return i.area(t, e, s) <= 0
                            };
                            var s = [],
                                n = [];
                            i.collinear = function(t, e, r, o) {
                                if (o) {
                                    var a = s,
                                        h = n;
                                    a[0] = e[0] - t[0], a[1] = e[1] - t[1], h[0] = r[0] - e[0], h[1] = r[1] - e[1];
                                    var l = a[0] * h[0] + a[1] * h[1],
                                        c = Math.sqrt(a[0] * a[0] + a[1] * a[1]),
                                        u = Math.sqrt(h[0] * h[0] + h[1] * h[1]),
                                        d = Math.acos(l / (c * u));
                                    return o > d
                                }
                                return 0 == i.area(t, e, r)
                            }, i.sqdist = function(t, e) {
                                var i = e[0] - t[0],
                                    s = e[1] - t[1];
                                return i * i + s * s
                            }
                        }, {}],
                        4: [function(t, e) {
                            function i() {
                                this.vertices = []
                            }

                            function s(t, e, i, s, n) {
                                n = n || 0;
                                var r = e[1] - t[1],
                                    a = t[0] - e[0],
                                    h = r * t[0] + a * t[1],
                                    l = s[1] - i[1],
                                    c = i[0] - s[0],
                                    u = l * i[0] + c * i[1],
                                    d = r * c - l * a;
                                return o.eq(d, 0, n) ? [0, 0] : [(c * h - a * u) / d, (r * u - l * h) / d]
                            }
                            var n = t("./Line"),
                                r = t("./Point"),
                                o = t("./Scalar");
                            e.exports = i, i.prototype.at = function(t) {
                                var e = this.vertices,
                                    i = e.length;
                                return e[0 > t ? t % i + i : t % i]
                            }, i.prototype.first = function() {
                                return this.vertices[0]
                            }, i.prototype.last = function() {
                                return this.vertices[this.vertices.length - 1]
                            }, i.prototype.clear = function() {
                                this.vertices.length = 0
                            }, i.prototype.append = function(t, e, i) {
                                if ("undefined" == typeof e) throw new Error("From is not given!");
                                if ("undefined" == typeof i) throw new Error("To is not given!");
                                if (e > i - 1) throw new Error("lol1");
                                if (i > t.vertices.length) throw new Error("lol2");
                                if (0 > e) throw new Error("lol3");
                                for (var s = e; i > s; s++) this.vertices.push(t.vertices[s])
                            }, i.prototype.makeCCW = function() {
                                for (var t = 0, e = this.vertices, i = 1; i < this.vertices.length; ++i)(e[i][1] < e[t][1] || e[i][1] == e[t][1] && e[i][0] > e[t][0]) && (t = i);
                                r.left(this.at(t - 1), this.at(t), this.at(t + 1)) || this.reverse()
                            }, i.prototype.reverse = function() {
                                for (var t = [], e = 0, i = this.vertices.length; e !== i; e++) t.push(this.vertices.pop());
                                this.vertices = t
                            }, i.prototype.isReflex = function(t) {
                                return r.right(this.at(t - 1), this.at(t), this.at(t + 1))
                            };
                            var a = [],
                                h = [];
                            i.prototype.canSee = function(t, e) {
                                var i, s, o = a,
                                    l = h;
                                if (r.leftOn(this.at(t + 1), this.at(t), this.at(e)) && r.rightOn(this.at(t - 1), this.at(t), this.at(e))) return !1;
                                s = r.sqdist(this.at(t), this.at(e));
                                for (var c = 0; c !== this.vertices.length; ++c)
                                    if ((c + 1) % this.vertices.length !== t && c !== t && r.leftOn(this.at(t), this.at(e), this.at(c + 1)) && r.rightOn(this.at(t), this.at(e), this.at(c)) && (o[0] = this.at(t), o[1] = this.at(e), l[0] = this.at(c), l[1] = this.at(c + 1), i = n.lineInt(o, l), r.sqdist(this.at(t), i) < s)) return !1;
                                return !0
                            }, i.prototype.copy = function(t, e, s) {
                                var n = s || new i;
                                if (n.clear(), e > t)
                                    for (var r = t; e >= r; r++) n.vertices.push(this.vertices[r]);
                                else {
                                    for (var r = 0; e >= r; r++) n.vertices.push(this.vertices[r]);
                                    for (var r = t; r < this.vertices.length; r++) n.vertices.push(this.vertices[r])
                                }
                                return n
                            }, i.prototype.getCutEdges = function() {
                                for (var t = [], e = [], s = [], n = new i, r = Number.MAX_VALUE, o = 0; o < this.vertices.length; ++o)
                                    if (this.isReflex(o))
                                        for (var a = 0; a < this.vertices.length; ++a)
                                            if (this.canSee(o, a)) {
                                                e = this.copy(o, a, n).getCutEdges(), s = this.copy(a, o, n).getCutEdges();
                                                for (var h = 0; h < s.length; h++) e.push(s[h]);
                                                e.length < r && (t = e, r = e.length, t.push([this.at(o), this.at(a)]))
                                            }
                                return t
                            }, i.prototype.decomp = function() {
                                var t = this.getCutEdges();
                                return t.length > 0 ? this.slice(t) : [this]
                            }, i.prototype.slice = function(t) {
                                if (0 == t.length) return [this];
                                if (t instanceof Array && t.length && t[0] instanceof Array && 2 == t[0].length && t[0][0] instanceof Array) {
                                    for (var e = [this], i = 0; i < t.length; i++)
                                        for (var s = t[i], n = 0; n < e.length; n++) {
                                            var r = e[n],
                                                o = r.slice(s);
                                            if (o) {
                                                e.splice(n, 1), e.push(o[0], o[1]);
                                                break
                                            }
                                        }
                                    return e
                                }
                                var s = t,
                                    i = this.vertices.indexOf(s[0]),
                                    n = this.vertices.indexOf(s[1]);
                                return -1 != i && -1 != n ? [this.copy(i, n), this.copy(n, i)] : !1
                            }, i.prototype.isSimple = function() {
                                for (var t = this.vertices, e = 0; e < t.length - 1; e++)
                                    for (var i = 0; e - 1 > i; i++)
                                        if (n.segmentsIntersect(t[e], t[e + 1], t[i], t[i + 1])) return !1;
                                for (var e = 1; e < t.length - 2; e++)
                                    if (n.segmentsIntersect(t[0], t[t.length - 1], t[e], t[e + 1])) return !1;
                                return !0
                            }, i.prototype.quickDecomp = function(t, e, n, o, a, h) {
                                a = a || 100, h = h || 0, o = o || 25, t = "undefined" != typeof t ? t : [], e = e || [], n = n || [];
                                var l = [0, 0],
                                    c = [0, 0],
                                    u = [0, 0],
                                    d = 0,
                                    p = 0,
                                    f = 0,
                                    g = 0,
                                    m = 0,
                                    y = 0,
                                    v = 0,
                                    x = new i,
                                    b = new i,
                                    _ = this,
                                    w = this.vertices;
                                if (w.length < 3) return t;
                                if (h++, h > a) return console.warn("quickDecomp: max level (" + a + ") reached."), t;
                                for (var P = 0; P < this.vertices.length; ++P)
                                    if (_.isReflex(P)) {
                                        e.push(_.vertices[P]), d = p = Number.MAX_VALUE;
                                        for (var T = 0; T < this.vertices.length; ++T) r.left(_.at(P - 1), _.at(P), _.at(T)) && r.rightOn(_.at(P - 1), _.at(P), _.at(T - 1)) && (u = s(_.at(P - 1), _.at(P), _.at(T), _.at(T - 1)), r.right(_.at(P + 1), _.at(P), u) && (f = r.sqdist(_.vertices[P], u), p > f && (p = f, c = u, y = T))), r.left(_.at(P + 1), _.at(P), _.at(T + 1)) && r.rightOn(_.at(P + 1), _.at(P), _.at(T)) && (u = s(_.at(P + 1), _.at(P), _.at(T), _.at(T + 1)), r.left(_.at(P - 1), _.at(P), u) && (f = r.sqdist(_.vertices[P], u), d > f && (d = f, l = u, m = T)));
                                        if (y == (m + 1) % this.vertices.length) u[0] = (c[0] + l[0]) / 2, u[1] = (c[1] + l[1]) / 2, n.push(u), m > P ? (x.append(_, P, m + 1), x.vertices.push(u), b.vertices.push(u), 0 != y && b.append(_, y, _.vertices.length), b.append(_, 0, P + 1)) : (0 != P && x.append(_, P, _.vertices.length), x.append(_, 0, m + 1), x.vertices.push(u), b.vertices.push(u), b.append(_, y, P + 1));
                                        else {
                                            if (y > m && (m += this.vertices.length), g = Number.MAX_VALUE, y > m) return t;
                                            for (var T = y; m >= T; ++T) r.leftOn(_.at(P - 1), _.at(P), _.at(T)) && r.rightOn(_.at(P + 1), _.at(P), _.at(T)) && (f = r.sqdist(_.at(P), _.at(T)), g > f && (g = f, v = T % this.vertices.length));
                                            v > P ? (x.append(_, P, v + 1), 0 != v && b.append(_, v, w.length), b.append(_, 0, P + 1)) : (0 != P && x.append(_, P, w.length), x.append(_, 0, v + 1), b.append(_, v, P + 1))
                                        }
                                        return x.vertices.length < b.vertices.length ? (x.quickDecomp(t, e, n, o, a, h), b.quickDecomp(t, e, n, o, a, h)) : (b.quickDecomp(t, e, n, o, a, h), x.quickDecomp(t, e, n, o, a, h)), t
                                    }
                                return t.push(this), t
                            }, i.prototype.removeCollinearPoints = function(t) {
                                for (var e = 0, i = this.vertices.length - 1; this.vertices.length > 3 && i >= 0; --i) r.collinear(this.at(i - 1), this.at(i), this.at(i + 1), t) && (this.vertices.splice(i % this.vertices.length, 1), i--, e++);
                                return e
                            }
                        }, {
                            "./Line": 2,
                            "./Point": 3,
                            "./Scalar": 5
                        }],
                        5: [function(t, e) {
                            function i() {}
                            e.exports = i, i.eq = function(t, e, i) {
                                return i = i || 0, Math.abs(t - e) < i
                            }
                        }, {}],
                        6: [function(t, e) {
                            e.exports = {
                                Polygon: t("./Polygon"),
                                Point: t("./Point")
                            }
                        }, {
                            "./Point": 3,
                            "./Polygon": 4
                        }],
                        7: [function(t, e) {
                            e.exports = {
                                name: "p2",
                                version: "0.5.0",
                                description: "A JavaScript 2D physics engine.",
                                author: "Stefan Hedman <schteppe@gmail.com> (http://steffe.se)",
                                keywords: ["p2.js", "p2", "physics", "engine", "2d"],
                                main: "./src/p2.js",
                                engines: {
                                    node: "*"
                                },
                                repository: {
                                    type: "git",
                                    url: "https://github.com/schteppe/p2.js.git"
                                },
                                bugs: {
                                    url: "https://github.com/schteppe/p2.js/issues"
                                },
                                licenses: [{
                                    type: "MIT"
                                }],
                                devDependencies: {
                                    grunt: "~0.4.0",
                                    "grunt-contrib-jshint": "~0.9.2",
                                    "grunt-contrib-nodeunit": "~0.1.2",
                                    "grunt-contrib-uglify": "~0.4.0",
                                    "grunt-contrib-watch": "~0.5.0",
                                    "grunt-browserify": "~2.0.1",
                                    "z-schema": "~2.4.6"
                                },
                                dependencies: {
                                    "poly-decomp": "0.1.0",
                                    "gl-matrix": "2.1.0"
                                }
                            }
                        }, {}],
                        8: [function(t, e) {
                            function i(t) {
                                this.lowerBound = s.create(), t && t.lowerBound && s.copy(this.lowerBound, t.lowerBound), this.upperBound = s.create(), t && t.upperBound && s.copy(this.upperBound, t.upperBound)
                            }
                            var s = t("../math/vec2");
                            t("../utils/Utils"), e.exports = i;
                            var n = s.create();
                            i.prototype.setFromPoints = function(t, e, i) {
                                var r = this.lowerBound,
                                    o = this.upperBound;
                                s.set(r, Number.MAX_VALUE, Number.MAX_VALUE), s.set(o, -Number.MAX_VALUE, -Number.MAX_VALUE);
                                for (var a = 0; a < t.length; a++) {
                                    var h = t[a];
                                    "number" == typeof i && (s.rotate(n, h, i), h = n);
                                    for (var l = 0; 2 > l; l++) h[l] > o[l] && (o[l] = h[l]), h[l] < r[l] && (r[l] = h[l])
                                }
                                e && (s.add(this.lowerBound, this.lowerBound, e), s.add(this.upperBound, this.upperBound, e))
                            }, i.prototype.copy = function(t) {
                                s.copy(this.lowerBound, t.lowerBound), s.copy(this.upperBound, t.upperBound)
                            }, i.prototype.extend = function(t) {
                                for (var e = 0; 2 > e; e++) t.lowerBound[e] < this.lowerBound[e] && (this.lowerBound[e] = t.lowerBound[e]), t.upperBound[e] > this.upperBound[e] && (this.upperBound[e] = t.upperBound[e])
                            }, i.prototype.overlaps = function(t) {
                                var e = this.lowerBound,
                                    i = this.upperBound,
                                    s = t.lowerBound,
                                    n = t.upperBound;
                                return (s[0] <= i[0] && i[0] <= n[0] || e[0] <= n[0] && n[0] <= i[0]) && (s[1] <= i[1] && i[1] <= n[1] || e[1] <= n[1] && n[1] <= i[1])
                            }
                        }, {
                            "../math/vec2": 30,
                            "../utils/Utils": 47
                        }],
                        9: [function(t, e) {
                            function i(t) {
                                this.type = t, this.result = [], this.world = null, this.boundingVolumeType = i.AABB
                            }
                            var s = t("../math/vec2"),
                                n = t("../objects/Body");
                            e.exports = i, i.AABB = 1, i.BOUNDING_CIRCLE = 2, i.prototype.setWorld = function(t) {
                                this.world = t
                            }, i.prototype.getCollisionPairs = function() {
                                throw new Error("getCollisionPairs must be implemented in a subclass!")
                            };
                            var r = s.create();
                            i.boundingRadiusCheck = function(t, e) {
                                s.sub(r, t.position, e.position);
                                var i = s.squaredLength(r),
                                    n = t.boundingRadius + e.boundingRadius;
                                return n * n >= i
                            }, i.aabbCheck = function(t, e) {
                                return t.aabbNeedsUpdate && t.updateAABB(), e.aabbNeedsUpdate && e.updateAABB(), t.aabb.overlaps(e.aabb)
                            }, i.prototype.boundingVolumeCheck = function(t, e) {
                                var s;
                                switch (this.boundingVolumeType) {
                                    case i.BOUNDING_CIRCLE:
                                        s = i.boundingRadiusCheck(t, e);
                                        break;
                                    case i.AABB:
                                        s = i.aabbCheck(t, e);
                                        break;
                                    default:
                                        throw new Error("Bounding volume type not recognized: " + this.boundingVolumeType)
                                }
                                return s
                            }, i.canCollide = function(t, e) {
                                return t.motionState === n.STATIC && e.motionState === n.STATIC ? !1 : t.motionState === n.KINEMATIC && e.motionState === n.STATIC || t.motionState === n.STATIC && e.motionState === n.KINEMATIC ? !1 : t.motionState === n.KINEMATIC && e.motionState === n.KINEMATIC ? !1 : t.sleepState === n.SLEEPING && e.sleepState === n.SLEEPING ? !1 : t.sleepState === n.SLEEPING && e.motionState === n.STATIC || e.sleepState === n.SLEEPING && t.motionState === n.STATIC ? !1 : !0
                            }, i.NAIVE = 1, i.SAP = 2
                        }, {
                            "../math/vec2": 30,
                            "../objects/Body": 31
                        }],
                        10: [function(t, e) {
                            function i(t) {
                                s.apply(this), t = n.defaults(t, {
                                    xmin: -100,
                                    xmax: 100,
                                    ymin: -100,
                                    ymax: 100,
                                    nx: 10,
                                    ny: 10
                                }), this.xmin = t.xmin, this.ymin = t.ymin, this.xmax = t.xmax, this.ymax = t.ymax, this.nx = t.nx, this.ny = t.ny, this.binsizeX = (this.xmax - this.xmin) / this.nx, this.binsizeY = (this.ymax - this.ymin) / this.ny
                            }
                            var s = (t("../shapes/Circle"), t("../shapes/Plane"), t("../shapes/Particle"), t("../collision/Broadphase")),
                                n = (t("../math/vec2"), t("../utils/Utils"));
                            e.exports = i, i.prototype = new s, i.prototype.getCollisionPairs = function(t) {
                                for (var e = [], i = t.bodies, n = i.length, r = (this.binsizeX, this.binsizeY, this.nx), o = this.ny, a = this.xmin, h = this.ymin, l = this.xmax, c = this.ymax, u = [], d = r * o, p = 0; d > p; p++) u.push([]);
                                for (var f = r / (l - a), g = o / (c - h), p = 0; p !== n; p++)
                                    for (var m = i[p], y = m.aabb, v = Math.max(y.lowerBound[0], a), x = Math.max(y.lowerBound[1], h), b = Math.min(y.upperBound[0], l), _ = Math.min(y.upperBound[1], c), w = Math.floor(f * (v - a)), P = Math.floor(g * (x - h)), T = Math.floor(f * (b - a)), S = Math.floor(g * (_ - h)), C = w; T >= C; C++)
                                        for (var A = P; S >= A; A++) {
                                            var E = C,
                                                M = A,
                                                L = E * (o - 1) + M;
                                            L >= 0 && d > L && u[L].push(m)
                                        }
                                for (var p = 0; p !== d; p++)
                                    for (var R = u[p], C = 0, B = R.length; C !== B; C++)
                                        for (var m = R[C], A = 0; A !== C; A++) {
                                            var O = R[A];
                                            s.canCollide(m, O) && this.boundingVolumeCheck(m, O) && e.push(m, O)
                                        }
                                return e
                            }
                        }, {
                            "../collision/Broadphase": 9,
                            "../math/vec2": 30,
                            "../shapes/Circle": 35,
                            "../shapes/Particle": 39,
                            "../shapes/Plane": 40,
                            "../utils/Utils": 47
                        }],
                        11: [function(t, e) {
                            function i() {
                                s.call(this, s.NAIVE)
                            }
                            var s = (t("../shapes/Circle"), t("../shapes/Plane"), t("../shapes/Shape"), t("../shapes/Particle"), t("../collision/Broadphase"));
                            t("../math/vec2"), e.exports = i, i.prototype = new s, i.prototype.getCollisionPairs = function(t) {
                                var e = t.bodies,
                                    i = this.result;
                                i.length = 0;
                                for (var n = 0, r = e.length; n !== r; n++)
                                    for (var o = e[n], a = 0; n > a; a++) {
                                        var h = e[a];
                                        s.canCollide(o, h) && this.boundingVolumeCheck(o, h) && i.push(o, h)
                                    }
                                return i
                            }
                        }, {
                            "../collision/Broadphase": 9,
                            "../math/vec2": 30,
                            "../shapes/Circle": 35,
                            "../shapes/Particle": 39,
                            "../shapes/Plane": 40,
                            "../shapes/Shape": 42
                        }],
                        12: [function(t, e) {
                            function i() {
                                this.contactEquations = [], this.frictionEquations = [], this.enableFriction = !0, this.slipForce = 10, this.frictionCoefficient = .3, this.surfaceVelocity = 0, this.reuseObjects = !0, this.reusableContactEquations = [], this.reusableFrictionEquations = [], this.restitution = 0, this.stiffness = u.DEFAULT_STIFFNESS, this.relaxation = u.DEFAULT_RELAXATION, this.frictionStiffness = u.DEFAULT_STIFFNESS, this.frictionRelaxation = u.DEFAULT_RELAXATION, this.collidingBodiesLastStep = new c
                            }

                            function s(t, e) {
                                r.set(t.vertices[0], .5 * -e.length, -e.radius), r.set(t.vertices[1], .5 * e.length, -e.radius), r.set(t.vertices[2], .5 * e.length, e.radius), r.set(t.vertices[3], .5 * -e.length, e.radius)
                            }

                            function n(t, e, i, s) {
                                for (var n = X, h = V, l = q, c = H, u = t, d = e.vertices, p = null, f = 0; f !== d.length + 1; f++) {
                                    var g = d[f % d.length],
                                        m = d[(f + 1) % d.length];
                                    r.rotate(n, g, s), r.rotate(h, m, s), a(n, n, i), a(h, h, i), o(l, n, u), o(c, h, u);
                                    var y = r.crossLength(l, c);
                                    if (null === p && (p = y), 0 >= y * p) return !1;
                                    p = y
                                }
                                return !0
                            }
                            var r = t("../math/vec2"),
                                o = r.sub,
                                a = r.add,
                                h = r.dot,
                                l = t("../utils/Utils"),
                                c = t("../utils/TupleDictionary"),
                                u = t("../equations/Equation"),
                                d = t("../equations/ContactEquation"),
                                p = t("../equations/FrictionEquation"),
                                f = t("../shapes/Circle"),
                                g = t("../shapes/Convex"),
                                m = t("../shapes/Shape"),
                                y = (t("../objects/Body"), t("../shapes/Rectangle"));
                            e.exports = i;
                            var v = r.fromValues(0, 1),
                                x = r.fromValues(0, 0),
                                b = r.fromValues(0, 0),
                                _ = r.fromValues(0, 0),
                                w = r.fromValues(0, 0),
                                P = r.fromValues(0, 0),
                                T = r.fromValues(0, 0),
                                S = r.fromValues(0, 0),
                                C = r.fromValues(0, 0),
                                A = r.fromValues(0, 0),
                                E = r.fromValues(0, 0),
                                M = r.fromValues(0, 0),
                                L = r.fromValues(0, 0),
                                R = r.fromValues(0, 0),
                                B = r.fromValues(0, 0),
                                O = r.fromValues(0, 0),
                                I = r.fromValues(0, 0),
                                k = r.fromValues(0, 0),
                                D = r.fromValues(0, 0),
                                F = [];
                            i.prototype.collidedLastStep = function(t, e) {
                                var i = 0 | t.id,
                                    s = 0 | e.id;
                                return !!this.collidingBodiesLastStep.get(i, s)
                            }, i.prototype.reset = function() {
                                this.collidingBodiesLastStep.reset();
                                for (var t = 0; t !== this.contactEquations.length; t++) {
                                    var e = this.contactEquations[t],
                                        i = 0 | e.bodyA.id,
                                        s = 0 | e.bodyB.id;
                                    this.collidingBodiesLastStep.set(i, s, !0)
                                }
                                if (this.reuseObjects) {
                                    var n = this.contactEquations,
                                        r = this.frictionEquations,
                                        o = this.reusableFrictionEquations,
                                        a = this.reusableContactEquations;
                                    l.appendArray(a, n), l.appendArray(o, r)
                                }
                                this.contactEquations.length = this.frictionEquations.length = 0
                            }, i.prototype.createContactEquation = function(t, e, i, s) {
                                var n = this.reusableContactEquations.length ? this.reusableContactEquations.pop() : new d(t, e);
                                return n.bodyA = t, n.bodyB = e, n.shapeA = i, n.shapeB = s, n.restitution = this.restitution, n.firstImpact = !this.collidedLastStep(t, e), n.stiffness = this.stiffness, n.relaxation = this.relaxation, n.needsUpdate = !0, n.enabled = !0, n
                            }, i.prototype.createFrictionEquation = function(t, e, i, s) {
                                var n = this.reusableFrictionEquations.length ? this.reusableFrictionEquations.pop() : new p(t, e);
                                return n.bodyA = t, n.bodyB = e, n.shapeA = i, n.shapeB = s, n.setSlipForce(this.slipForce), n.frictionCoefficient = this.frictionCoefficient, n.relativeVelocity = this.surfaceVelocity, n.enabled = !0, n.needsUpdate = !0, n.stiffness = this.frictionStiffness, n.relaxation = this.frictionRelaxation, n
                            }, i.prototype.createFrictionFromContact = function(t) {
                                var e = this.createFrictionEquation(t.bodyA, t.bodyB, t.shapeA, t.shapeB);
                                return r.copy(e.contactPointA, t.contactPointA), r.copy(e.contactPointB, t.contactPointB), r.rotate90cw(e.t, t.normalA), e.contactEquation = t, e
                            }, i.prototype[m.LINE | m.CONVEX] = i.prototype.convexLine = function(t, e, i, s, n, r, o, a, h) {
                                return h ? !1 : 0
                            }, i.prototype[m.LINE | m.RECTANGLE] = i.prototype.lineRectangle = function(t, e, i, s, n, r, o, a, h) {
                                return h ? !1 : 0
                            };
                            var G = new y(1, 1),
                                U = r.create();
                            i.prototype[m.CAPSULE | m.CONVEX] = i.prototype[m.CAPSULE | m.RECTANGLE] = i.prototype.convexCapsule = function(t, e, i, n, o, a, h, l, c) {
                                var u = U;
                                r.set(u, a.length / 2, 0), r.rotate(u, u, l), r.add(u, u, h);
                                var d = this.circleConvex(o, a, u, l, t, e, i, n, c, a.radius);
                                r.set(u, -a.length / 2, 0), r.rotate(u, u, l), r.add(u, u, h);
                                var p = this.circleConvex(o, a, u, l, t, e, i, n, c, a.radius);
                                if (c && (d || p)) return !0;
                                var f = G;
                                s(f, a);
                                var g = this.convexConvex(t, e, i, n, o, f, h, l, c);
                                return g + d + p
                            }, i.prototype[m.CAPSULE | m.LINE] = i.prototype.lineCapsule = function(t, e, i, s, n, r, o, a, h) {
                                return h ? !1 : 0
                            };
                            var N = r.create(),
                                j = r.create(),
                                W = new y(1, 1);
                            i.prototype[m.CAPSULE | m.CAPSULE] = i.prototype.capsuleCapsule = function(t, e, i, n, o, a, h, l, c) {
                                for (var u = N, d = j, p = 0, f = 0; 2 > f; f++) {
                                    r.set(u, (0 == f ? -1 : 1) * e.length / 2, 0), r.rotate(u, u, n), r.add(u, u, i);
                                    for (var g = 0; 2 > g; g++) {
                                        r.set(d, (0 == g ? -1 : 1) * a.length / 2, 0), r.rotate(d, d, l), r.add(d, d, h);
                                        var m = this.circleCircle(t, e, u, n, o, a, d, l, c, e.radius, a.radius);
                                        if (c && m) return !0;
                                        p += m
                                    }
                                }
                                var y = W;
                                s(y, e);
                                var v = this.convexCapsule(t, y, i, n, o, a, h, l, c);
                                if (c && v) return !0;
                                p += v, s(y, a);
                                var x = this.convexCapsule(o, y, h, l, t, e, i, n, c);
                                return c && x ? !0 : p += x
                            }, i.prototype[m.LINE | m.LINE] = i.prototype.lineLine = function(t, e, i, s, n, r, o, a, h) {
                                return h ? !1 : 0
                            }, i.prototype[m.PLANE | m.LINE] = i.prototype.planeLine = function(t, e, i, s, n, l, c, u, d) {
                                var p = x,
                                    f = b,
                                    g = _,
                                    m = w,
                                    y = P,
                                    E = T,
                                    M = S,
                                    L = C,
                                    R = A,
                                    B = F;
                                numContacts = 0, r.set(p, -l.length / 2, 0), r.set(f, l.length / 2, 0), r.rotate(g, p, u), r.rotate(m, f, u), a(g, g, c), a(m, m, c), r.copy(p, g), r.copy(f, m), o(y, f, p), r.normalize(E, y), r.rotate90cw(R, E), r.rotate(L, v, s), B[0] = p, B[1] = f;
                                for (var O = 0; O < B.length; O++) {
                                    var I = B[O];
                                    o(M, I, i);
                                    var k = h(M, L);
                                    if (0 > k) {
                                        if (d) return !0;
                                        var D = this.createContactEquation(t, n, e, l);
                                        numContacts++, r.copy(D.normalA, L), r.normalize(D.normalA, D.normalA), r.scale(M, L, k), o(D.contactPointA, I, M), o(D.contactPointA, D.contactPointA, t.position), o(D.contactPointB, I, c), a(D.contactPointB, D.contactPointB, c), o(D.contactPointB, D.contactPointB, n.position), this.contactEquations.push(D), this.enableFriction && this.frictionEquations.push(this.createFrictionFromContact(D))
                                    }
                                }
                                return numContacts
                            }, i.prototype[m.PARTICLE | m.CAPSULE] = i.prototype.particleCapsule = function(t, e, i, s, n, r, o, a, h) {
                                return this.circleLine(t, e, i, s, n, r, o, a, h, r.radius, 0)
                            }, i.prototype[m.CIRCLE | m.LINE] = i.prototype.circleLine = function(t, e, i, s, n, l, c, u, d, p, f) {
                                var g = l,
                                    m = u,
                                    y = n,
                                    v = c,
                                    O = i,
                                    I = t,
                                    k = e,
                                    p = p || 0,
                                    f = "undefined" != typeof f ? f : k.radius,
                                    D = x,
                                    G = b,
                                    U = _,
                                    N = w,
                                    j = P,
                                    W = T,
                                    X = S,
                                    V = C,
                                    q = A,
                                    H = E,
                                    Y = M,
                                    z = L,
                                    K = R,
                                    J = B,
                                    Z = F;
                                r.set(V, -g.length / 2, 0), r.set(q, g.length / 2, 0), r.rotate(H, V, m), r.rotate(Y, q, m), a(H, H, v), a(Y, Y, v), r.copy(V, H), r.copy(q, Y), o(W, q, V), r.normalize(X, W), r.rotate90cw(j, X), o(z, O, V);
                                var Q = h(z, j);
                                if (o(N, V, v), o(K, O, v), Math.abs(Q) < f + p) {
                                    r.scale(D, j, Q), o(U, O, D), r.scale(G, j, h(j, K)), r.normalize(G, G), r.scale(G, G, p), a(U, U, G);
                                    var $ = h(X, U),
                                        te = h(X, V),
                                        ee = h(X, q);
                                    if ($ > te && ee > $) {
                                        if (d) return !0;
                                        var ie = this.createContactEquation(I, y, e, l);
                                        return r.scale(ie.normalA, D, -1), r.normalize(ie.normalA, ie.normalA), r.scale(ie.contactPointA, ie.normalA, f), a(ie.contactPointA, ie.contactPointA, O), o(ie.contactPointA, ie.contactPointA, I.position), o(ie.contactPointB, U, v), a(ie.contactPointB, ie.contactPointB, v), o(ie.contactPointB, ie.contactPointB, y.position), this.contactEquations.push(ie), this.enableFriction && this.frictionEquations.push(this.createFrictionFromContact(ie)), 1
                                    }
                                }
                                Z[0] = V, Z[1] = q;
                                for (var se = 0; se < Z.length; se++) {
                                    var ne = Z[se];
                                    if (o(z, ne, O), r.squaredLength(z) < (f + p) * (f + p)) {
                                        if (d) return !0;
                                        var ie = this.createContactEquation(I, y, e, l);
                                        return r.copy(ie.normalA, z), r.normalize(ie.normalA, ie.normalA), r.scale(ie.contactPointA, ie.normalA, f), a(ie.contactPointA, ie.contactPointA, O), o(ie.contactPointA, ie.contactPointA, I.position), o(ie.contactPointB, ne, v), r.scale(J, ie.normalA, -p), a(ie.contactPointB, ie.contactPointB, J), a(ie.contactPointB, ie.contactPointB, v), o(ie.contactPointB, ie.contactPointB, y.position), this.contactEquations.push(ie), this.enableFriction && this.frictionEquations.push(this.createFrictionFromContact(ie)), 1
                                    }
                                }
                                return 0
                            }, i.prototype[m.CIRCLE | m.CAPSULE] = i.prototype.circleCapsule = function(t, e, i, s, n, r, o, a, h) {
                                return this.circleLine(t, e, i, s, n, r, o, a, h, r.radius)
                            }, i.prototype[m.CIRCLE | m.CONVEX] = i.prototype[m.CIRCLE | m.RECTANGLE] = i.prototype.circleConvex = function(t, e, i, s, h, l, c, u, d, p) {
                                var f = l,
                                    g = u,
                                    m = h,
                                    y = c,
                                    v = i,
                                    T = t,
                                    S = e,
                                    p = "number" == typeof p ? p : S.radius,
                                    C = x,
                                    A = b,
                                    L = _,
                                    k = w,
                                    D = P,
                                    F = E,
                                    G = M,
                                    U = R,
                                    N = B,
                                    j = O,
                                    W = I,
                                    X = !1,
                                    V = Number.MAX_VALUE;
                                verts = f.vertices;
                                for (var q = 0; q !== verts.length + 1; q++) {
                                    var H = verts[q % verts.length],
                                        Y = verts[(q + 1) % verts.length];
                                    if (r.rotate(C, H, g), r.rotate(A, Y, g), a(C, C, y), a(A, A, y), o(L, A, C), r.normalize(k, L), r.rotate90cw(D, k), r.scale(N, D, -S.radius), a(N, N, v), n(N, f, y, g)) {
                                        r.sub(j, C, N);
                                        var z = Math.abs(r.dot(j, D));
                                        V > z && (r.copy(W, N), V = z, r.scale(U, D, z), r.add(U, U, N), X = !0)
                                    }
                                }
                                if (X) {
                                    if (d) return !0;
                                    var K = this.createContactEquation(T, m, e, l);
                                    return r.sub(K.normalA, W, v), r.normalize(K.normalA, K.normalA), r.scale(K.contactPointA, K.normalA, p), a(K.contactPointA, K.contactPointA, v), o(K.contactPointA, K.contactPointA, T.position), o(K.contactPointB, U, y), a(K.contactPointB, K.contactPointB, y), o(K.contactPointB, K.contactPointB, m.position), this.contactEquations.push(K), this.enableFriction && this.frictionEquations.push(this.createFrictionFromContact(K)), 1
                                }
                                if (p > 0)
                                    for (var q = 0; q < verts.length; q++) {
                                        var J = verts[q];
                                        if (r.rotate(G, J, g), a(G, G, y), o(F, G, v), r.squaredLength(F) < p * p) {
                                            if (d) return !0;
                                            var K = this.createContactEquation(T, m, e, l);
                                            return r.copy(K.normalA, F), r.normalize(K.normalA, K.normalA), r.scale(K.contactPointA, K.normalA, p), a(K.contactPointA, K.contactPointA, v), o(K.contactPointA, K.contactPointA, T.position), o(K.contactPointB, G, y), a(K.contactPointB, K.contactPointB, y), o(K.contactPointB, K.contactPointB, m.position), this.contactEquations.push(K), this.enableFriction && this.frictionEquations.push(this.createFrictionFromContact(K)), 1
                                        }
                                    }
                                return 0
                            };
                            var X = r.create(),
                                V = r.create(),
                                q = r.create(),
                                H = r.create();
                            i.prototype[m.PARTICLE | m.CONVEX] = i.prototype[m.PARTICLE | m.RECTANGLE] = i.prototype.particleConvex = function(t, e, i, s, l, c, u, d, p) {
                                var f = c,
                                    g = d,
                                    m = l,
                                    y = u,
                                    v = i,
                                    C = t,
                                    A = x,
                                    M = b,
                                    L = _,
                                    B = w,
                                    O = P,
                                    I = T,
                                    F = S,
                                    G = E,
                                    U = R,
                                    N = k,
                                    j = D,
                                    W = Number.MAX_VALUE,
                                    X = !1,
                                    V = f.vertices;
                                if (!n(v, f, y, g)) return 0;
                                if (p) return !0;
                                for (var q = 0; q !== V.length + 1; q++) {
                                    var H = V[q % V.length],
                                        Y = V[(q + 1) % V.length];
                                    r.rotate(A, H, g), r.rotate(M, Y, g), a(A, A, y), a(M, M, y), o(L, M, A), r.normalize(B, L), r.rotate90cw(O, B), o(G, v, A), h(G, O), o(I, A, y), o(F, v, y), r.sub(N, A, v);
                                    var z = Math.abs(r.dot(N, O));
                                    W > z && (W = z, r.scale(U, O, z), r.add(U, U, v), r.copy(j, O), X = !0)
                                }
                                if (X) {
                                    var K = this.createContactEquation(C, m, e, c);
                                    return r.scale(K.normalA, j, -1), r.normalize(K.normalA, K.normalA), r.set(K.contactPointA, 0, 0), a(K.contactPointA, K.contactPointA, v), o(K.contactPointA, K.contactPointA, C.position), o(K.contactPointB, U, y), a(K.contactPointB, K.contactPointB, y), o(K.contactPointB, K.contactPointB, m.position), this.contactEquations.push(K), this.enableFriction && this.frictionEquations.push(this.createFrictionFromContact(K)), 1
                                }
                                return 0
                            }, i.prototype[m.CIRCLE] = i.prototype.circleCircle = function(t, e, i, s, n, h, l, c, u, d, p) {
                                var f = t,
                                    g = e,
                                    m = i,
                                    y = n,
                                    v = h,
                                    b = l,
                                    _ = x,
                                    d = d || g.radius,
                                    p = p || v.radius;
                                o(_, i, l);
                                var w = d + p;
                                if (r.squaredLength(_) > w * w) return 0;
                                if (u) return !0;
                                var P = this.createContactEquation(f, y, e, h);
                                return o(P.normalA, b, m), r.normalize(P.normalA, P.normalA), r.scale(P.contactPointA, P.normalA, d), r.scale(P.contactPointB, P.normalA, -p), a(P.contactPointA, P.contactPointA, m), o(P.contactPointA, P.contactPointA, f.position), a(P.contactPointB, P.contactPointB, b), o(P.contactPointB, P.contactPointB, y.position), this.contactEquations.push(P), this.enableFriction && this.frictionEquations.push(this.createFrictionFromContact(P)), 1
                            }, i.prototype[m.PLANE | m.CONVEX] = i.prototype[m.PLANE | m.RECTANGLE] = i.prototype.planeConvex = function(t, e, s, n, l, c, u, d, p) {
                                var f = l,
                                    g = u,
                                    m = c,
                                    y = d,
                                    w = t,
                                    P = e,
                                    T = s,
                                    S = n,
                                    C = x,
                                    A = b,
                                    E = _,
                                    M = 0;
                                r.rotate(A, v, S);
                                for (var L = 0; L < m.vertices.length; L++) {
                                    var R = m.vertices[L];
                                    if (r.rotate(C, R, y), a(C, C, g), o(E, C, T), h(E, A) <= i.convexPrecision) {
                                        if (p) return !0;
                                        M++;
                                        var B = this.createContactEquation(w, f, P, m);
                                        o(E, C, T), r.copy(B.normalA, A);
                                        var O = h(E, B.normalA);
                                        r.scale(E, B.normalA, O), o(B.contactPointB, C, f.position), o(B.contactPointA, C, E), o(B.contactPointA, B.contactPointA, w.position), this.contactEquations.push(B), this.enableFriction && this.frictionEquations.push(this.createFrictionFromContact(B))
                                    }
                                }
                                return M
                            }, i.prototype.convexPlane = function(t, e, i, s, n, r, o, a, h) {
                                return console.warn("Narrowphase.prototype.convexPlane is deprecated. Use planeConvex instead!"), this.planeConvex(n, r, o, a, t, e, i, s, h)
                            }, i.prototype[m.PARTICLE | m.PLANE] = i.prototype.particlePlane = function(t, e, i, s, n, a, l, c, u) {
                                var d = t,
                                    p = i,
                                    f = n,
                                    g = l,
                                    m = c,
                                    y = x,
                                    _ = b;
                                m = m || 0, o(y, p, g), r.rotate(_, v, m);
                                var w = h(y, _);
                                if (w > 0) return 0;
                                if (u) return !0;
                                var P = this.createContactEquation(f, d, a, e);
                                return r.copy(P.normalA, _), r.scale(y, P.normalA, w), o(P.contactPointA, p, y), o(P.contactPointA, P.contactPointA, f.position), o(P.contactPointB, p, d.position), this.contactEquations.push(P), this.enableFriction && this.frictionEquations.push(this.createFrictionFromContact(P)), 1
                            }, i.prototype[m.CIRCLE | m.PARTICLE] = i.prototype.circleParticle = function(t, e, i, s, n, h, l, c, u) {
                                var d = t,
                                    p = e,
                                    f = i,
                                    g = n,
                                    m = l,
                                    y = x;
                                if (o(y, m, f), r.squaredLength(y) > p.radius * p.radius) return 0;
                                if (u) return !0;
                                var v = this.createContactEquation(d, g, e, h);
                                return r.copy(v.normalA, y), r.normalize(v.normalA, v.normalA), r.scale(v.contactPointA, v.normalA, p.radius), a(v.contactPointA, v.contactPointA, f), o(v.contactPointA, v.contactPointA, d.position), o(v.contactPointB, m, g.position), this.contactEquations.push(v), this.enableFriction && this.frictionEquations.push(this.createFrictionFromContact(v)), 1
                            };
                            var Y = new f(1),
                                z = r.create(),
                                K = r.create();
                            r.create(), i.prototype[m.PLANE | m.CAPSULE] = i.prototype.planeCapsule = function(t, e, i, s, n, o, h, l, c) {
                                var u = z,
                                    d = K,
                                    p = Y;
                                r.set(u, -o.length / 2, 0), r.rotate(u, u, l), a(u, u, h), r.set(d, o.length / 2, 0), r.rotate(d, d, l), a(d, d, h), p.radius = o.radius;
                                var f = this.circlePlane(n, p, u, 0, t, e, i, s, c),
                                    g = this.circlePlane(n, p, d, 0, t, e, i, s, c);
                                return c ? f || g : f + g
                            }, i.prototype.capsulePlane = function(t, e, i, s, n, r, o, a, h) {
                                return console.warn("Narrowphase.prototype.capsulePlane() is deprecated. Use .planeCapsule() instead!"), this.planeCapsule(n, r, o, a, t, e, i, s, h)
                            }, i.prototype[m.CIRCLE | m.PLANE] = i.prototype.circlePlane = function(t, e, i, s, n, l, c, u, d) {
                                var p = t,
                                    f = e,
                                    g = i,
                                    m = n,
                                    y = c,
                                    w = u;
                                w = w || 0;
                                var P = x,
                                    T = b,
                                    S = _;
                                o(P, g, y), r.rotate(T, v, w);
                                var C = h(T, P);
                                if (C > f.radius) return 0;
                                if (d) return !0;
                                var A = this.createContactEquation(m, p, l, e);
                                return r.copy(A.normalA, T), r.scale(A.contactPointB, A.normalA, -f.radius), a(A.contactPointB, A.contactPointB, g), o(A.contactPointB, A.contactPointB, p.position), r.scale(S, A.normalA, C), o(A.contactPointA, P, S), a(A.contactPointA, A.contactPointA, y), o(A.contactPointA, A.contactPointA, m.position), this.contactEquations.push(A), this.enableFriction && this.frictionEquations.push(this.createFrictionFromContact(A)), 1
                            }, i.convexPrecision = 1e-7, i.prototype[m.CONVEX] = i.prototype[m.CONVEX | m.RECTANGLE] = i.prototype[m.RECTANGLE] = i.prototype.convexConvex = function(t, e, s, n, l, c, u, d, p, f) {
                                var g = x,
                                    m = b,
                                    y = _,
                                    v = w,
                                    T = P,
                                    E = S,
                                    M = C,
                                    L = A,
                                    R = 0,
                                    f = f || i.convexPrecision,
                                    B = i.findSeparatingAxis(e, s, n, c, u, d, g);
                                if (!B) return 0;
                                o(M, u, s), h(g, M) > 0 && r.scale(g, g, -1);
                                var O = i.getClosestEdge(e, n, g, !0),
                                    I = i.getClosestEdge(c, d, g);
                                if (-1 === O || -1 === I) return 0;
                                for (var k = 0; 2 > k; k++) {
                                    var D = O,
                                        F = I,
                                        G = e,
                                        U = c,
                                        N = s,
                                        j = u,
                                        W = n,
                                        X = d,
                                        V = t,
                                        q = l;
                                    if (0 === k) {
                                        var H;
                                        H = D, D = F, F = H, H = G, G = U, U = H, H = N, N = j, j = H, H = W, W = X, X = H, H = V, V = q, q = H
                                    }
                                    for (var Y = F; F + 2 > Y; Y++) {
                                        var z = U.vertices[(Y + U.vertices.length) % U.vertices.length];
                                        r.rotate(m, z, X), a(m, m, j);
                                        for (var K = 0, J = D - 1; D + 2 > J; J++) {
                                            var Z = G.vertices[(J + G.vertices.length) % G.vertices.length],
                                                Q = G.vertices[(J + 1 + G.vertices.length) % G.vertices.length];
                                            r.rotate(y, Z, W), r.rotate(v, Q, W), a(y, y, N), a(v, v, N), o(T, v, y), r.rotate90cw(L, T), r.normalize(L, L), o(M, m, y);
                                            var $ = h(L, M);
                                            f >= $ && K++
                                        }
                                        if (K >= 3) {
                                            if (p) return !0;
                                            var te = this.createContactEquation(V, q, G, U);
                                            R++;
                                            var Z = G.vertices[D % G.vertices.length],
                                                Q = G.vertices[(D + 1) % G.vertices.length];
                                            r.rotate(y, Z, W), r.rotate(v, Q, W), a(y, y, N), a(v, v, N), o(T, v, y), r.rotate90cw(te.normalA, T), r.normalize(te.normalA, te.normalA), o(M, m, y);
                                            var $ = h(te.normalA, M);
                                            r.scale(E, te.normalA, $), o(te.contactPointA, m, N), o(te.contactPointA, te.contactPointA, E), a(te.contactPointA, te.contactPointA, N), o(te.contactPointA, te.contactPointA, V.position), o(te.contactPointB, m, j), a(te.contactPointB, te.contactPointB, j), o(te.contactPointB, te.contactPointB, q.position), this.contactEquations.push(te), this.enableFriction && this.frictionEquations.push(this.createFrictionFromContact(te))
                                        }
                                    }
                                }
                                return R
                            };
                            var J = r.fromValues(0, 0);
                            i.projectConvexOntoAxis = function(t, e, i, s, n) {
                                var o, a, l = null,
                                    c = null,
                                    u = J;
                                r.rotate(u, s, -i);
                                for (var d = 0; d < t.vertices.length; d++) o = t.vertices[d], a = h(o, u), (null === l || a > l) && (l = a), (null === c || c > a) && (c = a);
                                if (c > l) {
                                    var p = c;
                                    c = l, l = p
                                }
                                var f = h(e, s);
                                r.set(n, c + f, l + f)
                            };
                            var Z = r.fromValues(0, 0),
                                Q = r.fromValues(0, 0),
                                $ = r.fromValues(0, 0),
                                te = r.fromValues(0, 0),
                                ee = r.fromValues(0, 0),
                                ie = r.fromValues(0, 0);
                            i.findSeparatingAxis = function(t, e, s, n, a, h, l) {
                                for (var c = null, u = !1, d = !1, p = Z, f = Q, g = $, m = te, y = ee, v = ie, x = 0; 2 !== x; x++) {
                                    var b = t,
                                        _ = s;
                                    1 === x && (b = n, _ = h);
                                    for (var w = 0; w !== b.vertices.length; w++) {
                                        r.rotate(f, b.vertices[w], _), r.rotate(g, b.vertices[(w + 1) % b.vertices.length], _), o(p, g, f), r.rotate90cw(m, p), r.normalize(m, m), i.projectConvexOntoAxis(t, e, s, m, y), i.projectConvexOntoAxis(n, a, h, m, v);
                                        var P = y,
                                            T = v,
                                            S = !1;
                                        y[0] > v[0] && (T = y, P = v, S = !0);
                                        var C = T[0] - P[1];
                                        u = C <= i.convexPrecision, (null === c || C > c) && (r.copy(l, m), c = C, d = u)
                                    }
                                }
                                return d
                            };
                            var se = r.fromValues(0, 0),
                                ne = r.fromValues(0, 0),
                                re = r.fromValues(0, 0);
                            i.getClosestEdge = function(t, e, i, s) {
                                var n = se,
                                    a = ne,
                                    l = re;
                                r.rotate(n, i, -e), s && r.scale(n, n, -1);
                                for (var c = -1, u = t.vertices.length, d = 0; d !== u; d++) {
                                    o(a, t.vertices[(d + 1) % u], t.vertices[d % u]), r.rotate90cw(l, a), r.normalize(l, l);
                                    var p = h(l, n);
                                    (-1 == c || p > maxDot) && (c = d % u, maxDot = p)
                                }
                                return c
                            };
                            var oe = r.create(),
                                ae = r.create(),
                                he = r.create(),
                                le = r.create(),
                                ce = r.create(),
                                ue = r.create(),
                                de = r.create();
                            i.prototype[m.CIRCLE | m.HEIGHTFIELD] = i.prototype.circleHeightfield = function(t, e, i, s, n, h, l, c, u, d) {
                                var p = h.data,
                                    d = d || e.radius,
                                    f = h.elementWidth,
                                    g = ae,
                                    m = oe,
                                    y = ce,
                                    v = de,
                                    x = ue,
                                    b = he,
                                    _ = le,
                                    w = Math.floor((i[0] - d - l[0]) / f),
                                    P = Math.ceil((i[0] + d - l[0]) / f);
                                0 > w && (w = 0), P >= p.length && (P = p.length - 1);
                                for (var T = p[w], S = p[P], C = w; P > C; C++) p[C] < S && (S = p[C]), p[C] > T && (T = p[C]);
                                if (i[1] - d > T) return u ? !1 : 0;
                                i[1] + d < S;
                                for (var A = !1, C = w; P > C; C++) {
                                    r.set(b, C * f, p[C]), r.set(_, (C + 1) * f, p[C + 1]), r.add(b, b, l), r.add(_, _, l), r.sub(x, _, b), r.rotate(x, x, Math.PI / 2), r.normalize(x, x), r.scale(m, x, -d), r.add(m, m, i), r.sub(g, m, b);
                                    var E = r.dot(g, x);
                                    if (m[0] >= b[0] && m[0] < _[0] && 0 >= E) {
                                        if (u) return !0;
                                        A = !0, r.scale(g, x, -E), r.add(y, m, g), r.copy(v, x);
                                        var M = this.createContactEquation(n, t, h, e);
                                        r.copy(M.normalA, v), r.scale(M.contactPointB, M.normalA, -d), a(M.contactPointB, M.contactPointB, i), o(M.contactPointB, M.contactPointB, t.position), r.copy(M.contactPointA, y), r.sub(M.contactPointA, M.contactPointA, n.position), this.contactEquations.push(M), this.enableFriction && this.frictionEquations.push(this.createFrictionFromContact(M))
                                    }
                                }
                                if (A = !1, d > 0)
                                    for (var C = w; P >= C; C++)
                                        if (r.set(b, C * f, p[C]), r.add(b, b, l), r.sub(g, i, b), r.squaredLength(g) < d * d) {
                                            if (u) return !0;
                                            A = !0;
                                            var M = this.createContactEquation(n, t, h, e);
                                            r.copy(M.normalA, g), r.normalize(M.normalA, M.normalA), r.scale(M.contactPointB, M.normalA, -d), a(M.contactPointB, M.contactPointB, i), o(M.contactPointB, M.contactPointB, t.position), o(M.contactPointA, b, l), a(M.contactPointA, M.contactPointA, l), o(M.contactPointA, M.contactPointA, n.position), this.contactEquations.push(M), this.enableFriction && this.frictionEquations.push(this.createFrictionFromContact(M))
                                        }
                                return A ? 1 : 0
                            };
                            var pe = r.create(),
                                fe = r.create(),
                                ge = r.create(),
                                me = new g([r.create(), r.create(), r.create(), r.create()]);
                            i.prototype[m.RECTANGLE | m.HEIGHTFIELD] = i.prototype[m.CONVEX | m.HEIGHTFIELD] = i.prototype.convexHeightfield = function(t, e, i, s, n, o, a, h, l) {
                                var c = o.data,
                                    u = o.elementWidth,
                                    d = pe,
                                    p = fe,
                                    f = ge,
                                    g = me,
                                    m = Math.floor((t.aabb.lowerBound[0] - a[0]) / u),
                                    y = Math.ceil((t.aabb.upperBound[0] - a[0]) / u);
                                0 > m && (m = 0), y >= c.length && (y = c.length - 1);
                                for (var v = c[m], x = c[y], b = m; y > b; b++) c[b] < x && (x = c[b]), c[b] > v && (v = c[b]);
                                if (t.aabb.lowerBound[1] > v) return l ? !1 : 0;
                                for (var _ = 0, b = m; y > b; b++) {
                                    r.set(d, b * u, c[b]), r.set(p, (b + 1) * u, c[b + 1]), r.add(d, d, a), r.add(p, p, a);
                                    var w = 100;
                                    r.set(f, .5 * (p[0] + d[0]), .5 * (p[1] + d[1] - w)), r.sub(g.vertices[0], p, f), r.sub(g.vertices[1], d, f), r.copy(g.vertices[2], g.vertices[1]), r.copy(g.vertices[3], g.vertices[0]), g.vertices[2][1] -= w, g.vertices[3][1] -= w, _ += this.convexConvex(t, e, i, s, n, g, f, 0, l)
                                }
                                return _
                            }
                        }, {
                            "../equations/ContactEquation": 21,
                            "../equations/Equation": 22,
                            "../equations/FrictionEquation": 23,
                            "../math/vec2": 30,
                            "../objects/Body": 31,
                            "../shapes/Circle": 35,
                            "../shapes/Convex": 36,
                            "../shapes/Rectangle": 41,
                            "../shapes/Shape": 42,
                            "../utils/TupleDictionary": 46,
                            "../utils/Utils": 47
                        }],
                        13: [function(t, e) {
                            function i() {
                                n.call(this, n.SAP), this.axisList = [], this.world = null, this.axisIndex = 0;
                                var t = this.axisList;
                                this._addBodyHandler = function(e) {
                                    t.push(e.body)
                                }, this._removeBodyHandler = function(e) {
                                    var i = t.indexOf(e.body); - 1 !== i && t.splice(i, 1)
                                }
                            }
                            var s = t("../utils/Utils"),
                                n = t("../collision/Broadphase");
                            e.exports = i, i.prototype = new n, i.prototype.setWorld = function(t) {
                                this.axisList.length = 0, s.appendArray(this.axisList, t.bodies), t.off("addBody", this._addBodyHandler).off("removeBody", this._removeBodyHandler), t.on("addBody", this._addBodyHandler).on("removeBody", this._removeBodyHandler), this.world = t
                            }, i.sortAxisList = function(t, e) {
                                e = 0 | e;
                                for (var i = 1, s = t.length; s > i; i++) {
                                    for (var n = t[i], r = i - 1; r >= 0 && !(t[r].aabb.lowerBound[e] <= n.aabb.lowerBound[e]); r--) t[r + 1] = t[r];
                                    t[r + 1] = n
                                }
                                return t
                            }, i.prototype.getCollisionPairs = function() {
                                var t = this.axisList,
                                    e = this.result,
                                    s = this.axisIndex;
                                e.length = 0;
                                for (var r = t.length; r--;) {
                                    var o = t[r];
                                    o.aabbNeedsUpdate && o.updateAABB()
                                }
                                i.sortAxisList(t, s);
                                for (var a = 0, h = 0 | t.length; a !== h; a++)
                                    for (var l = t[a], c = a + 1; h > c; c++) {
                                        var u = t[c],
                                            d = u.aabb.lowerBound[s] <= l.aabb.upperBound[s];
                                        if (!d) break;
                                        n.canCollide(l, u) && this.boundingVolumeCheck(l, u) && e.push(l, u)
                                    }
                                return e
                            }
                        }, {
                            "../collision/Broadphase": 9,
                            "../utils/Utils": 47
                        }],
                        14: [function(t, e) {
                            function i(t, e, i, n) {
                                this.type = i, n = s.defaults(n, {
                                    collideConnected: !0,
                                    wakeUpBodies: !0
                                }), this.equations = [], this.bodyA = t, this.bodyB = e, this.collideConnected = n.collideConnected, n.wakeUpBodies && (t && t.wakeUp(), e && e.wakeUp())
                            }
                            e.exports = i;
                            var s = t("../utils/Utils");
                            i.prototype.update = function() {
                                throw new Error("method update() not implmemented in this Constraint subclass!")
                            }, i.DISTANCE = 1, i.GEAR = 2, i.LOCK = 3, i.PRISMATIC = 4, i.REVOLUTE = 5, i.prototype.setStiffness = function(t) {
                                for (var e = this.equations, i = 0; i !== e.length; i++) {
                                    var s = e[i];
                                    s.stiffness = t, s.needsUpdate = !0
                                }
                            }, i.prototype.setRelaxation = function(t) {
                                for (var e = this.equations, i = 0; i !== e.length; i++) {
                                    var s = e[i];
                                    s.relaxation = t, s.needsUpdate = !0
                                }
                            }
                        }, {
                            "../utils/Utils": 47
                        }],
                        15: [function(t, e) {
                            function i(t, e, i, o) {
                                o = o || {}, s.call(this, t, e, s.DISTANCE, o), this.distance = i, this.localAnchorA = r.create(), this.localAnchorB = r.create();
                                var a, h = this.localAnchorA,
                                    l = this.localAnchorB;
                                a = "undefined" == typeof o.maxForce ? Number.MAX_VALUE : o.maxForce;
                                var c = new n(t, e, -a, a);
                                this.equations = [c];
                                var u = r.create(),
                                    d = r.create(),
                                    p = r.create(),
                                    f = this;
                                c.computeGq = function() {
                                    var t = this.bodyA,
                                        e = this.bodyB,
                                        i = t.position;
                                    return e.position, r.rotate(d, h, t.angle), r.rotate(p, l, e.angle), r.add(u, i, p), r.sub(u, u, d), r.sub(u, u, i), r.sub(u, e.position, t.position), r.length(u) - f.distance
                                }, this.setMaxForce(a)
                            }
                            var s = t("./Constraint"),
                                n = t("../equations/Equation"),
                                r = t("../math/vec2");
                            e.exports = i, i.prototype = new s;
                            var o = r.create(),
                                a = r.create(),
                                h = r.create();
                            i.prototype.update = function() {
                                var t = this.equations[0],
                                    e = this.bodyA,
                                    i = this.bodyB,
                                    s = (this.distance, e.position, i.position, t.G);
                                r.rotate(a, this.localAnchorA, e.angle), r.rotate(h, this.localAnchorB, i.angle), r.crossLength(a, o), r.crossLength(h, o), r.sub(o, i.position, e.position), r.normalize(o, o), s[0] = -o[0], s[1] = -o[1], s[3] = o[0], s[4] = o[1]
                            }, i.prototype.setMaxForce = function(t) {
                                var e = this.equations[0];
                                e.minForce = -t, e.maxForce = t
                            }, i.prototype.getMaxForce = function() {
                                var t = this.equations[0];
                                return t.maxForce
                            }
                        }, {
                            "../equations/Equation": 22,
                            "../math/vec2": 30,
                            "./Constraint": 14
                        }],
                        16: [function(t, e) {
                            function i(t, e, i) {
                                i = i || {}, s.call(this, t, e, s.GEAR, i), this.equations = [new n(t, e, i)], this.angle = "number" == typeof i.angle ? i.angle : 0, this.ratio = "number" == typeof i.ratio ? i.ratio : 1, "number" == typeof i.maxTorque && this.setMaxTorque(i.maxTorque)
                            }
                            var s = t("./Constraint"),
                                n = (t("../equations/Equation"), t("../equations/AngleLockEquation"));
                            t("../math/vec2"), e.exports = i, i.prototype = new s, i.prototype.update = function() {
                                var t = this.equations[0];
                                t.ratio !== this.ratio && t.setRatio(this.ratio), t.angle = this.angle
                            }, i.prototype.setMaxTorque = function(t) {
                                this.equations[0].setMaxTorque(t)
                            }, i.prototype.getMaxTorque = function() {
                                return this.equations[0].maxForce
                            }
                        }, {
                            "../equations/AngleLockEquation": 20,
                            "../equations/Equation": 22,
                            "../math/vec2": 30,
                            "./Constraint": 14
                        }],
                        17: [function(t, e) {
                            function i(t, e, i) {
                                i = i || {}, s.call(this, t, e, s.LOCK, i);
                                var o = "undefined" == typeof i.maxForce ? Number.MAX_VALUE : i.maxForce,
                                    a = i.localOffsetB || n.fromValues(0, 0);
                                a = n.fromValues(a[0], a[1]);
                                var h = i.localAngleB || 0,
                                    l = new r(t, e, -o, o),
                                    c = new r(t, e, -o, o),
                                    u = new r(t, e, -o, o),
                                    d = n.create(),
                                    p = n.create(),
                                    f = this;
                                l.computeGq = function() {
                                    return n.rotate(d, f.localOffsetB, t.angle), n.sub(p, e.position, t.position), n.sub(p, p, d), p[0]
                                }, c.computeGq = function() {
                                    return n.rotate(d, f.localOffsetB, t.angle), n.sub(p, e.position, t.position), n.sub(p, p, d), p[1]
                                };
                                var g = n.create(),
                                    m = n.create();
                                u.computeGq = function() {
                                    return n.rotate(g, f.localOffsetB, e.angle - f.localAngleB), n.scale(g, g, -1), n.sub(p, t.position, e.position), n.add(p, p, g), n.rotate(m, g, -Math.PI / 2), n.normalize(m, m), n.dot(p, m)
                                }, this.localOffsetB = a, this.localAngleB = h, this.equations.push(l, c, u), this.setMaxForce(o)
                            }
                            var s = t("./Constraint"),
                                n = t("../math/vec2"),
                                r = t("../equations/Equation");
                            e.exports = i, i.prototype = new s, i.prototype.setMaxForce = function(t) {
                                for (var e = this.equations, i = 0; i < this.equations.length; i++) e[i].maxForce = t, e[i].minForce = -t
                            }, i.prototype.getMaxForce = function() {
                                return this.equations[0].maxForce
                            };
                            var o = n.create(),
                                a = n.create(),
                                h = n.create(),
                                l = n.fromValues(1, 0),
                                c = n.fromValues(0, 1);
                            i.prototype.update = function() {
                                var t = this.equations[0],
                                    e = this.equations[1],
                                    i = this.equations[2],
                                    s = this.bodyA,
                                    r = this.bodyB;
                                n.rotate(o, this.localOffsetB, s.angle), n.rotate(a, this.localOffsetB, r.angle - this.localAngleB), n.scale(a, a, -1), n.rotate(h, a, Math.PI / 2), n.normalize(h, h), t.G[0] = -1, t.G[1] = 0, t.G[2] = -n.crossLength(o, l), t.G[3] = 1, e.G[0] = 0, e.G[1] = -1, e.G[2] = -n.crossLength(o, c), e.G[4] = 1, i.G[0] = -h[0], i.G[1] = -h[1], i.G[3] = h[0], i.G[4] = h[1], i.G[5] = n.crossLength(a, h)
                            }
                        }, {
                            "../equations/Equation": 22,
                            "../math/vec2": 30,
                            "./Constraint": 14
                        }],
                        18: [function(t, e) {
                            function i(t, e, i) {
                                i = i || {}, s.call(this, t, e, s.PRISMATIC, i);
                                var h = o.fromValues(0, 0),
                                    l = o.fromValues(1, 0),
                                    c = o.fromValues(0, 0);
                                i.localAnchorA && o.copy(h, i.localAnchorA), i.localAxisA && o.copy(l, i.localAxisA), i.localAnchorB && o.copy(c, i.localAnchorB), this.localAnchorA = h, this.localAnchorB = c, this.localAxisA = l;
                                var u = this.maxForce = "undefined" != typeof i.maxForce ? i.maxForce : Number.MAX_VALUE,
                                    d = new r(t, e, -u, u),
                                    p = new o.create,
                                    f = new o.create,
                                    g = new o.create,
                                    m = new o.create;
                                if (d.computeGq = function() {
                                        return o.dot(g, m)
                                    }, d.updateJacobian = function() {
                                        var i = this.G,
                                            s = t.position,
                                            n = e.position;
                                        o.rotate(p, h, t.angle), o.rotate(f, c, e.angle), o.add(g, n, f), o.sub(g, g, s), o.sub(g, g, p), o.rotate(m, l, t.angle + Math.PI / 2), i[0] = -m[0], i[1] = -m[1], i[2] = -o.crossLength(p, m) + o.crossLength(m, g), i[3] = m[0], i[4] = m[1], i[5] = o.crossLength(f, m)
                                    }, this.equations.push(d), !i.disableRotationalLock) {
                                    var y = new a(t, e, -u, u);
                                    this.equations.push(y)
                                }
                                this.position = 0, this.velocity = 0, this.lowerLimitEnabled = "undefined" != typeof i.lowerLimit ? !0 : !1, this.upperLimitEnabled = "undefined" != typeof i.upperLimit ? !0 : !1, this.lowerLimit = "undefined" != typeof i.lowerLimit ? i.lowerLimit : 0, this.upperLimit = "undefined" != typeof i.upperLimit ? i.upperLimit : 1, this.upperLimitEquation = new n(t, e), this.lowerLimitEquation = new n(t, e), this.upperLimitEquation.minForce = this.lowerLimitEquation.minForce = 0, this.upperLimitEquation.maxForce = this.lowerLimitEquation.maxForce = u, this.motorEquation = new r(t, e), this.motorEnabled = !1, this.motorSpeed = 0;
                                var v = this,
                                    x = this.motorEquation;
                                x.computeGW, x.computeGq = function() {
                                    return 0
                                }, x.computeGW = function() {
                                    var t = this.G,
                                        e = this.bodyA,
                                        i = this.bodyB,
                                        s = e.velocity,
                                        n = i.velocity,
                                        r = e.angularVelocity,
                                        o = i.angularVelocity;
                                    return this.transformedGmult(t, s, r, n, o) + v.motorSpeed
                                }
                            }
                            var s = t("./Constraint"),
                                n = t("../equations/ContactEquation"),
                                r = t("../equations/Equation"),
                                o = t("../math/vec2"),
                                a = t("../equations/RotationalLockEquation");
                            e.exports = i, i.prototype = new s;
                            var h = o.create(),
                                l = o.create(),
                                c = o.create(),
                                u = o.create(),
                                d = o.create(),
                                p = o.create();
                            i.prototype.update = function() {
                                var t = this.equations,
                                    e = t[0],
                                    i = this.upperLimit,
                                    s = this.lowerLimit,
                                    n = this.upperLimitEquation,
                                    r = this.lowerLimitEquation,
                                    a = this.bodyA,
                                    f = this.bodyB,
                                    g = this.localAxisA,
                                    m = this.localAnchorA,
                                    y = this.localAnchorB;
                                e.updateJacobian(), o.rotate(h, g, a.angle), o.rotate(u, m, a.angle), o.add(l, u, a.position), o.rotate(d, y, f.angle), o.add(c, d, f.position);
                                var v = this.position = o.dot(c, h) - o.dot(l, h);
                                if (this.motorEnabled) {
                                    var x = this.motorEquation.G;
                                    x[0] = h[0], x[1] = h[1], x[2] = o.crossLength(h, d), x[3] = -h[0], x[4] = -h[1], x[5] = -o.crossLength(h, u)
                                }
                                if (this.upperLimitEnabled && v > i) o.scale(n.normalA, h, -1), o.sub(n.contactPointA, l, a.position), o.sub(n.contactPointB, c, f.position), o.scale(p, h, i), o.add(n.contactPointA, n.contactPointA, p), -1 == t.indexOf(n) && t.push(n);
                                else {
                                    var b = t.indexOf(n); - 1 != b && t.splice(b, 1)
                                }
                                if (this.lowerLimitEnabled && s > v) o.scale(r.normalA, h, 1), o.sub(r.contactPointA, l, a.position), o.sub(r.contactPointB, c, f.position), o.scale(p, h, s), o.sub(r.contactPointB, r.contactPointB, p), -1 == t.indexOf(r) && t.push(r);
                                else {
                                    var b = t.indexOf(r); - 1 != b && t.splice(b, 1)
                                }
                            }, i.prototype.enableMotor = function() {
                                this.motorEnabled || (this.equations.push(this.motorEquation), this.motorEnabled = !0)
                            }, i.prototype.disableMotor = function() {
                                if (this.motorEnabled) {
                                    var t = this.equations.indexOf(this.motorEquation);
                                    this.equations.splice(t, 1), this.motorEnabled = !1
                                }
                            }
                        }, {
                            "../equations/ContactEquation": 21,
                            "../equations/Equation": 22,
                            "../equations/RotationalLockEquation": 24,
                            "../math/vec2": 30,
                            "./Constraint": 14
                        }],
                        19: [function(t, e) {
                            function i(t, e, i, p, f) {
                                f = f || {}, s.call(this, t, i, s.REVOLUTE, f);
                                var g = this.maxForce = "undefined" != typeof f.maxForce ? f.maxForce : Number.MAX_VALUE;
                                this.pivotA = a.fromValues(e[0], e[1]), this.pivotB = a.fromValues(p[0], p[1]);
                                var m = this.equations = [new n(t, i, -g, g), new n(t, i, -g, g)],
                                    y = m[0],
                                    v = m[1],
                                    x = this;
                                y.computeGq = function() {
                                    return a.rotate(h, x.pivotA, t.angle), a.rotate(l, x.pivotB, i.angle), a.add(d, i.position, l), a.sub(d, d, t.position), a.sub(d, d, h), a.dot(d, c)
                                }, v.computeGq = function() {
                                    return a.rotate(h, x.pivotA, t.angle), a.rotate(l, x.pivotB, i.angle), a.add(d, i.position, l), a.sub(d, d, t.position), a.sub(d, d, h), a.dot(d, u)
                                }, v.minForce = y.minForce = -g, v.maxForce = y.maxForce = g, this.motorEquation = new r(t, i), this.motorEnabled = !1, this.angle = 0, this.lowerLimitEnabled = !1, this.upperLimitEnabled = !1, this.lowerLimit = 0, this.upperLimit = 0, this.upperLimitEquation = new o(t, i), this.lowerLimitEquation = new o(t, i), this.upperLimitEquation.minForce = 0, this.lowerLimitEquation.maxForce = 0
                            }
                            var s = t("./Constraint"),
                                n = t("../equations/Equation"),
                                r = t("../equations/RotationalVelocityEquation"),
                                o = t("../equations/RotationalLockEquation"),
                                a = t("../math/vec2");
                            e.exports = i;
                            var h = a.create(),
                                l = a.create(),
                                c = a.fromValues(1, 0),
                                u = a.fromValues(0, 1),
                                d = a.create();
                            i.prototype = new s, i.prototype.update = function() {
                                var t = this.bodyA,
                                    e = this.bodyB,
                                    i = this.pivotA,
                                    s = this.pivotB,
                                    n = this.equations,
                                    r = (n[0], n[1], n[0]),
                                    o = n[1],
                                    d = this.upperLimit,
                                    p = this.lowerLimit,
                                    f = this.upperLimitEquation,
                                    g = this.lowerLimitEquation,
                                    m = this.angle = e.angle - t.angle;
                                if (this.upperLimitEnabled && m > d) f.angle = d, -1 == n.indexOf(f) && n.push(f);
                                else {
                                    var y = n.indexOf(f); - 1 != y && n.splice(y, 1)
                                }
                                if (this.lowerLimitEnabled && p > m) g.angle = p, -1 == n.indexOf(g) && n.push(g);
                                else {
                                    var y = n.indexOf(g); - 1 != y && n.splice(y, 1)
                                }
                                a.rotate(h, i, t.angle), a.rotate(l, s, e.angle), r.G[0] = -1, r.G[1] = 0, r.G[2] = -a.crossLength(h, c), r.G[3] = 1, r.G[4] = 0, r.G[5] = a.crossLength(l, c), o.G[0] = 0, o.G[1] = -1, o.G[2] = -a.crossLength(h, u), o.G[3] = 0, o.G[4] = 1, o.G[5] = a.crossLength(l, u)
                            }, i.prototype.enableMotor = function() {
                                this.motorEnabled || (this.equations.push(this.motorEquation), this.motorEnabled = !0)
                            }, i.prototype.disableMotor = function() {
                                if (this.motorEnabled) {
                                    var t = this.equations.indexOf(this.motorEquation);
                                    this.equations.splice(t, 1), this.motorEnabled = !1
                                }
                            }, i.prototype.motorIsEnabled = function() {
                                return !!this.motorEnabled
                            }, i.prototype.setMotorSpeed = function(t) {
                                if (this.motorEnabled) {
                                    var e = this.equations.indexOf(this.motorEquation);
                                    this.equations[e].relativeVelocity = t
                                }
                            }, i.prototype.getMotorSpeed = function() {
                                return this.motorEnabled ? this.motorEquation.relativeVelocity : !1
                            }
                        }, {
                            "../equations/Equation": 22,
                            "../equations/RotationalLockEquation": 24,
                            "../equations/RotationalVelocityEquation": 25,
                            "../math/vec2": 30,
                            "./Constraint": 14
                        }],
                        20: [function(t, e) {
                            function i(t, e, i) {
                                i = i || {}, s.call(this, t, e, -Number.MAX_VALUE, Number.MAX_VALUE), this.angle = i.angle || 0, this.ratio = "number" == typeof i.ratio ? i.ratio : 1, this.setRatio(this.ratio)
                            }
                            var s = t("./Equation");
                            t("../math/vec2"), e.exports = i, i.prototype = new s, i.prototype.constructor = i, i.prototype.computeGq = function() {
                                return this.ratio * this.bodyA.angle - this.bodyB.angle + this.angle
                            }, i.prototype.setRatio = function(t) {
                                var e = this.G;
                                e[2] = t, e[5] = -1, this.ratio = t
                            }, i.prototype.setMaxTorque = function(t) {
                                this.maxForce = t, this.minForce = -t
                            }
                        }, {
                            "../math/vec2": 30,
                            "./Equation": 22
                        }],
                        21: [function(t, e) {
                            function i(t, e) {
                                s.call(this, t, e, 0, Number.MAX_VALUE), this.contactPointA = n.create(), this.penetrationVec = n.create(), this.contactPointB = n.create(), this.normalA = n.create(), this.restitution = 0, this.firstImpact = !1, this.shapeA = null, this.shapeB = null
                            }
                            var s = t("./Equation"),
                                n = t("../math/vec2");
                            e.exports = i, i.prototype = new s, i.prototype.constructor = i, i.prototype.computeB = function(t, e, i) {
                                var s = this.bodyA,
                                    r = this.bodyB,
                                    o = this.contactPointA,
                                    a = this.contactPointB,
                                    h = s.position,
                                    l = r.position,
                                    c = this.penetrationVec,
                                    u = this.normalA,
                                    d = this.G,
                                    p = n.crossLength(o, u),
                                    f = n.crossLength(a, u);
                                d[0] = -u[0], d[1] = -u[1], d[2] = -p, d[3] = u[0], d[4] = u[1], d[5] = f, n.add(c, l, a), n.sub(c, c, h), n.sub(c, c, o);
                                var g, m;
                                this.firstImpact && 0 !== this.restitution ? (m = 0, g = 1 / e * (1 + this.restitution) * this.computeGW()) : (m = n.dot(u, c), g = this.computeGW());
                                var y = this.computeGiMf(),
                                    v = -m * t - g * e - i * y;
                                return v
                            }
                        }, {
                            "../math/vec2": 30,
                            "./Equation": 22
                        }],
                        22: [function(t, e) {
                            function i(t, e, s, n) {
                                this.minForce = "undefined" == typeof s ? -Number.MAX_VALUE : s, this.maxForce = "undefined" == typeof n ? Number.MAX_VALUE : n, this.bodyA = t, this.bodyB = e, this.stiffness = i.DEFAULT_STIFFNESS, this.relaxation = i.DEFAULT_RELAXATION, this.G = new a.ARRAY_TYPE(6);
                                for (var r = 0; 6 > r; r++) this.G[r] = 0;
                                this.offset = 0, this.a = 0, this.b = 0, this.epsilon = 0, this.timeStep = 1 / 60, this.needsUpdate = !0, this.multiplier = 0, this.relativeVelocity = 0, this.enabled = !0
                            }

                            function s(t, e, i, s, n) {
                                return t[0] * e[0] + t[1] * e[1] + t[2] * i + t[3] * s[0] + t[4] * s[1] + t[5] * n
                            }

                            function n(t) {
                                return t.sleepState === h.SLEEPING ? 0 : t.invMass
                            }

                            function r(t) {
                                return t.sleepState === h.SLEEPING ? 0 : t.invInertia
                            }
                            e.exports = i;
                            var o = t("../math/vec2"),
                                a = t("../utils/Utils"),
                                h = t("../objects/Body");
                            i.prototype.constructor = i, i.DEFAULT_STIFFNESS = 1e6, i.DEFAULT_RELAXATION = 4, i.prototype.update = function() {
                                var t = this.stiffness,
                                    e = this.relaxation,
                                    i = this.timeStep;
                                this.a = 4 / (i * (1 + 4 * e)), this.b = 4 * e / (1 + 4 * e), this.epsilon = 4 / (i * i * t * (1 + 4 * e)), this.needsUpdate = !1
                            }, i.prototype.computeB = function(t, e, i) {
                                var s = this.computeGW(),
                                    n = this.computeGq(),
                                    r = this.computeGiMf();
                                return -n * t - s * e - r * i
                            };
                            var l = o.create(),
                                c = o.create();
                            i.prototype.computeGq = function() {
                                var t = this.G,
                                    e = this.bodyA,
                                    i = this.bodyB,
                                    n = (e.position, i.position, e.angle),
                                    r = i.angle;
                                return s(t, l, n, c, r) + this.offset
                            }, i.prototype.computeGW = function() {
                                var t = this.G,
                                    e = this.bodyA,
                                    i = this.bodyB,
                                    n = e.velocity,
                                    r = i.velocity,
                                    o = e.angularVelocity,
                                    a = i.angularVelocity;
                                return s(t, n, o, r, a) + this.relativeVelocity
                            }, i.prototype.computeGWlambda = function() {
                                var t = this.G,
                                    e = this.bodyA,
                                    i = this.bodyB,
                                    n = e.vlambda,
                                    r = i.vlambda,
                                    o = e.wlambda,
                                    a = i.wlambda;
                                return s(t, n, o, r, a)
                            };
                            var u = o.create(),
                                d = o.create();
                            i.prototype.computeGiMf = function() {
                                var t = this.bodyA,
                                    e = this.bodyB,
                                    i = t.force,
                                    a = t.angularForce,
                                    h = e.force,
                                    l = e.angularForce,
                                    c = n(t),
                                    p = n(e),
                                    f = r(t),
                                    g = r(e),
                                    m = this.G;
                                return o.scale(u, i, c), o.scale(d, h, p), s(m, u, a * f, d, l * g)
                            }, i.prototype.computeGiMGt = function() {
                                var t = this.bodyA,
                                    e = this.bodyB,
                                    i = n(t),
                                    s = n(e),
                                    o = r(t),
                                    a = r(e),
                                    h = this.G;
                                return h[0] * h[0] * i + h[1] * h[1] * i + h[2] * h[2] * o + h[3] * h[3] * s + h[4] * h[4] * s + h[5] * h[5] * a
                            };
                            var p = o.create(),
                                f = o.create(),
                                g = o.create();
                            o.create(), o.create(), o.create(), i.prototype.addToWlambda = function(t) {
                                var e = this.bodyA,
                                    i = this.bodyB,
                                    s = p,
                                    a = f,
                                    h = g,
                                    l = n(e),
                                    c = n(i),
                                    u = r(e),
                                    d = r(i),
                                    m = this.G;
                                a[0] = m[0], a[1] = m[1], h[0] = m[3], h[1] = m[4], o.scale(s, a, l * t), o.add(e.vlambda, e.vlambda, s), e.wlambda += u * m[2] * t, o.scale(s, h, c * t), o.add(i.vlambda, i.vlambda, s), i.wlambda += d * m[5] * t
                            }, i.prototype.computeInvC = function(t) {
                                return 1 / (this.computeGiMGt() + t)
                            }
                        }, {
                            "../math/vec2": 30,
                            "../objects/Body": 31,
                            "../utils/Utils": 47
                        }],
                        23: [function(t, e) {
                            function i(t, e, i) {
                                n.call(this, t, e, -i, i), this.contactPointA = s.create(), this.contactPointB = s.create(), this.t = s.create(), this.contactEquation = null, this.shapeA = null, this.shapeB = null, this.frictionCoefficient = .3
                            }
                            var s = t("../math/vec2"),
                                n = t("./Equation");
                            t("../utils/Utils"), e.exports = i, i.prototype = new n, i.prototype.constructor = i, i.prototype.setSlipForce = function(t) {
                                this.maxForce = t, this.minForce = -t
                            }, i.prototype.getSlipForce = function() {
                                return this.maxForce
                            }, i.prototype.computeB = function(t, e, i) {
                                var n = (this.bodyA, this.bodyB, this.contactPointA),
                                    r = this.contactPointB,
                                    o = this.t,
                                    a = this.G;
                                a[0] = -o[0], a[1] = -o[1], a[2] = -s.crossLength(n, o), a[3] = o[0], a[4] = o[1], a[5] = s.crossLength(r, o);
                                var h = this.computeGW(),
                                    l = this.computeGiMf(),
                                    c = -h * e - i * l;
                                return c
                            }
                        }, {
                            "../math/vec2": 30,
                            "../utils/Utils": 47,
                            "./Equation": 22
                        }],
                        24: [function(t, e) {
                            function i(t, e, i) {
                                i = i || {}, s.call(this, t, e, -Number.MAX_VALUE, Number.MAX_VALUE), this.angle = i.angle || 0;
                                var n = this.G;
                                n[2] = 1, n[5] = -1
                            }
                            var s = t("./Equation"),
                                n = t("../math/vec2");
                            e.exports = i, i.prototype = new s, i.prototype.constructor = i;
                            var r = n.create(),
                                o = n.create(),
                                a = n.fromValues(1, 0),
                                h = n.fromValues(0, 1);
                            i.prototype.computeGq = function() {
                                return n.rotate(r, a, this.bodyA.angle + this.angle), n.rotate(o, h, this.bodyB.angle), n.dot(r, o)
                            }
                        }, {
                            "../math/vec2": 30,
                            "./Equation": 22
                        }],
                        25: [function(t, e) {
                            function i(t, e) {
                                s.call(this, t, e, -Number.MAX_VALUE, Number.MAX_VALUE), this.relativeVelocity = 1, this.ratio = 1
                            }
                            var s = t("./Equation");
                            t("../math/vec2"), e.exports = i, i.prototype = new s, i.prototype.constructor = i, i.prototype.computeB = function(t, e, i) {
                                var s = this.G;
                                s[2] = -1, s[5] = this.ratio;
                                var n = this.computeGiMf(),
                                    r = this.computeGW(),
                                    o = -r * e - i * n;
                                return o
                            }
                        }, {
                            "../math/vec2": 30,
                            "./Equation": 22
                        }],
                        26: [function(t, e) {
                            var i = function() {};
                            e.exports = i, i.prototype = {
                                constructor: i,
                                on: function(t, e, i) {
                                    e.context = i || this, void 0 === this._listeners && (this._listeners = {});
                                    var s = this._listeners;
                                    return void 0 === s[t] && (s[t] = []), -1 === s[t].indexOf(e) && s[t].push(e), this
                                },
                                has: function(t, e) {
                                    if (void 0 === this._listeners) return !1;
                                    var i = this._listeners;
                                    if (e) {
                                        if (void 0 !== i[t] && -1 !== i[t].indexOf(e)) return !0
                                    } else if (void 0 !== i[t]) return !0;
                                    return !1
                                },
                                off: function(t, e) {
                                    if (void 0 === this._listeners) return this;
                                    var i = this._listeners,
                                        s = i[t].indexOf(e);
                                    return -1 !== s && i[t].splice(s, 1), this
                                },
                                emit: function(t) {
                                    if (void 0 === this._listeners) return this;
                                    var e = this._listeners,
                                        i = e[t.type];
                                    if (void 0 !== i) {
                                        t.target = this;
                                        for (var s = 0, n = i.length; n > s; s++) {
                                            var r = i[s];
                                            r.call(r.context, t)
                                        }
                                    }
                                    return this
                                }
                            }
                        }, {}],
                        27: [function(t, e) {
                            function i(t, e, r) {
                                if (r = r || {}, !(t instanceof s && e instanceof s)) throw new Error("First two arguments must be Material instances.");
                                this.id = i.idCounter++, this.materialA = t, this.materialB = e, this.friction = "undefined" != typeof r.friction ? Number(r.friction) : .3, this.restitution = "undefined" != typeof r.restitution ? Number(r.restitution) : 0, this.stiffness = "undefined" != typeof r.stiffness ? Number(r.stiffness) : n.DEFAULT_STIFFNESS, this.relaxation = "undefined" != typeof r.relaxation ? Number(r.relaxation) : n.DEFAULT_RELAXATION, this.frictionStiffness = "undefined" != typeof r.frictionStiffness ? Number(r.frictionStiffness) : n.DEFAULT_STIFFNESS, this.frictionRelaxation = "undefined" != typeof r.frictionRelaxation ? Number(r.frictionRelaxation) : n.DEFAULT_RELAXATION, this.surfaceVelocity = "undefined" != typeof r.surfaceVelocity ? Number(r.surfaceVelocity) : 0
                            }
                            var s = t("./Material"),
                                n = t("../equations/Equation");
                            e.exports = i, i.idCounter = 0
                        }, {
                            "../equations/Equation": 22,
                            "./Material": 28
                        }],
                        28: [function(t, e) {
                            function i() {
                                this.id = i.idCounter++
                            }
                            e.exports = i, i.idCounter = 0
                        }, {}],
                        29: [function(t, e) {
                            var i = {};
                            i.GetArea = function(t) {
                                if (t.length < 6) return 0;
                                for (var e = t.length - 2, i = 0, s = 0; e > s; s += 2) i += (t[s + 2] - t[s]) * (t[s + 1] + t[s + 3]);
                                return i += (t[0] - t[e]) * (t[e + 1] + t[1]), .5 * -i
                            }, i.Triangulate = function(t) {
                                var e = t.length >> 1;
                                if (3 > e) return [];
                                for (var s = [], n = [], r = 0; e > r; r++) n.push(r);
                                for (var r = 0, o = e; o > 3;) {
                                    var a = n[(r + 0) % o],
                                        h = n[(r + 1) % o],
                                        l = n[(r + 2) % o],
                                        c = t[2 * a],
                                        u = t[2 * a + 1],
                                        d = t[2 * h],
                                        p = t[2 * h + 1],
                                        f = t[2 * l],
                                        g = t[2 * l + 1],
                                        m = !1;
                                    if (i._convex(c, u, d, p, f, g)) {
                                        m = !0;
                                        for (var y = 0; o > y; y++) {
                                            var v = n[y];
                                            if (v != a && v != h && v != l && i._PointInTriangle(t[2 * v], t[2 * v + 1], c, u, d, p, f, g)) {
                                                m = !1;
                                                break
                                            }
                                        }
                                    }
                                    if (m) s.push(a, h, l), n.splice((r + 1) % o, 1), o--, r = 0;
                                    else if (r++ > 3 * o) break
                                }
                                return s.push(n[0], n[1], n[2]), s
                            }, i._PointInTriangle = function(t, e, i, s, n, r, o, a) {
                                var h = o - i,
                                    l = a - s,
                                    c = n - i,
                                    u = r - s,
                                    d = t - i,
                                    p = e - s,
                                    f = h * h + l * l,
                                    g = h * c + l * u,
                                    m = h * d + l * p,
                                    y = c * c + u * u,
                                    v = c * d + u * p,
                                    x = 1 / (f * y - g * g),
                                    b = (y * m - g * v) * x,
                                    _ = (f * v - g * m) * x;
                                return b >= 0 && _ >= 0 && 1 > b + _
                            }, i._convex = function(t, e, i, s, n, r) {
                                return (e - s) * (n - i) + (i - t) * (r - s) >= 0
                            }, e.exports = i
                        }, {}],
                        30: [function(t, e) {
                            var i = t("../../build/vec2").vec2;
                            i.crossLength = function(t, e) {
                                return t[0] * e[1] - t[1] * e[0]
                            }, i.crossVZ = function(t, e, s) {
                                return i.rotate(t, e, -Math.PI / 2), i.scale(t, t, s), t
                            }, i.crossZV = function(t, e, s) {
                                return i.rotate(t, s, Math.PI / 2), i.scale(t, t, e), t
                            }, i.rotate = function(t, e, i) {
                                var s = Math.cos(i),
                                    n = Math.sin(i),
                                    r = e[0],
                                    o = e[1];
                                t[0] = s * r - n * o, t[1] = n * r + s * o
                            }, i.rotate90cw = function(t, e) {
                                t[0] = e[1], t[1] = -e[0]
                            }, i.toLocalFrame = function(t, e, s, n) {
                                i.copy(t, e), i.sub(t, t, s), i.rotate(t, t, -n)
                            }, i.toGlobalFrame = function(t, e, s, n) {
                                i.copy(t, e), i.rotate(t, t, n), i.add(t, t, s)
                            }, i.centroid = function(t, e, s, n) {
                                return i.add(t, e, s), i.add(t, t, n), i.scale(t, t, 1 / 3), t
                            }, e.exports = i
                        }, {
                            "../../build/vec2": 1
                        }],
                        31: [function(t, e) {
                            function i(t) {
                                t = t || {}, a.call(this), this.id = ++i._idCounter, this.world = null, this.shapes = [], this.shapeOffsets = [], this.shapeAngles = [], this.mass = t.mass || 0, this.invMass = 0, this.inertia = 0, this.invInertia = 0, this.fixedRotation = !!t.fixedRotation || !1, this.position = s.fromValues(0, 0), t.position && s.copy(this.position, t.position), this.interpolatedPosition = s.fromValues(0, 0), this.interpolatedAngle = 0, this.previousPosition = s.fromValues(0, 0), this.previousAngle = 0, this.velocity = s.fromValues(0, 0), t.velocity && s.copy(this.velocity, t.velocity), this.vlambda = s.fromValues(0, 0), this.wlambda = 0, this.angle = t.angle || 0, this.angularVelocity = t.angularVelocity || 0, this.force = s.create(), t.force && s.copy(this.force, t.force), this.angularForce = t.angularForce || 0, this.damping = "number" == typeof t.damping ? t.damping : .1, this.angularDamping = "number" == typeof t.angularDamping ? t.angularDamping : .1, this.motionState = 0 === this.mass ? i.STATIC : i.DYNAMIC, this.boundingRadius = 0, this.aabb = new o, this.aabbNeedsUpdate = !0, this.allowSleep = !0, this.wantsToSleep = !1, this.sleepState = i.AWAKE, this.sleepSpeedLimit = .2, this.sleepTimeLimit = 1, this.gravityScale = 1, this.timeLastSleepy = 0, this.concavePath = null, this.lastDampingScale = 1, this.lastAngularDampingScale = 1, this.lastDampingTimeStep = -1, this._wakeUpAfterNarrowphase = !1, this.updateMassProperties()
                            }
                            var s = t("../math/vec2"),
                                n = t("poly-decomp"),
                                r = t("../shapes/Convex"),
                                o = t("../collision/AABB"),
                                a = t("../events/EventEmitter");
                            e.exports = i, i.prototype = new a, i._idCounter = 0, i.prototype.setDensity = function(t) {
                                var e = this.getArea();
                                this.mass = e * t, this.updateMassProperties()
                            }, i.prototype.getArea = function() {
                                for (var t = 0, e = 0; e < this.shapes.length; e++) t += this.shapes[e].area;
                                return t
                            };
                            var h = new o,
                                l = s.create();
                            i.prototype.updateAABB = function() {
                                for (var t = this.shapes, e = this.shapeOffsets, i = this.shapeAngles, n = t.length, r = 0; r !== n; r++) {
                                    var o = t[r],
                                        a = l,
                                        c = i[r] + this.angle;
                                    s.rotate(a, e[r], this.angle), s.add(a, a, this.position), o.computeAABB(h, a, c), 0 === r ? this.aabb.copy(h) : this.aabb.extend(h)
                                }
                                this.aabbNeedsUpdate = !1
                            }, i.prototype.updateBoundingRadius = function() {
                                for (var t = this.shapes, e = this.shapeOffsets, i = t.length, n = 0, r = 0; r !== i; r++) {
                                    var o = t[r],
                                        a = s.length(e[r]),
                                        h = o.boundingRadius;
                                    a + h > n && (n = a + h)
                                }
                                this.boundingRadius = n
                            }, i.prototype.addShape = function(t, e, i) {
                                i = i || 0, e = e ? s.fromValues(e[0], e[1]) : s.fromValues(0, 0), this.shapes.push(t), this.shapeOffsets.push(e), this.shapeAngles.push(i), this.updateMassProperties(), this.updateBoundingRadius(), this.aabbNeedsUpdate = !0
                            }, i.prototype.removeShape = function(t) {
                                var e = this.shapes.indexOf(t);
                                return -1 !== e ? (this.shapes.splice(e, 1), this.shapeOffsets.splice(e, 1), this.shapeAngles.splice(e, 1), this.aabbNeedsUpdate = !0, !0) : !1
                            }, i.prototype.updateMassProperties = function() {
                                if (this.motionState === i.STATIC || this.motionState === i.KINEMATIC) this.mass = Number.MAX_VALUE, this.invMass = 0, this.inertia = Number.MAX_VALUE, this.invInertia = 0;
                                else {
                                    var t = this.shapes,
                                        e = t.length,
                                        n = this.mass / e,
                                        r = 0;
                                    if (this.fixedRotation) this.inertia = Number.MAX_VALUE, this.invInertia = 0;
                                    else {
                                        for (var o = 0; e > o; o++) {
                                            var a = t[o],
                                                h = s.squaredLength(this.shapeOffsets[o]),
                                                l = a.computeMomentOfInertia(n);
                                            r += l + n * h
                                        }
                                        this.inertia = r, this.invInertia = r > 0 ? 1 / r : 0
                                    }
                                    this.invMass = 1 / this.mass
                                }
                            };
                            var c = s.create();
                            i.prototype.applyForce = function(t, e) {
                                var i = c;
                                s.sub(i, e, this.position), s.add(this.force, this.force, t);
                                var n = s.crossLength(i, t);
                                this.angularForce += n
                            }, i.prototype.toLocalFrame = function(t, e) {
                                s.toLocalFrame(t, e, this.position, this.angle)
                            }, i.prototype.toWorldFrame = function(t, e) {
                                s.toGlobalFrame(t, e, this.position, this.angle)
                            }, i.prototype.fromPolygon = function(t, e) {
                                e = e || {};
                                for (var i = this.shapes.length; i >= 0; --i) this.removeShape(this.shapes[i]);
                                var o = new n.Polygon;
                                if (o.vertices = t, o.makeCCW(), "number" == typeof e.removeCollinearPoints && o.removeCollinearPoints(e.removeCollinearPoints), "undefined" == typeof e.skipSimpleCheck && !o.isSimple()) return !1;
                                this.concavePath = o.vertices.slice(0);
                                for (var i = 0; i < this.concavePath.length; i++) {
                                    var a = [0, 0];
                                    s.copy(a, this.concavePath[i]), this.concavePath[i] = a
                                }
                                var h;
                                h = e.optimalDecomp ? o.decomp() : o.quickDecomp();
                                for (var l = s.create(), i = 0; i !== h.length; i++) {
                                    for (var c = new r(h[i].vertices), u = 0; u !== c.vertices.length; u++) {
                                        var a = c.vertices[u];
                                        s.sub(a, a, c.centerOfMass)
                                    }
                                    s.scale(l, c.centerOfMass, 1), c.updateTriangles(), c.updateCenterOfMass(), c.updateBoundingRadius(), this.addShape(c, l)
                                }
                                return this.adjustCenterOfMass(), this.aabbNeedsUpdate = !0, !0
                            };
                            var u = (s.fromValues(0, 0), s.fromValues(0, 0)),
                                d = s.fromValues(0, 0),
                                p = s.fromValues(0, 0);
                            i.prototype.adjustCenterOfMass = function() {
                                var t = u,
                                    e = d,
                                    i = p,
                                    n = 0;
                                s.set(e, 0, 0);
                                for (var r = 0; r !== this.shapes.length; r++) {
                                    var o = this.shapes[r],
                                        a = this.shapeOffsets[r];
                                    s.scale(t, a, o.area), s.add(e, e, t), n += o.area
                                }
                                s.scale(i, e, 1 / n);
                                for (var r = 0; r !== this.shapes.length; r++) {
                                    var o = this.shapes[r],
                                        a = this.shapeOffsets[r];
                                    a || (a = this.shapeOffsets[r] = s.create()), s.sub(a, a, i)
                                }
                                s.add(this.position, this.position, i);
                                for (var r = 0; this.concavePath && r < this.concavePath.length; r++) s.sub(this.concavePath[r], this.concavePath[r], i);
                                this.updateMassProperties(), this.updateBoundingRadius()
                            }, i.prototype.setZeroForce = function() {
                                s.set(this.force, 0, 0), this.angularForce = 0
                            }, i.prototype.resetConstraintVelocity = function() {
                                var t = this,
                                    e = t.vlambda;
                                s.set(e, 0, 0), t.wlambda = 0
                            }, i.prototype.addConstraintVelocity = function() {
                                var t = this,
                                    e = t.velocity;
                                s.add(e, e, t.vlambda), t.angularVelocity += t.wlambda
                            }, i.prototype.applyDamping = function(t) {
                                if (this.motionState === i.DYNAMIC) {
                                    t !== this.lastDampingTimeStep && (this.lastDampingScale = Math.pow(1 - this.damping, t), this.lastAngularDampingScale = Math.pow(1 - this.angularDamping, t), this.lastDampingTimeStep = t);
                                    var e = this.velocity;
                                    s.scale(e, e, this.lastDampingScale), this.angularVelocity *= this.lastAngularDampingScale
                                }
                            }, i.prototype.wakeUp = function() {
                                var t = this.sleepState;
                                this.sleepState = i.AWAKE, this.idleTime = 0, t !== i.AWAKE && this.emit(i.wakeUpEvent)
                            }, i.prototype.sleep = function() {
                                this.sleepState = i.SLEEPING, this.angularVelocity = 0, this.angularForce = 0, s.set(this.velocity, 0, 0), s.set(this.force, 0, 0), this.emit(i.sleepEvent)
                            }, i.prototype.sleepTick = function(t, e, n) {
                                if (this.allowSleep && this.motionState !== i.SLEEPING) {
                                    this.wantsToSleep = !1;
                                    var r = (this.sleepState, s.squaredLength(this.velocity) + Math.pow(this.angularVelocity, 2)),
                                        o = Math.pow(this.sleepSpeedLimit, 2);
                                    r >= o ? (this.idleTime = 0, this.sleepState = i.AWAKE) : (this.idleTime += n, this.sleepState = i.SLEEPY), this.idleTime > this.sleepTimeLimit && (e ? this.wantsToSleep = !0 : this.sleep())
                                }
                            }, i.prototype.getVelocityFromPosition = function(t, e) {
                                return t = t || s.create(), s.sub(t, this.position, this.previousPosition), s.scale(t, t, 1 / e), t
                            }, i.prototype.getAngularVelocityFromPosition = function(t) {
                                return (this.angle - this.previousAngle) / t
                            }, i.sleepyEvent = {
                                type: "sleepy"
                            }, i.sleepEvent = {
                                type: "sleep"
                            }, i.wakeUpEvent = {
                                type: "wakeup"
                            }, i.DYNAMIC = 1, i.STATIC = 2, i.KINEMATIC = 4, i.AWAKE = 0, i.SLEEPY = 1, i.SLEEPING = 2
                        }, {
                            "../collision/AABB": 8,
                            "../events/EventEmitter": 26,
                            "../math/vec2": 30,
                            "../shapes/Convex": 36,
                            "poly-decomp": 6
                        }],
                        32: [function(t, e) {
                            function i(t, e, i) {
                                i = n.defaults(i, {
                                    restLength: 1,
                                    stiffness: 100,
                                    damping: 1,
                                    localAnchorA: [0, 0],
                                    localAnchorB: [0, 0]
                                }), this.restLength = i.restLength, this.stiffness = i.stiffness, this.damping = i.damping, this.bodyA = t, this.bodyB = e, this.localAnchorA = s.create(), s.copy(this.localAnchorA, i.localAnchorA), this.localAnchorB = s.create(), s.copy(this.localAnchorB, i.localAnchorB), i.worldAnchorA && this.setWorldAnchorA(i.worldAnchorA), i.worldAnchorB && this.setWorldAnchorB(i.worldAnchorB)
                            }
                            var s = t("../math/vec2"),
                                n = t("../utils/Utils");
                            e.exports = i, i.prototype.setWorldAnchorA = function(t) {
                                this.bodyA.toLocalFrame(this.localAnchorA, t)
                            }, i.prototype.setWorldAnchorB = function(t) {
                                this.bodyB.toLocalFrame(this.localAnchorB, t)
                            }, i.prototype.getWorldAnchorA = function(t) {
                                this.bodyA.toWorldFrame(t, this.localAnchorA)
                            }, i.prototype.getWorldAnchorB = function(t) {
                                this.bodyB.toWorldFrame(t, this.localAnchorB)
                            };
                            var r = s.create(),
                                o = s.create(),
                                a = s.create(),
                                h = s.create(),
                                l = s.create(),
                                c = s.create(),
                                u = s.create(),
                                d = s.create(),
                                p = s.create();
                            i.prototype.applyForce = function() {
                                var t = this.stiffness,
                                    e = this.damping,
                                    i = this.restLength,
                                    n = this.bodyA,
                                    f = this.bodyB,
                                    g = r,
                                    m = o,
                                    y = a,
                                    v = h,
                                    x = p,
                                    b = l,
                                    _ = c,
                                    w = u,
                                    P = d;
                                this.getWorldAnchorA(b), this.getWorldAnchorB(_), s.sub(w, b, n.position), s.sub(P, _, f.position), s.sub(g, _, b);
                                var T = s.len(g);
                                s.normalize(m, g), s.sub(y, f.velocity, n.velocity), s.crossZV(x, f.angularVelocity, P), s.add(y, y, x), s.crossZV(x, n.angularVelocity, w), s.sub(y, y, x), s.scale(v, m, -t * (T - i) - e * s.dot(y, m)), s.sub(n.force, n.force, v), s.add(f.force, f.force, v);
                                var S = s.crossLength(w, v),
                                    C = s.crossLength(P, v);
                                n.angularForce -= S, f.angularForce += C
                            }
                        }, {
                            "../math/vec2": 30,
                            "../utils/Utils": 47
                        }],
                        33: [function(t, e) {
                            e.exports = {
                                AABB: t("./collision/AABB"),
                                AngleLockEquation: t("./equations/AngleLockEquation"),
                                Body: t("./objects/Body"),
                                Broadphase: t("./collision/Broadphase"),
                                Capsule: t("./shapes/Capsule"),
                                Circle: t("./shapes/Circle"),
                                Constraint: t("./constraints/Constraint"),
                                ContactEquation: t("./equations/ContactEquation"),
                                ContactMaterial: t("./material/ContactMaterial"),
                                Convex: t("./shapes/Convex"),
                                DistanceConstraint: t("./constraints/DistanceConstraint"),
                                Equation: t("./equations/Equation"),
                                EventEmitter: t("./events/EventEmitter"),
                                FrictionEquation: t("./equations/FrictionEquation"),
                                GearConstraint: t("./constraints/GearConstraint"),
                                GridBroadphase: t("./collision/GridBroadphase"),
                                GSSolver: t("./solver/GSSolver"),
                                Heightfield: t("./shapes/Heightfield"),
                                Line: t("./shapes/Line"),
                                LockConstraint: t("./constraints/LockConstraint"),
                                Material: t("./material/Material"),
                                Narrowphase: t("./collision/Narrowphase"),
                                NaiveBroadphase: t("./collision/NaiveBroadphase"),
                                Particle: t("./shapes/Particle"),
                                Plane: t("./shapes/Plane"),
                                RevoluteConstraint: t("./constraints/RevoluteConstraint"),
                                PrismaticConstraint: t("./constraints/PrismaticConstraint"),
                                Rectangle: t("./shapes/Rectangle"),
                                RotationalVelocityEquation: t("./equations/RotationalVelocityEquation"),
                                SAPBroadphase: t("./collision/SAPBroadphase"),
                                Shape: t("./shapes/Shape"),
                                Solver: t("./solver/Solver"),
                                Spring: t("./objects/Spring"),
                                Utils: t("./utils/Utils"),
                                World: t("./world/World"),
                                vec2: t("./math/vec2"),
                                version: t("../package.json").version
                            }
                        }, {
                            "../package.json": 7,
                            "./collision/AABB": 8,
                            "./collision/Broadphase": 9,
                            "./collision/GridBroadphase": 10,
                            "./collision/NaiveBroadphase": 11,
                            "./collision/Narrowphase": 12,
                            "./collision/SAPBroadphase": 13,
                            "./constraints/Constraint": 14,
                            "./constraints/DistanceConstraint": 15,
                            "./constraints/GearConstraint": 16,
                            "./constraints/LockConstraint": 17,
                            "./constraints/PrismaticConstraint": 18,
                            "./constraints/RevoluteConstraint": 19,
                            "./equations/AngleLockEquation": 20,
                            "./equations/ContactEquation": 21,
                            "./equations/Equation": 22,
                            "./equations/FrictionEquation": 23,
                            "./equations/RotationalVelocityEquation": 25,
                            "./events/EventEmitter": 26,
                            "./material/ContactMaterial": 27,
                            "./material/Material": 28,
                            "./math/vec2": 30,
                            "./objects/Body": 31,
                            "./objects/Spring": 32,
                            "./shapes/Capsule": 34,
                            "./shapes/Circle": 35,
                            "./shapes/Convex": 36,
                            "./shapes/Heightfield": 37,
                            "./shapes/Line": 38,
                            "./shapes/Particle": 39,
                            "./shapes/Plane": 40,
                            "./shapes/Rectangle": 41,
                            "./shapes/Shape": 42,
                            "./solver/GSSolver": 43,
                            "./solver/Solver": 44,
                            "./utils/Utils": 47,
                            "./world/World": 51
                        }],
                        34: [function(t, e) {
                            function i(t, e) {
                                this.length = t || 1, this.radius = e || 1, s.call(this, s.CAPSULE)
                            }
                            var s = t("./Shape"),
                                n = t("../math/vec2");
                            e.exports = i, i.prototype = new s, i.prototype.computeMomentOfInertia = function(t) {
                                var e = this.radius,
                                    i = this.length + e,
                                    s = 2 * e;
                                return t * (s * s + i * i) / 12
                            }, i.prototype.updateBoundingRadius = function() {
                                this.boundingRadius = this.radius + this.length / 2
                            }, i.prototype.updateArea = function() {
                                this.area = Math.PI * this.radius * this.radius + 2 * this.radius * this.length
                            };
                            var r = n.create();
                            i.prototype.computeAABB = function(t, e, i) {
                                var s = this.radius;
                                n.set(r, this.length, 0), n.rotate(r, r, i), n.set(t.upperBound, Math.max(r[0] + s, -r[0] + s), Math.max(r[1] + s, -r[1] + s)), n.set(t.lowerBound, Math.min(r[0] - s, -r[0] - s), Math.min(r[1] - s, -r[1] - s)), n.add(t.lowerBound, t.lowerBound, e), n.add(t.upperBound, t.upperBound, e)
                            }
                        }, {
                            "../math/vec2": 30,
                            "./Shape": 42
                        }],
                        35: [function(t, e) {
                            function i(t) {
                                this.radius = t || 1, s.call(this, s.CIRCLE)
                            }
                            var s = t("./Shape"),
                                n = t("../math/vec2");
                            e.exports = i, i.prototype = new s, i.prototype.computeMomentOfInertia = function(t) {
                                var e = this.radius;
                                return t * e * e / 2
                            }, i.prototype.updateBoundingRadius = function() {
                                this.boundingRadius = this.radius
                            }, i.prototype.updateArea = function() {
                                this.area = Math.PI * this.radius * this.radius
                            }, i.prototype.computeAABB = function(t, e) {
                                var i = this.radius;
                                n.set(t.upperBound, i, i), n.set(t.lowerBound, -i, -i), e && (n.add(t.lowerBound, t.lowerBound, e), n.add(t.upperBound, t.upperBound, e))
                            }
                        }, {
                            "../math/vec2": 30,
                            "./Shape": 42
                        }],
                        36: [function(t, e) {
                            function i(t) {
                                this.vertices = [];
                                for (var e = 0; e < t.length; e++) {
                                    var i = n.create();
                                    n.copy(i, t[e]), this.vertices.push(i)
                                }
                                if (this.centerOfMass = n.fromValues(0, 0), this.triangles = [], this.vertices.length && (this.updateTriangles(), this.updateCenterOfMass()), this.boundingRadius = 0, s.call(this, s.CONVEX), this.updateBoundingRadius(), this.updateArea(), this.area < 0) throw new Error("Convex vertices must be given in conter-clockwise winding.")
                            }
                            var s = t("./Shape"),
                                n = t("../math/vec2"),
                                r = t("../math/polyk");
                            t("poly-decomp"), e.exports = i, i.prototype = new s, i.prototype.updateTriangles = function() {
                                this.triangles.length = 0;
                                for (var t = [], e = 0; e < this.vertices.length; e++) {
                                    var i = this.vertices[e];
                                    t.push(i[0], i[1])
                                }
                                for (var s = r.Triangulate(t), e = 0; e < s.length; e += 3) {
                                    var n = s[e],
                                        o = s[e + 1],
                                        a = s[e + 2];
                                    this.triangles.push([n, o, a])
                                }
                            };
                            var o = n.create(),
                                a = n.create(),
                                h = n.create(),
                                l = n.create(),
                                c = n.create();
                            n.create(), n.create(), n.create(), n.create(), i.prototype.updateCenterOfMass = function() {
                                var t = this.triangles,
                                    e = this.vertices,
                                    s = this.centerOfMass,
                                    r = o,
                                    u = h,
                                    d = l,
                                    p = c,
                                    f = a;
                                n.set(s, 0, 0);
                                for (var g = 0, m = 0; m !== t.length; m++) {
                                    var y = t[m],
                                        u = e[y[0]],
                                        d = e[y[1]],
                                        p = e[y[2]];
                                    n.centroid(r, u, d, p);
                                    var v = i.triangleArea(u, d, p);
                                    g += v, n.scale(f, r, v), n.add(s, s, f)
                                }
                                n.scale(s, s, 1 / g)
                            }, i.prototype.computeMomentOfInertia = function(t) {
                                for (var e = 0, i = 0, s = this.vertices.length, r = s - 1, o = 0; s > o; r = o, o++) {
                                    var a = this.vertices[r],
                                        h = this.vertices[o],
                                        l = Math.abs(n.crossLength(a, h)),
                                        c = n.dot(h, h) + n.dot(h, a) + n.dot(a, a);
                                    e += l * c, i += l
                                }
                                return t / 6 * (e / i)
                            }, i.prototype.updateBoundingRadius = function() {
                                for (var t = this.vertices, e = 0, i = 0; i !== t.length; i++) {
                                    var s = n.squaredLength(t[i]);
                                    s > e && (e = s)
                                }
                                this.boundingRadius = Math.sqrt(e)
                            }, i.triangleArea = function(t, e, i) {
                                return .5 * ((e[0] - t[0]) * (i[1] - t[1]) - (i[0] - t[0]) * (e[1] - t[1]))
                            }, i.prototype.updateArea = function() {
                                this.updateTriangles(), this.area = 0;
                                for (var t = this.triangles, e = this.vertices, s = 0; s !== t.length; s++) {
                                    var n = t[s],
                                        r = e[n[0]],
                                        o = e[n[1]],
                                        a = e[n[2]],
                                        h = i.triangleArea(r, o, a);
                                    this.area += h
                                }
                            }, i.prototype.computeAABB = function(t, e, i) {
                                t.setFromPoints(this.vertices, e, i)
                            }
                        }, {
                            "../math/polyk": 29,
                            "../math/vec2": 30,
                            "./Shape": 42,
                            "poly-decomp": 6
                        }],
                        37: [function(t, e) {
                            function i(t, e) {
                                if (e = n.defaults(e, {
                                        maxValue: null,
                                        minValue: null,
                                        elementWidth: .1
                                    }), null === e.minValue || null === e.maxValue) {
                                    e.maxValue = t[0], e.minValue = t[0];
                                    for (var i = 0; i !== t.length; i++) {
                                        var r = t[i];
                                        r > e.maxValue && (e.maxValue = r), r < e.minValue && (e.minValue = r)
                                    }
                                }
                                this.data = t, this.maxValue = e.maxValue, this.minValue = e.minValue, this.elementWidth = e.elementWidth, s.call(this, s.HEIGHTFIELD)
                            }
                            var s = t("./Shape"),
                                n = (t("../math/vec2"), t("../utils/Utils"));
                            e.exports = i, i.prototype = new s, i.prototype.computeMomentOfInertia = function() {
                                return Number.MAX_VALUE
                            }, i.prototype.updateBoundingRadius = function() {
                                this.boundingRadius = Number.MAX_VALUE
                            }, i.prototype.updateArea = function() {
                                for (var t = this.data, e = 0, i = 0; i < t.length - 1; i++) e += (t[i] + t[i + 1]) / 2 * this.elementWidth;
                                this.area = e
                            }, i.prototype.computeAABB = function(t, e) {
                                t.upperBound[0] = this.elementWidth * this.data.length + e[0], t.upperBound[1] = this.maxValue + e[1], t.lowerBound[0] = e[0], t.lowerBound[1] = -Number.MAX_VALUE
                            }
                        }, {
                            "../math/vec2": 30,
                            "../utils/Utils": 47,
                            "./Shape": 42
                        }],
                        38: [function(t, e) {
                            function i(t) {
                                this.length = t || 1, s.call(this, s.LINE)
                            }
                            var s = t("./Shape"),
                                n = t("../math/vec2");
                            e.exports = i, i.prototype = new s, i.prototype.computeMomentOfInertia = function(t) {
                                return t * Math.pow(this.length, 2) / 12
                            }, i.prototype.updateBoundingRadius = function() {
                                this.boundingRadius = this.length / 2
                            };
                            var r = [n.create(), n.create()];
                            i.prototype.computeAABB = function(t, e, i) {
                                var s = this.length;
                                n.set(r[0], -s / 2, 0), n.set(r[1], s / 2, 0), t.setFromPoints(r, e, i)
                            }
                        }, {
                            "../math/vec2": 30,
                            "./Shape": 42
                        }],
                        39: [function(t, e) {
                            function i() {
                                s.call(this, s.PARTICLE)
                            }
                            var s = t("./Shape"),
                                n = t("../math/vec2");
                            e.exports = i, i.prototype = new s, i.prototype.computeMomentOfInertia = function() {
                                return 0
                            }, i.prototype.updateBoundingRadius = function() {
                                this.boundingRadius = 0
                            }, i.prototype.computeAABB = function(t, e) {
                                this.length, n.copy(t.lowerBound, e), n.copy(t.upperBound, e)
                            }
                        }, {
                            "../math/vec2": 30,
                            "./Shape": 42
                        }],
                        40: [function(t, e) {
                            function i() {
                                s.call(this, s.PLANE)
                            }
                            var s = t("./Shape"),
                                n = t("../math/vec2");
                            t("../utils/Utils"), e.exports = i, i.prototype = new s, i.prototype.computeMomentOfInertia = function() {
                                return 0
                            }, i.prototype.updateBoundingRadius = function() {
                                this.boundingRadius = Number.MAX_VALUE
                            }, i.prototype.computeAABB = function(t, e, i) {
                                var s = 0,
                                    r = n.set;
                                "number" == typeof i && (s = i % (2 * Math.PI)), 0 == s ? (r(t.lowerBound, -Number.MAX_VALUE, -Number.MAX_VALUE), r(t.upperBound, Number.MAX_VALUE, 0)) : s == Math.PI / 2 ? (r(t.lowerBound, 0, -Number.MAX_VALUE), r(t.upperBound, Number.MAX_VALUE, Number.MAX_VALUE)) : s == Math.PI ? (r(t.lowerBound, -Number.MAX_VALUE, 0), r(t.upperBound, Number.MAX_VALUE, Number.MAX_VALUE)) : s == 3 * Math.PI / 2 ? (r(t.lowerBound, -Number.MAX_VALUE, -Number.MAX_VALUE), r(t.upperBound, 0, Number.MAX_VALUE)) : (r(t.lowerBound, -Number.MAX_VALUE, -Number.MAX_VALUE), r(t.upperBound, Number.MAX_VALUE, Number.MAX_VALUE)), n.add(t.lowerBound, t.lowerBound, e), n.add(t.upperBound, t.upperBound, e)
                            }, i.prototype.updateArea = function() {
                                this.area = Number.MAX_VALUE
                            }
                        }, {
                            "../math/vec2": 30,
                            "../utils/Utils": 47,
                            "./Shape": 42
                        }],
                        41: [function(t, e) {
                            function i(t, e) {
                                t = t || 1, e = e || 1;
                                var i = [s.fromValues(-t / 2, -e / 2), s.fromValues(t / 2, -e / 2), s.fromValues(t / 2, e / 2), s.fromValues(-t / 2, e / 2)];
                                this.width = t, this.height = e, r.call(this, i), this.type = n.RECTANGLE
                            }
                            var s = t("../math/vec2"),
                                n = t("./Shape"),
                                r = t("./Convex");
                            e.exports = i, i.prototype = new r([]), i.prototype.computeMomentOfInertia = function(t) {
                                var e = this.width,
                                    i = this.height;
                                return t * (i * i + e * e) / 12
                            }, i.prototype.updateBoundingRadius = function() {
                                var t = this.width,
                                    e = this.height;
                                this.boundingRadius = Math.sqrt(t * t + e * e) / 2
                            }, s.create(), s.create(), s.create(), s.create(), i.prototype.computeAABB = function(t, e, i) {
                                t.setFromPoints(this.vertices, e, i)
                            }, i.prototype.updateArea = function() {
                                this.area = this.width * this.height
                            }
                        }, {
                            "../math/vec2": 30,
                            "./Convex": 36,
                            "./Shape": 42
                        }],
                        42: [function(t, e) {
                            function i(t) {
                                this.type = t, this.id = i.idCounter++, this.boundingRadius = 0, this.collisionGroup = 1, this.collisionMask = 1, t && this.updateBoundingRadius(), this.material = null, this.area = 0, this.sensor = !1, this.updateArea()
                            }
                            e.exports = i, i.idCounter = 0, i.CIRCLE = 1, i.PARTICLE = 2, i.PLANE = 4, i.CONVEX = 8, i.LINE = 16, i.RECTANGLE = 32, i.CAPSULE = 64, i.HEIGHTFIELD = 128, i.prototype.computeMomentOfInertia = function() {
                                throw new Error("Shape.computeMomentOfInertia is not implemented in this Shape...")
                            }, i.prototype.updateBoundingRadius = function() {
                                throw new Error("Shape.updateBoundingRadius is not implemented in this Shape...")
                            }, i.prototype.updateArea = function() {}, i.prototype.computeAABB = function() {}
                        }, {}],
                        43: [function(t, e) {
                            function i(t) {
                                r.call(this, t, r.GS), t = t || {}, this.iterations = t.iterations || 10, this.tolerance = t.tolerance || 1e-10, this.arrayStep = 30, this.lambda = new o.ARRAY_TYPE(this.arrayStep), this.Bs = new o.ARRAY_TYPE(this.arrayStep), this.invCs = new o.ARRAY_TYPE(this.arrayStep), this.useZeroRHS = !1, this.frictionIterations = 0, this.usedIterations = 0
                            }

                            function s(t) {
                                for (var e = t.length; e--;) t[e] = 0
                            }
                            var n = t("../math/vec2"),
                                r = t("./Solver"),
                                o = t("../utils/Utils"),
                                a = t("../equations/FrictionEquation");
                            e.exports = i, i.prototype = new r, i.prototype.solve = function(t, e) {
                                this.sortEquations();
                                var r = 0,
                                    h = this.iterations,
                                    l = this.frictionIterations,
                                    c = this.equations,
                                    u = c.length,
                                    d = Math.pow(this.tolerance * u, 2),
                                    p = e.bodies,
                                    f = e.bodies.length,
                                    g = (n.add, n.set, this.useZeroRHS),
                                    m = this.lambda;
                                this.usedIterations = 0, m.length < u && (m = this.lambda = new o.ARRAY_TYPE(u + this.arrayStep), this.Bs = new o.ARRAY_TYPE(u + this.arrayStep), this.invCs = new o.ARRAY_TYPE(u + this.arrayStep)), s(m);
                                for (var y = this.invCs, v = this.Bs, m = this.lambda, x = 0; x !== c.length; x++) {
                                    var b = c[x];
                                    (b.timeStep !== t || b.needsUpdate) && (b.timeStep = t, b.update()), v[x] = b.computeB(b.a, b.b, t), y[x] = b.computeInvC(b.epsilon)
                                }
                                var b, _, x, w;
                                if (0 !== u) {
                                    for (x = 0; x !== f; x++) p[x].resetConstraintVelocity();
                                    if (l) {
                                        for (r = 0; r !== l; r++) {
                                            for (_ = 0, w = 0; w !== u; w++) {
                                                b = c[w];
                                                var P = i.iterateEquation(w, b, b.epsilon, v, y, m, g, t, r);
                                                _ += Math.abs(P)
                                            }
                                            if (this.usedIterations++, d >= _ * _) break
                                        }
                                        for (i.updateMultipliers(c, m, 1 / t), w = 0; w !== u; w++) {
                                            var T = c[w];
                                            if (T instanceof a) {
                                                var S = T.contactEquation.multiplier * T.frictionCoefficient;
                                                T.maxForce = S, T.minForce = -S
                                            }
                                        }
                                    }
                                    for (r = 0; r !== h; r++) {
                                        for (_ = 0, w = 0; w !== u; w++) {
                                            b = c[w];
                                            var P = i.iterateEquation(w, b, b.epsilon, v, y, m, g, t, r);
                                            _ += Math.abs(P)
                                        }
                                        if (this.usedIterations++, d >= _ * _) break
                                    }
                                    for (x = 0; x !== f; x++) p[x].addConstraintVelocity();
                                    i.updateMultipliers(c, m, 1 / t)
                                }
                            }, i.updateMultipliers = function(t, e, i) {
                                for (var s = t.length; s--;) t[s].multiplier = e[s] * i
                            }, i.iterateEquation = function(t, e, i, s, n, r, o, a) {
                                var h = s[t],
                                    l = n[t],
                                    c = r[t],
                                    u = e.computeGWlambda(),
                                    d = e.maxForce,
                                    p = e.minForce;
                                o && (h = 0);
                                var f = l * (h - u - i * c),
                                    g = c + f;
                                return p * a > g ? f = p * a - c : g > d * a && (f = d * a - c), r[t] += f, e.addToWlambda(f), f
                            }
                        }, {
                            "../equations/FrictionEquation": 23,
                            "../math/vec2": 30,
                            "../utils/Utils": 47,
                            "./Solver": 44
                        }],
                        44: [function(t, e) {
                            function i(t, e) {
                                t = t || {}, s.call(this), this.type = e, this.equations = [], this.equationSortFunction = t.equationSortFunction || !1
                            }
                            var s = (t("../utils/Utils"), t("../events/EventEmitter"));
                            e.exports = i, i.prototype = new s, i.prototype.solve = function() {
                                throw new Error("Solver.solve should be implemented by subclasses!")
                            };
                            var n = {
                                bodies: []
                            };
                            i.prototype.solveIsland = function(t, e) {
                                this.removeAllEquations(), e.equations.length && (this.addEquations(e.equations), n.bodies.length = 0, e.getBodies(n.bodies), n.bodies.length && this.solve(t, n))
                            }, i.prototype.sortEquations = function() {
                                this.equationSortFunction && this.equations.sort(this.equationSortFunction)
                            }, i.prototype.addEquation = function(t) {
                                t.enabled && this.equations.push(t)
                            }, i.prototype.addEquations = function(t) {
                                for (var e = 0, i = t.length; e !== i; e++) {
                                    var s = t[e];
                                    s.enabled && this.equations.push(s)
                                }
                            }, i.prototype.removeEquation = function(t) {
                                var e = this.equations.indexOf(t); - 1 !== e && this.equations.splice(e, 1)
                            }, i.prototype.removeAllEquations = function() {
                                this.equations.length = 0
                            }, i.GS = 1, i.ISLAND = 2
                        }, {
                            "../events/EventEmitter": 26,
                            "../utils/Utils": 47
                        }],
                        45: [function(t, e) {
                            function i() {
                                this.overlappingLastState = new n, this.overlappingCurrentState = new n, this.recordPool = [], this.tmpDict = new n, this.tmpArray1 = []
                            }

                            function s(t, e, i, s) {
                                this.shapeA = e, this.shapeB = s, this.bodyA = t, this.bodyB = i
                            }
                            var n = t("./TupleDictionary");
                            t("./Utils"), e.exports = i, i.prototype.tick = function() {
                                for (var t = this.overlappingLastState, e = this.overlappingCurrentState, i = e.keys.length; i--;) {
                                    var s = e.keys[i];
                                    this.recordPool.push(e.getByKey(s))
                                }
                                t.reset(), t.copy(e), e.reset()
                            }, i.prototype.setOverlapping = function(t, e, i, n) {
                                var r = (this.overlappingLastState, this.overlappingCurrentState);
                                if (!r.get(e.id, n.id)) {
                                    var o;
                                    o = this.recordPool.length ? this.recordPool.pop() : new s(t, e, i, n), r.set(e.id, n.id, o)
                                }
                            }, i.prototype.getNewOverlaps = function(t) {
                                return this.getDiff(this.overlappingLastState, this.overlappingCurrentState, t)
                            }, i.prototype.getEndOverlaps = function(t) {
                                return this.getDiff(this.overlappingCurrentState, this.overlappingLastState, t)
                            }, i.prototype.getDiff = function(t, e, i) {
                                var i = i || [],
                                    s = t,
                                    n = e;
                                i.length = 0;
                                for (var r = n.keys.length; r--;) {
                                    var o = n.keys[r],
                                        a = n.data[o];
                                    if (!a) throw new Error("Key " + o + " had no data!");
                                    var h = s.data[o];
                                    h || i.push(a)
                                }
                                return i
                            }, i.prototype.isNewOverlap = function(t, e) {
                                var i = 0 | t.id,
                                    s = 0 | e.id;
                                return !this.overlappingLastState.get(i, s) && !!this.overlappingCurrentState.get(i, s)
                            }, i.prototype.getNewBodyOverlaps = function(t) {
                                this.tmpArray1.length = 0;
                                var e = this.getNewOverlaps(this.tmpArray1);
                                return this.getBodyDiff(e, t)
                            }, i.prototype.getEndBodyOverlaps = function(t) {
                                this.tmpArray1.length = 0;
                                var e = this.getEndOverlaps(this.tmpArray1);
                                return this.getBodyDiff(e, t)
                            }, i.prototype.getBodyDiff = function(t, e) {
                                e = e || [];
                                for (var i = this.tmpDict, s = t.length; s--;) {
                                    var n = t[s];
                                    i.set(0 | n.bodyA.id, 0 | n.bodyB.id, n)
                                }
                                for (s = i.keys.length; s--;) {
                                    var n = i.keys[s];
                                    e.push(n.bodyA, n.bodyB)
                                }
                                return i.reset(), e
                            }, s.prototype.set = function(t, e, i, n) {
                                s.call(this, t, e, i, n)
                            }
                        }, {
                            "./TupleDictionary": 46,
                            "./Utils": 47
                        }],
                        46: [function(t, e) {
                            function i() {
                                this.data = [], this.keys = []
                            }
                            var s = t("./Utils");
                            e.exports = i, i.prototype.getKey = function(t, e) {
                                return t = 0 | t, e = 0 | e, (0 | t) === (0 | e) ? -1 : 0 | ((0 | t) > (0 | e) ? t << 16 | 65535 & e : e << 16 | 65535 & t)
                            }, i.prototype.getByKey = function(t) {
                                return t = 0 | t, this.data[t]
                            }, i.prototype.get = function(t, e) {
                                t = 0 | t, e = 0 | e;
                                var i = 0 | this.getKey(t, e);
                                return this.data[i]
                            }, i.prototype.set = function(t, e, i) {
                                if (!i) throw new Error("No data!");
                                t = 0 | t, e = 0 | e;
                                var s = 0 | this.getKey(t, e);
                                return this.get(t, e) || this.keys.push(s), this.data[s] = i, s
                            }, i.prototype.reset = function() {
                                for (var t = this.data, e = this.keys, i = 0 | e.length; i--;) {
                                    var s = 0 | e[i];
                                    t[s] = void 0
                                }
                                e.length = 0
                            }, i.prototype.copy = function(t) {
                                this.reset(), s.appendArray(this.keys, t.keys);
                                for (var e = 0 | t.keys.length; e--;) {
                                    var i = 0 | t.keys[e];
                                    this.data[i] = t.data[i]
                                }
                            }
                        }, {
                            "./Utils": 47
                        }],
                        47: [function(t, e) {
                            function i() {}
                            e.exports = i, i.appendArray = function(t, e) {
                                if (e.length < 15e4) t.push.apply(t, e);
                                else
                                    for (var i = 0, s = e.length; i !== s; ++i) t.push(e[i])
                            }, i.splice = function(t, e, i) {
                                i = i || 1;
                                for (var s = e, n = t.length - i; n > s; s++) t[s] = t[s + i];
                                t.length = n
                            }, i.ARRAY_TYPE = window.Float32Array || Array, i.extend = function(t, e) {
                                for (var i in e) t[i] = e[i]
                            }, i.defaults = function(t, e) {
                                t = t || {};
                                for (var i in e) i in t || (t[i] = e[i]);
                                return t
                            }
                        }, {}],
                        48: [function(t, e) {
                            function i() {
                                this.equations = [], this.bodies = []
                            }
                            var s = t("../objects/Body");
                            e.exports = i, i.prototype.reset = function() {
                                this.equations.length = this.bodies.length = 0
                            };
                            var n = [];
                            i.prototype.getBodies = function(t) {
                                var e = t || [],
                                    i = this.equations;
                                n.length = 0;
                                for (var s = 0; s !== i.length; s++) {
                                    var r = i[s]; - 1 === n.indexOf(r.bodyA.id) && (e.push(r.bodyA), n.push(r.bodyA.id)), -1 === n.indexOf(r.bodyB.id) && (e.push(r.bodyB), n.push(r.bodyB.id))
                                }
                                return e
                            }, i.prototype.wantsToSleep = function() {
                                for (var t = 0; t < this.bodies.length; t++) {
                                    var e = this.bodies[t];
                                    if (e.motionState === s.DYNAMIC && !e.wantsToSleep) return !1
                                }
                                return !0
                            }, i.prototype.sleep = function() {
                                for (var t = 0; t < this.bodies.length; t++) {
                                    var e = this.bodies[t];
                                    e.sleep()
                                }
                                return !0
                            }
                        }, {
                            "../objects/Body": 31
                        }],
                        49: [function(t, e) {
                            function i() {
                                this._nodePool = [], this._islandPool = [], this.equations = [], this.islands = [], this.nodes = [], this.queue = []
                            }
                            var s = (t("../math/vec2"), t("./Island")),
                                n = t("./IslandNode"),
                                r = t("../objects/Body");
                            e.exports = i, i.getUnvisitedNode = function(t) {
                                for (var e = t.length, i = 0; i !== e; i++) {
                                    var s = t[i];
                                    if (!s.visited && s.body.motionState === r.DYNAMIC) return s
                                }
                                return !1
                            }, i.prototype.visit = function(t, e, i) {
                                e.push(t.body);
                                for (var s = t.equations.length, n = 0; n !== s; n++) {
                                    var r = t.equations[n]; - 1 === i.indexOf(r) && i.push(r)
                                }
                            }, i.prototype.bfs = function(t, e, s) {
                                var n = this.queue;
                                for (n.length = 0, n.push(t), t.visited = !0, this.visit(t, e, s); n.length;)
                                    for (var o, a = n.pop(); o = i.getUnvisitedNode(a.neighbors);) o.visited = !0, this.visit(o, e, s), o.body.motionState === r.DYNAMIC && n.push(o)
                            }, i.prototype.split = function(t) {
                                for (var e = t.bodies, r = this.nodes, o = this.equations; r.length;) this._nodePool.push(r.pop());
                                for (var a = 0; a !== e.length; a++)
                                    if (this._nodePool.length) {
                                        var h = this._nodePool.pop();
                                        h.reset(), h.body = e[a], r.push(h)
                                    } else r.push(new n(e[a]));
                                for (var l = 0; l !== o.length; l++) {
                                    var c = o[l],
                                        a = e.indexOf(c.bodyA),
                                        u = e.indexOf(c.bodyB),
                                        d = r[a],
                                        p = r[u];
                                    d.neighbors.push(p), p.neighbors.push(d), d.equations.push(c), p.equations.push(c)
                                }
                                for (var f = this.islands; f.length;) {
                                    var g = f.pop();
                                    g.reset(), this._islandPool.push(g)
                                }
                                for (var m; m = i.getUnvisitedNode(r);) {
                                    var g = this._islandPool.length ? this._islandPool.pop() : new s;
                                    this.bfs(m, g.bodies, g.equations), f.push(g)
                                }
                                return f
                            }
                        }, {
                            "../math/vec2": 30,
                            "../objects/Body": 31,
                            "./Island": 48,
                            "./IslandNode": 50
                        }],
                        50: [function(t, e) {
                            function i(t) {
                                this.body = t, this.neighbors = [], this.equations = [], this.visited = !1
                            }
                            e.exports = i, i.prototype.reset = function() {
                                this.equations.length = 0, this.neighbors.length = 0, this.visited = !1, this.body = null
                            }
                        }, {}],
                        51: [function(t, e) {
                            function i(t) {
                                y.apply(this), t = t || {}, this.springs = [], this.bodies = [], this.disabledBodyCollisionPairs = [], this.solver = t.solver || new o, this.narrowphase = new B(this), this.islandManager = new k, this.gravity = l.fromValues(0, -9.78), t.gravity && l.copy(this.gravity, t.gravity), this.frictionGravity = l.length(this.gravity) || 10, this.useWorldGravityAsFrictionGravity = !0, this.useFrictionGravityOnZeroGravity = !0, this.doProfiling = t.doProfiling || !1, this.lastStepTime = 0, this.broadphase = t.broadphase || new h, this.broadphase.setWorld(this), this.constraints = [], this.defaultMaterial = new _, this.defaultContactMaterial = new w(this.defaultMaterial, this.defaultMaterial), this.lastTimeStep = 1 / 60, this.applySpringForces = !0, this.applyDamping = !0, this.applyGravity = !0, this.solveConstraints = !0, this.contactMaterials = [], this.time = 0, this.stepping = !1, this.bodiesToBeRemoved = [], this.fixedStepTime = 0, this.islandSplit = "undefined" != typeof t.islandSplit ? !!t.islandSplit : !1, this.emitImpactEvent = !0, this._constraintIdCounter = 0, this._bodyIdCounter = 0, this.postStepEvent = {
                                    type: "postStep"
                                }, this.addBodyEvent = {
                                    type: "addBody",
                                    body: null
                                }, this.removeBodyEvent = {
                                    type: "removeBody",
                                    body: null
                                }, this.addSpringEvent = {
                                    type: "addSpring",
                                    spring: null
                                }, this.impactEvent = {
                                    type: "impact",
                                    bodyA: null,
                                    bodyB: null,
                                    shapeA: null,
                                    shapeB: null,
                                    contactEquation: null
                                }, this.postBroadphaseEvent = {
                                    type: "postBroadphase",
                                    pairs: null
                                }, this.enableBodySleeping = !1, this.enableIslandSleeping = !1, this.beginContactEvent = {
                                    type: "beginContact",
                                    shapeA: null,
                                    shapeB: null,
                                    bodyA: null,
                                    bodyB: null,
                                    contactEquations: []
                                }, this.endContactEvent = {
                                    type: "endContact",
                                    shapeA: null,
                                    shapeB: null,
                                    bodyA: null,
                                    bodyB: null
                                }, this.preSolveEvent = {
                                    type: "preSolve",
                                    contactEquations: null,
                                    frictionEquations: null
                                }, this.overlappingShapesLastState = {
                                    keys: []
                                }, this.overlappingShapesCurrentState = {
                                    keys: []
                                }, this.overlapKeeper = new I
                            }

                            function s(t) {
                                return t ? [t[0], t[1]] : t
                            }

                            function n(t, e) {
                                for (var i in e) t[i] = e[i]
                            }

                            function r(t) {
                                return {
                                    id: t.id,
                                    materialA: t.materialA.id,
                                    materialB: t.materialB.id,
                                    friction: t.friction,
                                    restitution: t.restitution,
                                    stiffness: t.stiffness,
                                    relaxation: t.relaxation,
                                    frictionStiffness: t.frictionStiffness,
                                    frictionRelaxation: t.frictionRelaxation
                                }
                            }
                            var o = t("../solver/GSSolver"),
                                a = t("../solver/Solver"),
                                h = t("../collision/NaiveBroadphase"),
                                l = t("../math/vec2"),
                                c = t("../shapes/Circle"),
                                u = t("../shapes/Rectangle"),
                                d = t("../shapes/Convex"),
                                p = t("../shapes/Line"),
                                f = t("../shapes/Plane"),
                                g = t("../shapes/Capsule"),
                                m = t("../shapes/Particle"),
                                y = t("../events/EventEmitter"),
                                v = t("../objects/Body"),
                                x = t("../shapes/Shape"),
                                b = t("../objects/Spring"),
                                _ = t("../material/Material"),
                                w = t("../material/ContactMaterial"),
                                P = t("../constraints/DistanceConstraint"),
                                T = t("../constraints/Constraint"),
                                S = t("../constraints/LockConstraint"),
                                C = t("../constraints/RevoluteConstraint"),
                                A = t("../constraints/PrismaticConstraint"),
                                E = t("../constraints/GearConstraint"),
                                M = t("../../package.json"),
                                L = t("../collision/Broadphase"),
                                R = t("../collision/SAPBroadphase"),
                                B = t("../collision/Narrowphase"),
                                O = t("../utils/Utils"),
                                I = t("../utils/OverlapKeeper"),
                                k = t("./IslandManager");
                            if (e.exports = i, "undefined" == typeof performance && (performance = {}), !performance.now) {
                                var D = Date.now();
                                performance.timing && performance.timing.navigationStart && (D = performance.timing.navigationStart), performance.now = function() {
                                    return Date.now() - D
                                }
                            }
                            i.prototype = new Object(y.prototype), i.prototype.addConstraint = function(t) {
                                this.constraints.push(t)
                            }, i.prototype.addContactMaterial = function(t) {
                                this.contactMaterials.push(t)
                            }, i.prototype.removeContactMaterial = function(t) {
                                var e = this.contactMaterials.indexOf(t); - 1 !== e && O.splice(this.contactMaterials, e, 1)
                            }, i.prototype.getContactMaterial = function(t, e) {
                                for (var i = this.contactMaterials, s = 0, n = i.length; s !== n; s++) {
                                    var r = i[s];
                                    if (r.materialA === t && r.materialB === e || r.materialA === e && r.materialB === t) return r
                                }
                                return !1
                            }, i.prototype.removeConstraint = function(t) {
                                var e = this.constraints.indexOf(t); - 1 !== e && O.splice(this.constraints, e, 1)
                            };
                            var F = (l.create(), l.create(), l.create(), l.create(), l.create(), l.create(), l.create()),
                                G = l.fromValues(0, 0),
                                U = l.fromValues(0, 0),
                                N = (l.fromValues(0, 0), l.fromValues(0, 0));
                            i.prototype.step = function(t, e, i) {
                                if (i = i || 10, e = e || 0, 0 === e) this.internalStep(t), this.time += t;
                                else {
                                    var s = Math.floor((this.time + e) / t) - Math.floor(this.time / t);
                                    s = Math.min(s, i);
                                    for (var n = 0; n !== s; n++) this.internalStep(t);
                                    this.time += e;
                                    for (var r = this.time % t, o = r / t, a = 0; a !== this.bodies.length; a++) {
                                        var h = this.bodies[a];
                                        h.motionState !== v.STATIC && h.sleepState !== v.SLEEPING ? (l.sub(N, h.position, h.previousPosition), l.scale(N, N, o), l.add(h.interpolatedPosition, h.position, N), h.interpolatedAngle = h.angle + (h.angle - h.previousAngle) * o) : (l.copy(h.interpolatedPosition, h.position), h.interpolatedAngle = h.angle)
                                    }
                                }
                            };
                            var j = [];
                            i.prototype.internalStep = function(t) {
                                this.stepping = !0;
                                var e, s, n = this,
                                    r = this.doProfiling,
                                    o = this.springs.length,
                                    a = this.springs,
                                    h = this.bodies,
                                    c = this.gravity,
                                    u = this.solver,
                                    d = this.bodies.length,
                                    p = this.broadphase,
                                    f = this.narrowphase,
                                    g = this.constraints,
                                    m = F,
                                    y = (l.scale, l.add),
                                    x = (l.rotate, this.islandManager);
                                if (this.lastTimeStep = t, r && (e = performance.now()), this.useWorldGravityAsFrictionGravity) {
                                    var b = l.length(this.gravity);
                                    0 === b && this.useFrictionGravityOnZeroGravity || (this.frictionGravity = b)
                                }
                                if (this.applyGravity)
                                    for (var _ = 0; _ !== d; _++) {
                                        var w = h[_],
                                            P = w.force;
                                        w.motionState === v.DYNAMIC && w.sleepState !== v.SLEEPING && (l.scale(m, c, w.mass * w.gravityScale), y(P, P, m))
                                    }
                                if (this.applySpringForces)
                                    for (var _ = 0; _ !== o; _++) {
                                        var T = a[_];
                                        T.applyForce()
                                    }
                                if (this.applyDamping)
                                    for (var _ = 0; _ !== d; _++) {
                                        var w = h[_];
                                        w.motionState === v.DYNAMIC && w.applyDamping(t)
                                    }
                                for (var S = p.getCollisionPairs(this), C = this.disabledBodyCollisionPairs, _ = C.length - 2; _ >= 0; _ -= 2)
                                    for (var A = S.length - 2; A >= 0; A -= 2)(C[_] === S[A] && C[_ + 1] === S[A + 1] || C[_ + 1] === S[A] && C[_] === S[A + 1]) && S.splice(A, 2);
                                var E = g.length;
                                for (_ = 0; _ !== E; _++) {
                                    var M = g[_];
                                    if (!M.collideConnected)
                                        for (var A = S.length - 2; A >= 0; A -= 2)(M.bodyA === S[A] && M.bodyB === S[A + 1] || M.bodyB === S[A] && M.bodyA === S[A + 1]) && S.splice(A, 2)
                                }
                                this.postBroadphaseEvent.pairs = S, this.emit(this.postBroadphaseEvent), f.reset(this);
                                for (var _ = 0, L = S.length; _ !== L; _ += 2)
                                    for (var R = S[_], B = S[_ + 1], I = 0, k = R.shapes.length; I !== k; I++)
                                        for (var D = R.shapes[I], G = R.shapeOffsets[I], U = R.shapeAngles[I], N = 0, W = B.shapes.length; N !== W; N++) {
                                            var X = B.shapes[N],
                                                V = B.shapeOffsets[N],
                                                q = B.shapeAngles[N],
                                                H = this.defaultContactMaterial;
                                            if (D.material && X.material) {
                                                var Y = this.getContactMaterial(D.material, X.material);
                                                Y && (H = Y)
                                            }
                                            this.runNarrowphase(f, R, D, G, U, B, X, V, q, H, this.frictionGravity)
                                        }
                                for (var _ = 0; _ !== d; _++) {
                                    var z = h[_];
                                    z._wakeUpAfterNarrowphase && (z.wakeUp(), z._wakeUpAfterNarrowphase = !1)
                                }
                                if (this.has("endContact")) {
                                    this.overlapKeeper.getEndOverlaps(j);
                                    for (var K = this.endContactEvent, N = j.length; N--;) {
                                        var J = j[N];
                                        K.shapeA = J.shapeA, K.shapeB = J.shapeB, K.bodyA = J.bodyA, K.bodyB = J.bodyA, this.emit(K)
                                    }
                                }
                                this.overlapKeeper.tick();
                                var Z = this.preSolveEvent;
                                Z.contactEquations = f.contactEquations, Z.frictionEquations = f.frictionEquations, this.emit(Z);
                                var E = g.length;
                                for (_ = 0; _ !== E; _++) g[_].update();
                                if (f.contactEquations.length || f.frictionEquations.length || g.length)
                                    if (this.islandSplit) {
                                        for (x.equations.length = 0, O.appendArray(x.equations, f.contactEquations), O.appendArray(x.equations, f.frictionEquations), _ = 0; _ !== E; _++) O.appendArray(x.equations, g[_].equations);
                                        x.split(this);
                                        for (var _ = 0; _ !== x.islands.length; _++) {
                                            var Q = x.islands[_];
                                            Q.equations.length && u.solveIsland(t, Q)
                                        }
                                    } else {
                                        for (u.addEquations(f.contactEquations), u.addEquations(f.frictionEquations), _ = 0; _ !== E; _++) u.addEquations(g[_].equations);
                                        this.solveConstraints && u.solve(t, this), u.removeAllEquations()
                                    }
                                for (var _ = 0; _ !== d; _++) {
                                    var z = h[_];
                                    z.sleepState !== v.SLEEPING && z.motionState !== v.STATIC && i.integrateBody(z, t)
                                }
                                for (var _ = 0; _ !== d; _++) h[_].setZeroForce();
                                if (r && (s = performance.now(), n.lastStepTime = s - e), this.emitImpactEvent && this.has("impact"))
                                    for (var $ = this.impactEvent, _ = 0; _ !== f.contactEquations.length; _++) {
                                        var te = f.contactEquations[_];
                                        te.firstImpact && ($.bodyA = te.bodyA, $.bodyB = te.bodyB, $.shapeA = te.shapeA, $.shapeB = te.shapeB, $.contactEquation = te, this.emit($))
                                    }
                                if (this.enableBodySleeping)
                                    for (_ = 0; _ !== d; _++) h[_].sleepTick(this.time, !1, t);
                                else if (this.enableIslandSleeping && this.islandSplit) {
                                    for (_ = 0; _ !== d; _++) h[_].sleepTick(this.time, !0, t);
                                    for (var _ = 0; _ < this.islandManager.islands.length; _++) {
                                        var Q = this.islandManager.islands[_];
                                        Q.wantsToSleep() && Q.sleep()
                                    }
                                }
                                if (this.stepping = !1, this.bodiesToBeRemoved.length) {
                                    for (var _ = 0; _ !== this.bodiesToBeRemoved.length; _++) this.removeBody(this.bodiesToBeRemoved[_]);
                                    this.bodiesToBeRemoved.length = 0
                                }
                                this.emit(this.postStepEvent)
                            };
                            var W = l.create(),
                                X = l.create();
                            i.integrateBody = function(t, e) {
                                var i = t.invMass,
                                    s = t.force,
                                    n = t.position,
                                    r = t.velocity;
                                l.copy(t.previousPosition, t.position), t.previousAngle = t.angle, t.fixedRotation || (t.angularVelocity += t.angularForce * t.invInertia * e, t.angle += t.angularVelocity * e), l.scale(W, s, e * i), l.add(r, W, r), l.scale(X, r, e), l.add(n, n, X), t.aabbNeedsUpdate = !0
                            }, i.prototype.runNarrowphase = function(t, e, i, s, n, r, o, a, h, c, u) {
                                if (0 !== (i.collisionGroup & o.collisionMask) && 0 !== (o.collisionGroup & i.collisionMask)) {
                                    l.rotate(G, s, e.angle), l.rotate(U, a, r.angle), l.add(G, G, e.position), l.add(U, U, r.position);
                                    var d = n + e.angle,
                                        p = h + r.angle;
                                    t.enableFriction = c.friction > 0, t.frictionCoefficient = c.friction;
                                    var f;
                                    f = e.motionState === v.STATIC || e.motionState === v.KINEMATIC ? r.mass : r.motionState === v.STATIC || r.motionState === v.KINEMATIC ? e.mass : e.mass * r.mass / (e.mass + r.mass), t.slipForce = c.friction * u * f, t.restitution = c.restitution, t.surfaceVelocity = c.surfaceVelocity, t.frictionStiffness = c.frictionStiffness, t.frictionRelaxation = c.frictionRelaxation, t.stiffness = c.stiffness, t.relaxation = c.relaxation;
                                    var g = t[i.type | o.type],
                                        m = 0;
                                    if (g) {
                                        var y = i.sensor || o.sensor,
                                            x = t.frictionEquations.length;
                                        m = i.type < o.type ? g.call(t, e, i, G, d, r, o, U, p, y) : g.call(t, r, o, U, p, e, i, G, d, y);
                                        var b = t.frictionEquations.length - x;
                                        if (m) {
                                            if (e.allowSleep && e.motionState === v.DYNAMIC && e.sleepState === v.SLEEPING && r.sleepState === v.AWAKE && r.motionState !== v.STATIC) {
                                                var _ = l.squaredLength(r.velocity) + Math.pow(r.angularVelocity, 2),
                                                    w = Math.pow(r.sleepSpeedLimit, 2);
                                                _ >= 2 * w && (e._wakeUpAfterNarrowphase = !0)
                                            }
                                            if (r.allowSleep && r.motionState === v.DYNAMIC && r.sleepState === v.SLEEPING && e.sleepState === v.AWAKE && e.motionState !== v.STATIC) {
                                                var P = l.squaredLength(e.velocity) + Math.pow(e.angularVelocity, 2),
                                                    T = Math.pow(e.sleepSpeedLimit, 2);
                                                P >= 2 * T && (r._wakeUpAfterNarrowphase = !0)
                                            }
                                            if (this.overlapKeeper.setOverlapping(e, i, r, o), this.has("beginContact") && this.overlapKeeper.isNewOverlap(i, o)) {
                                                var S = this.beginContactEvent;
                                                if (S.shapeA = i, S.shapeB = o, S.bodyA = e, S.bodyB = r, S.contactEquations.length = 0, "number" == typeof m)
                                                    for (var C = t.contactEquations.length - m; C < t.contactEquations.length; C++) S.contactEquations.push(t.contactEquations[C]);
                                                this.emit(S)
                                            }
                                            if ("number" == typeof m && b > 1)
                                                for (var C = t.frictionEquations.length - b; C < t.frictionEquations.length; C++) {
                                                    var A = t.frictionEquations[C];
                                                    A.setSlipForce(A.getSlipForce() / b)
                                                }
                                        }
                                    }
                                }
                            }, i.prototype.addSpring = function(t) {
                                this.springs.push(t), this.addSpringEvent.spring = t, this.emit(this.addSpringEvent)
                            }, i.prototype.removeSpring = function(t) {
                                var e = this.springs.indexOf(t); - 1 === e && O.splice(this.springs, e, 1)
                            }, i.prototype.addBody = function(t) {
                                -1 === this.bodies.indexOf(t) && (this.bodies.push(t), t.world = this, this.addBodyEvent.body = t, this.emit(this.addBodyEvent))
                            }, i.prototype.removeBody = function(t) {
                                if (this.stepping) this.bodiesToBeRemoved.push(t);
                                else {
                                    t.world = null;
                                    var e = this.bodies.indexOf(t); - 1 !== e && (O.splice(this.bodies, e, 1), this.removeBodyEvent.body = t, t.resetConstraintVelocity(), this.emit(this.removeBodyEvent))
                                }
                            }, i.prototype.getBodyById = function(t) {
                                for (var e = this.bodies, i = 0; i < e.length; i++) {
                                    var s = e[i];
                                    if (s.id === t) return s
                                }
                                return !1
                            }, i.prototype.disableBodyCollision = function(t, e) {
                                this.disabledBodyCollisionPairs.push(t, e)
                            }, i.prototype.enableBodyCollision = function(t, e) {
                                for (var i = this.disabledBodyCollisionPairs, s = 0; s < i.length; s += 2)
                                    if (i[s] === t && i[s + 1] === e || i[s + 1] === t && i[s] === e) return void i.splice(s, 2)
                            }, i.prototype.toJSON = function() {
                                var t = this,
                                    e = {
                                        p2: M.version,
                                        bodies: [],
                                        springs: [],
                                        solver: {},
                                        gravity: s(t.gravity),
                                        broadphase: {},
                                        distanceConstraints: [],
                                        revoluteConstraints: [],
                                        prismaticConstraints: [],
                                        lockConstraints: [],
                                        gearConstraints: [],
                                        contactMaterials: [],
                                        materials: [],
                                        defaultContactMaterial: r(t.defaultContactMaterial),
                                        islandSplit: t.islandSplit,
                                        enableIslandSleeping: t.enableIslandSleeping,
                                        enableBodySleeping: t.enableBodySleeping
                                    },
                                    i = e.solver,
                                    o = t.solver;
                                o.type === a.GS && (i.type = "GSSolver", i.iterations = o.iterations);
                                var h = e.broadphase,
                                    l = t.broadphase;
                                l.type === L.NAIVE ? h.type = "NaiveBroadphase" : l.type === L.SAP ? h.type = "SAPBroadphase" : console.error("Broadphase not supported: " + l.type);
                                for (var c = 0; c !== t.springs.length; c++) {
                                    var o = t.springs[c];
                                    e.springs.push({
                                        bodyA: t.bodies.indexOf(o.bodyA),
                                        bodyB: t.bodies.indexOf(o.bodyB),
                                        stiffness: o.stiffness,
                                        damping: o.damping,
                                        restLength: o.restLength,
                                        localAnchorA: s(o.localAnchorA),
                                        localAnchorB: s(o.localAnchorB)
                                    })
                                }
                                for (var c = 0; c < t.constraints.length; c++) {
                                    var u = t.constraints[c],
                                        d = {
                                            bodyA: t.bodies.indexOf(u.bodyA),
                                            bodyB: t.bodies.indexOf(u.bodyB),
                                            collideConnected: u.collideConnected
                                        };
                                    switch (u.type) {
                                        case T.DISTANCE:
                                            n(d, {
                                                distance: u.distance,
                                                maxForce: u.getMaxForce()
                                            }), e.distanceConstraints.push(d);
                                            break;
                                        case T.REVOLUTE:
                                            n(d, {
                                                pivotA: s(u.pivotA),
                                                pivotB: s(u.pivotB),
                                                maxForce: u.maxForce,
                                                motorSpeed: u.getMotorSpeed() || 0,
                                                motorEnabled: !!u.getMotorSpeed(),
                                                lowerLimit: u.lowerLimit,
                                                lowerLimitEnabled: u.lowerLimitEnabled,
                                                upperLimit: u.upperLimit,
                                                upperLimitEnabled: u.upperLimitEnabled
                                            }), e.revoluteConstraints.push(d);
                                            break;
                                        case T.PRISMATIC:
                                            n(d, {
                                                localAxisA: s(u.localAxisA),
                                                localAnchorA: s(u.localAnchorA),
                                                localAnchorB: s(u.localAnchorB),
                                                maxForce: u.maxForce,
                                                upperLimitEnabled: u.upperLimitEnabled,
                                                lowerLimitEnabled: u.lowerLimitEnabled,
                                                upperLimit: u.upperLimit,
                                                lowerLimit: u.lowerLimit,
                                                motorEnabled: u.motorEnabled,
                                                motorSpeed: u.motorSpeed
                                            }), e.prismaticConstraints.push(d);
                                            break;
                                        case T.LOCK:
                                            n(d, {
                                                localOffsetB: s(u.localOffsetB),
                                                localAngleB: u.localAngleB,
                                                maxForce: u.getMaxForce()
                                            }), e.lockConstraints.push(d);
                                            break;
                                        case T.GEAR:
                                            n(d, {
                                                angle: u.angle,
                                                ratio: u.ratio,
                                                maxForce: u.maxForce || 1e6
                                            }), e.gearConstraints.push(d);
                                            break;
                                        default:
                                            console.error("Constraint not supported yet: ", u.type)
                                    }
                                }
                                for (var c = 0; c !== t.bodies.length; c++) {
                                    var p = t.bodies[c],
                                        f = p.shapes,
                                        g = {
                                            id: p.id,
                                            mass: p.mass,
                                            angle: p.angle,
                                            position: s(p.position),
                                            velocity: s(p.velocity),
                                            angularVelocity: p.angularVelocity,
                                            force: s(p.force),
                                            motionState: p.motionState,
                                            fixedRotation: p.fixedRotation,
                                            circleShapes: [],
                                            planeShapes: [],
                                            particleShapes: [],
                                            lineShapes: [],
                                            rectangleShapes: [],
                                            convexShapes: [],
                                            capsuleShapes: []
                                        };
                                    p.concavePath && (g.concavePath = p.concavePath);
                                    for (var m = 0; m < f.length; m++) {
                                        var o = f[m],
                                            y = {};
                                        switch (y.offset = s(p.shapeOffsets[m]), y.angle = p.shapeAngles[m], y.collisionGroup = o.collisionGroup, y.collisionMask = o.collisionMask, y.material = o.material ? o.material.id : null, o.type) {
                                            case x.CIRCLE:
                                                n(y, {
                                                    radius: o.radius
                                                }), g.circleShapes.push(y);
                                                break;
                                            case x.PLANE:
                                                g.planeShapes.push(y);
                                                break;
                                            case x.PARTICLE:
                                                g.particleShapes.push(y);
                                                break;
                                            case x.LINE:
                                                y.length = o.length, g.lineShapes.push(y);
                                                break;
                                            case x.RECTANGLE:
                                                n(y, {
                                                    width: o.width,
                                                    height: o.height
                                                }), g.rectangleShapes.push(y);
                                                break;
                                            case x.CONVEX:
                                                for (var v = [], b = 0; b < o.vertices.length; b++) v.push(s(o.vertices[b]));
                                                n(y, {
                                                    vertices: v
                                                }), g.convexShapes.push(y);
                                                break;
                                            case x.CAPSULE:
                                                n(y, {
                                                    length: o.length,
                                                    radius: o.radius
                                                }), g.capsuleShapes.push(y);
                                                break;
                                            default:
                                                console.error("Shape type not supported yet!")
                                        }
                                    }
                                    e.bodies.push(g)
                                }
                                for (var c = 0; c < t.contactMaterials.length; c++) {
                                    var _ = t.contactMaterials[c];
                                    e.contactMaterials.push(r(_))
                                }
                                for (var w = {}, c = 0; c < t.contactMaterials.length; c++) {
                                    var _ = t.contactMaterials[c];
                                    w[_.materialA.id + ""] = _.materialA, w[_.materialB.id + ""] = _.materialB
                                }
                                for (var P in w) {
                                    var S = w[parseInt(P)];
                                    e.materials.push({
                                        id: S.id
                                    })
                                }
                                return e
                            }, i.prototype.fromJSON = function(t) {
                                function e(t, e, i) {
                                    e.collisionMask = i.collisionMask, e.collisionGroup = i.collisionGroup, i.material && (e.material = a[i.material + ""]), t.addShape(e, i.offset, i.angle)
                                }
                                if (this.clear(), !t.p2) return !1;
                                var i = this;
                                switch (l.copy(i.gravity, t.gravity), i.islandSplit = t.islandSplit, i.enableIslandSleeping = t.enableIslandSleeping, i.enableBodySleeping = t.enableBodySleeping, t.solver.type) {
                                    case "GSSolver":
                                        var s = t.solver,
                                            n = new o;
                                        i.solver = n, n.iterations = s.iterations;
                                        break;
                                    default:
                                        throw new Error("Solver type not recognized: " + t.solver.type)
                                }
                                switch (t.broadphase.type) {
                                    case "NaiveBroadphase":
                                        i.broadphase = new h;
                                        break;
                                    case "SAPBroadphase":
                                        i.broadphase = new R
                                }
                                i.broadphase.setWorld(i);
                                for (var r = i.bodies, a = {}, y = 0; y !== t.materials.length; y++) {
                                    var x = t.materials[y],
                                        T = new _;
                                    a[x.id + ""] = T, T.id = x.id
                                }
                                i.defaultMaterial.id = t.defaultContactMaterial.materialA;
                                for (var y = 0; y !== t.bodies.length; y++) {
                                    var M = t.bodies[y],
                                        L = new v({
                                            mass: M.mass,
                                            position: M.position,
                                            angle: M.angle,
                                            velocity: M.velocity,
                                            angularVelocity: M.angularVelocity,
                                            force: M.force,
                                            fixedRotation: M.fixedRotation
                                        });
                                    L.id = M.id, L.motionState = M.motionState;
                                    for (var B = 0; B < M.circleShapes.length; B++) {
                                        var n = M.circleShapes[B];
                                        e(L, new c(n.radius), n)
                                    }
                                    for (var B = 0; B < M.planeShapes.length; B++) {
                                        var n = M.planeShapes[B];
                                        e(L, new f, n)
                                    }
                                    for (var B = 0; B < M.particleShapes.length; B++) {
                                        var n = M.particleShapes[B];
                                        e(L, new m, n)
                                    }
                                    for (var B = 0; B < M.lineShapes.length; B++) {
                                        var n = M.lineShapes[B];
                                        e(L, new p(n.length), n)
                                    }
                                    for (var B = 0; B < M.rectangleShapes.length; B++) {
                                        var n = M.rectangleShapes[B];
                                        e(L, new u(n.width, n.height), n)
                                    }
                                    for (var B = 0; B < M.convexShapes.length; B++) {
                                        var n = M.convexShapes[B];
                                        e(L, new d(n.vertices), n)
                                    }
                                    for (var B = 0; B < M.capsuleShapes.length; B++) {
                                        var n = M.capsuleShapes[B];
                                        e(L, new g(n.length, n.radius), n)
                                    }
                                    M.concavePath && (L.concavePath = M.concavePath), i.addBody(L)
                                }
                                for (var y = 0; y < t.springs.length; y++) {
                                    var s = t.springs[y],
                                        O = r[s.bodyA],
                                        I = r[s.bodyB];
                                    if (!O) return this.error = "instance.springs[" + y + "] references instance.body[" + s.bodyA + "], which does not exist.", !1;
                                    if (!I) return this.error = "instance.springs[" + y + "] references instance.body[" + s.bodyB + "], which does not exist.", !1;
                                    var n = new b(O, I, {
                                        stiffness: s.stiffness,
                                        damping: s.damping,
                                        restLength: s.restLength,
                                        localAnchorA: s.localAnchorA,
                                        localAnchorB: s.localAnchorB
                                    });
                                    i.addSpring(n)
                                }
                                for (var y = 0; y < t.contactMaterials.length; y++) {
                                    var x = t.contactMaterials[y],
                                        k = a[x.materialA + ""],
                                        D = a[x.materialB + ""];
                                    if (!k) return this.error = "Reference to material id " + x.materialA + ": material not found", !1;
                                    if (!D) return this.error = "Reference to material id " + x.materialB + ": material not found", !1;
                                    var F = new w(k, D, {
                                        friction: x.friction,
                                        restitution: x.restitution,
                                        stiffness: x.stiffness,
                                        relaxation: x.relaxation,
                                        frictionStiffness: x.frictionStiffness,
                                        frictionRelaxation: x.frictionRelaxation
                                    });
                                    F.id = x.id, i.addContactMaterial(F)
                                }
                                var x = t.defaultContactMaterial,
                                    k = i.defaultMaterial,
                                    D = i.defaultMaterial,
                                    F = new w(k, D, {
                                        friction: x.friction,
                                        restitution: x.restitution,
                                        stiffness: x.stiffness,
                                        relaxation: x.relaxation,
                                        frictionStiffness: x.frictionStiffness,
                                        frictionRelaxation: x.frictionRelaxation
                                    });
                                F.id = x.id, i.defaultContactMaterial = F;
                                for (var y = 0; y < t.distanceConstraints.length; y++) {
                                    var G = t.distanceConstraints[y];
                                    i.addConstraint(new P(r[G.bodyA], r[G.bodyB], G.distance, {
                                        maxForce: G.maxForce,
                                        collideConnected: G.collideConnected
                                    }))
                                }
                                for (var y = 0; y < t.revoluteConstraints.length; y++) {
                                    var G = t.revoluteConstraints[y],
                                        U = new C(r[G.bodyA], G.pivotA, r[G.bodyB], G.pivotB, {
                                            maxForce: G.maxForce,
                                            collideConnected: G.collideConnected
                                        });
                                    G.motorEnabled && U.enableMotor(), U.setMotorSpeed(G.motorSpeed), U.lowerLimit = G.lowerLimit, U.upperLimit = G.upperLimit, U.lowerLimitEnabled = G.lowerLimitEnabled, U.upperLimitEnabled = G.upperLimitEnabled, i.addConstraint(U)
                                }
                                for (var y = 0; y < t.prismaticConstraints.length; y++) {
                                    var G = t.prismaticConstraints[y],
                                        N = new A(r[G.bodyA], r[G.bodyB], {
                                            maxForce: G.maxForce,
                                            localAxisA: G.localAxisA,
                                            localAnchorA: G.localAnchorA,
                                            localAnchorB: G.localAnchorB,
                                            collideConnected: G.collideConnected
                                        });
                                    N.motorSpeed = G.motorSpeed, i.addConstraint(N)
                                }
                                for (var y = 0; y < t.lockConstraints.length; y++) {
                                    var G = t.lockConstraints[y];
                                    i.addConstraint(new S(r[G.bodyA], r[G.bodyB], {
                                        maxForce: G.maxForce,
                                        localOffsetB: G.localOffsetB,
                                        localAngleB: G.localAngleB,
                                        collideConnected: G.collideConnected
                                    }))
                                }
                                for (var y = 0; y < t.gearConstraints.length; y++) {
                                    var G = t.gearConstraints[y];
                                    i.addConstraint(new E(r[G.bodyA], r[G.bodyB], {
                                        maxForce: G.maxForce,
                                        angle: G.angle,
                                        ratio: G.ratio,
                                        collideConnected: G.collideConnected
                                    }))
                                }
                                return !0
                            }, i.prototype.clear = function() {
                                this.time = 0, this.fixedStepTime = 0, this.solver && this.solver.equations.length && this.solver.removeAllEquations();
                                for (var t = this.constraints, e = t.length - 1; e >= 0; e--) this.removeConstraint(t[e]);
                                for (var s = this.bodies, e = s.length - 1; e >= 0; e--) this.removeBody(s[e]);
                                for (var n = this.springs, e = n.length - 1; e >= 0; e--) this.removeSpring(n[e]);
                                for (var r = this.contactMaterials, e = r.length - 1; e >= 0; e--) this.removeContactMaterial(r[e]);
                                i.apply(this)
                            }, i.prototype.clone = function() {
                                var t = new i;
                                return t.fromJSON(this.toJSON()), t
                            };
                            var V = l.create(),
                                q = l.fromValues(0, 0),
                                H = l.fromValues(0, 0);
                            i.prototype.hitTest = function(t, e, i) {
                                i = i || 0;
                                var s = new v({
                                        position: t
                                    }),
                                    n = new m,
                                    r = t,
                                    o = 0,
                                    a = V,
                                    h = q,
                                    u = H;
                                s.addShape(n);
                                for (var p = this.narrowphase, y = [], x = 0, b = e.length; x !== b; x++)
                                    for (var _ = e[x], w = 0, P = _.shapes.length; w !== P; w++) {
                                        var T = _.shapes[w],
                                            S = _.shapeOffsets[w] || h,
                                            C = _.shapeAngles[w] || 0;
                                        l.rotate(a, S, _.angle), l.add(a, a, _.position);
                                        var A = C + _.angle;
                                        (T instanceof c && p.circleParticle(_, T, a, A, s, n, r, o, !0) || T instanceof d && p.particleConvex(s, n, r, o, _, T, a, A, !0) || T instanceof f && p.particlePlane(s, n, r, o, _, T, a, A, !0) || T instanceof g && p.particleCapsule(s, n, r, o, _, T, a, A, !0) || T instanceof m && l.squaredLength(l.sub(u, a, t)) < i * i) && y.push(_)
                                    }
                                return y
                            }, i.prototype.setGlobalEquationParameters = function(t) {
                                t = t || {};
                                for (var e = 0; e !== this.constraints.length; e++)
                                    for (var i = this.constraints[e], s = 0; s !== i.equations.length; s++) {
                                        var n = i.equations[s];
                                        "undefined" != typeof t.stiffness && (n.stiffness = t.stiffness), "undefined" != typeof t.relaxation && (n.relaxation = t.relaxation), n.needsUpdate = !0
                                    }
                                for (var e = 0; e !== this.contactMaterials.length; e++) {
                                    var i = this.contactMaterials[e];
                                    "undefined" != typeof t.stiffness && (i.stiffness = t.stiffness, i.frictionStiffness = t.stiffness), "undefined" != typeof t.relaxation && (i.relaxation = t.relaxation, i.frictionRelaxation = t.relaxation)
                                }
                                var i = this.defaultContactMaterial;
                                "undefined" != typeof t.stiffness && (i.stiffness = t.stiffness, i.frictionStiffness = t.stiffness), "undefined" != typeof t.relaxation && (i.relaxation = t.relaxation, i.frictionRelaxation = t.relaxation)
                            }, i.prototype.setGlobalStiffness = function(t) {
                                this.setGlobalEquationParameters({
                                    stiffness: t
                                })
                            }, i.prototype.setGlobalRelaxation = function(t) {
                                this.setGlobalEquationParameters({
                                    relaxation: t
                                })
                            }
                        }, {
                            "../../package.json": 7,
                            "../collision/Broadphase": 9,
                            "../collision/NaiveBroadphase": 11,
                            "../collision/Narrowphase": 12,
                            "../collision/SAPBroadphase": 13,
                            "../constraints/Constraint": 14,
                            "../constraints/DistanceConstraint": 15,
                            "../constraints/GearConstraint": 16,
                            "../constraints/LockConstraint": 17,
                            "../constraints/PrismaticConstraint": 18,
                            "../constraints/RevoluteConstraint": 19,
                            "../events/EventEmitter": 26,
                            "../material/ContactMaterial": 27,
                            "../material/Material": 28,
                            "../math/vec2": 30,
                            "../objects/Body": 31,
                            "../objects/Spring": 32,
                            "../shapes/Capsule": 34,
                            "../shapes/Circle": 35,
                            "../shapes/Convex": 36,
                            "../shapes/Line": 38,
                            "../shapes/Particle": 39,
                            "../shapes/Plane": 40,
                            "../shapes/Rectangle": 41,
                            "../shapes/Shape": 42,
                            "../solver/GSSolver": 43,
                            "../solver/Solver": 44,
                            "../utils/OverlapKeeper": 45,
                            "../utils/Utils": 47,
                            "./IslandManager": 49
                        }]
                    }, {}, [33])(33)
                }), p2.Body.prototype.parent = null, p2.Spring.prototype.parent = null, Phaser.Physics.P2 = function(t, e) {
                    this.game = t, "undefined" != typeof e && e.hasOwnProperty("gravity") && e.hasOwnProperty("broadphase") || (e = {
                        gravity: [0, 0],
                        broadphase: new p2.SAPBroadphase
                    }), this.world = new p2.World(e), this.frameRate = 1 / 60, this.useElapsedTime = !1, this.paused = !1, this.materials = [], this.gravity = new Phaser.Physics.P2.InversePointProxy(this, this.world.gravity), this.walls = {
                        left: null,
                        right: null,
                        top: null,
                        bottom: null
                    }, this.onBodyAdded = new Phaser.Signal, this.onBodyRemoved = new Phaser.Signal, this.onSpringAdded = new Phaser.Signal, this.onSpringRemoved = new Phaser.Signal, this.onConstraintAdded = new Phaser.Signal, this.onConstraintRemoved = new Phaser.Signal, this.onContactMaterialAdded = new Phaser.Signal, this.onContactMaterialRemoved = new Phaser.Signal, this.postBroadphaseCallback = null, this.callbackContext = null, this.onBeginContact = new Phaser.Signal, this.onEndContact = new Phaser.Signal, e.hasOwnProperty("mpx") && e.hasOwnProperty("pxm") && e.hasOwnProperty("mpxi") && e.hasOwnProperty("pxmi") && (this.mpx = e.mpx, this.mpxi = e.mpxi, this.pxm = e.pxm, this.pxmi = e.pxmi), this.world.on("beginContact", this.beginContactHandler, this), this.world.on("endContact", this.endContactHandler, this), this.collisionGroups = [], this.nothingCollisionGroup = new Phaser.Physics.P2.CollisionGroup(1), this.boundsCollisionGroup = new Phaser.Physics.P2.CollisionGroup(2), this.everythingCollisionGroup = new Phaser.Physics.P2.CollisionGroup(2147483648), this.boundsCollidesWith = [], this._toRemove = [], this._collisionGroupID = 2, this.setBoundsToWorld(!0, !0, !0, !0, !1)
                }, Phaser.Physics.P2.prototype = {
                    removeBodyNextStep: function(t) {
                        this._toRemove.push(t)
                    },
                    preUpdate: function() {
                        for (var t = this._toRemove.length; t--;) this.removeBody(this._toRemove[t]);
                        this._toRemove.length = 0
                    },
                    enable: function(t, e, i) {
                        "undefined" == typeof e && (e = !1), "undefined" == typeof i && (i = !0);
                        var s = 1;
                        if (Array.isArray(t))
                            for (s = t.length; s--;) t[s] instanceof Phaser.Group ? this.enable(t[s].children, e, i) : (this.enableBody(t[s], e), i && t[s].hasOwnProperty("children") && t[s].children.length > 0 && this.enable(t[s], e, !0));
                        else t instanceof Phaser.Group ? this.enable(t.children, e, i) : (this.enableBody(t, e), i && t.hasOwnProperty("children") && t.children.length > 0 && this.enable(t.children, e, !0))
                    },
                    enableBody: function(t, e) {
                        t.hasOwnProperty("body") && null === t.body && (t.body = new Phaser.Physics.P2.Body(this.game, t, t.x, t.y, 1), t.body.debug = e, t.anchor.set(.5))
                    },
                    setImpactEvents: function(t) {
                        t ? this.world.on("impact", this.impactHandler, this) : this.world.off("impact", this.impactHandler, this)
                    },
                    setPostBroadphaseCallback: function(t, e) {
                        this.postBroadphaseCallback = t, this.callbackContext = e, null !== t ? this.world.on("postBroadphase", this.postBroadphaseHandler, this) : this.world.off("postBroadphase", this.postBroadphaseHandler, this)
                    },
                    postBroadphaseHandler: function(t) {
                        if (this.postBroadphaseCallback)
                            for (var e = t.pairs.length; e -= 2;) t.pairs[e].parent && t.pairs[e + 1].parent && !this.postBroadphaseCallback.call(this.callbackContext, t.pairs[e].parent, t.pairs[e + 1].parent) && t.pairs.splice(e, 2)
                    },
                    impactHandler: function(t) {
                        if (t.bodyA.parent && t.bodyB.parent) {
                            var e = t.bodyA.parent,
                                i = t.bodyB.parent;
                            e._bodyCallbacks[t.bodyB.id] && e._bodyCallbacks[t.bodyB.id].call(e._bodyCallbackContext[t.bodyB.id], e, i, t.shapeA, t.shapeB), i._bodyCallbacks[t.bodyA.id] && i._bodyCallbacks[t.bodyA.id].call(i._bodyCallbackContext[t.bodyA.id], i, e, t.shapeB, t.shapeA), e._groupCallbacks[t.shapeB.collisionGroup] && e._groupCallbacks[t.shapeB.collisionGroup].call(e._groupCallbackContext[t.shapeB.collisionGroup], e, i, t.shapeA, t.shapeB), i._groupCallbacks[t.shapeA.collisionGroup] && i._groupCallbacks[t.shapeA.collisionGroup].call(i._groupCallbackContext[t.shapeA.collisionGroup], i, e, t.shapeB, t.shapeA)
                        }
                    },
                    beginContactHandler: function(t) {
                        this.onBeginContact.dispatch(t.bodyA, t.bodyB, t.shapeA, t.shapeB, t.contactEquations), t.bodyA.parent && t.bodyA.parent.onBeginContact.dispatch(t.bodyB.parent, t.shapeA, t.shapeB, t.contactEquations), t.bodyB.parent && t.bodyB.parent.onBeginContact.dispatch(t.bodyA.parent, t.shapeB, t.shapeA, t.contactEquations)
                    },
                    endContactHandler: function(t) {
                        this.onEndContact.dispatch(t.bodyA, t.bodyB, t.shapeA, t.shapeB), t.bodyA.parent && t.bodyA.parent.onEndContact.dispatch(t.bodyB.parent, t.shapeA, t.shapeB), t.bodyB.parent && t.bodyB.parent.onEndContact.dispatch(t.bodyA.parent, t.shapeB, t.shapeA)
                    },
                    setBoundsToWorld: function(t, e, i, s, n) {
                        this.setBounds(this.game.world.bounds.x, this.game.world.bounds.y, this.game.world.bounds.width, this.game.world.bounds.height, t, e, i, s, n)
                    },
                    setWorldMaterial: function(t, e, i, s, n) {
                        "undefined" == typeof e && (e = !0), "undefined" == typeof i && (i = !0), "undefined" == typeof s && (s = !0), "undefined" == typeof n && (n = !0), e && this.walls.left && (this.walls.left.shapes[0].material = t), i && this.walls.right && (this.walls.right.shapes[0].material = t), s && this.walls.top && (this.walls.top.shapes[0].material = t), n && this.walls.bottom && (this.walls.bottom.shapes[0].material = t)
                    },
                    updateBoundsCollisionGroup: function(t) {
                        var e = this.everythingCollisionGroup.mask;
                        "undefined" == typeof t && (e = this.boundsCollisionGroup.mask), this.walls.left && (this.walls.left.shapes[0].collisionGroup = e), this.walls.right && (this.walls.right.shapes[0].collisionGroup = e), this.walls.top && (this.walls.top.shapes[0].collisionGroup = e), this.walls.bottom && (this.walls.bottom.shapes[0].collisionGroup = e)
                    },
                    setBounds: function(t, e, i, s, n, r, o, a, h) {
                        "undefined" == typeof n && (n = !0), "undefined" == typeof r && (r = !0), "undefined" == typeof o && (o = !0), "undefined" == typeof a && (a = !0), "undefined" == typeof h && (h = !0), this.walls.left && this.world.removeBody(this.walls.left), this.walls.right && this.world.removeBody(this.walls.right), this.walls.top && this.world.removeBody(this.walls.top), this.walls.bottom && this.world.removeBody(this.walls.bottom), n && (this.walls.left = new p2.Body({
                            mass: 0,
                            position: [this.pxmi(t), this.pxmi(e)],
                            angle: 1.5707963267948966
                        }), this.walls.left.addShape(new p2.Plane), h && (this.walls.left.shapes[0].collisionGroup = this.boundsCollisionGroup.mask), this.world.addBody(this.walls.left)), r && (this.walls.right = new p2.Body({
                            mass: 0,
                            position: [this.pxmi(t + i), this.pxmi(e)],
                            angle: -1.5707963267948966
                        }), this.walls.right.addShape(new p2.Plane), h && (this.walls.right.shapes[0].collisionGroup = this.boundsCollisionGroup.mask), this.world.addBody(this.walls.right)), o && (this.walls.top = new p2.Body({
                            mass: 0,
                            position: [this.pxmi(t), this.pxmi(e)],
                            angle: -3.141592653589793
                        }), this.walls.top.addShape(new p2.Plane), h && (this.walls.top.shapes[0].collisionGroup = this.boundsCollisionGroup.mask), this.world.addBody(this.walls.top)), a && (this.walls.bottom = new p2.Body({
                            mass: 0,
                            position: [this.pxmi(t), this.pxmi(e + s)]
                        }), this.walls.bottom.addShape(new p2.Plane), h && (this.walls.bottom.shapes[0].collisionGroup = this.boundsCollisionGroup.mask), this.world.addBody(this.walls.bottom))
                    },
                    pause: function() {
                        this.paused = !0
                    },
                    resume: function() {
                        this.paused = !1
                    },
                    update: function() {
                        this.paused || this.world.step(this.useElapsedTime ? this.game.time.physicsElapsed : this.frameRate)
                    },
                    clear: function() {
                        this.world.clear(), this.world.off("beginContact", this.beginContactHandler, this), this.world.off("endContact", this.endContactHandler, this), this.postBroadphaseCallback = null, this.callbackContext = null, this.impactCallback = null, this.collisionGroups = [], this._toRemove = [], this._collisionGroupID = 2, this.boundsCollidesWith = []
                    },
                    destroy: function() {
                        this.clear(), this.game = null
                    },
                    addBody: function(t) {
                        return t.data.world ? !1 : (this.world.addBody(t.data), this.onBodyAdded.dispatch(t), !0)
                    },
                    removeBody: function(t) {
                        return t.data.world == this.world && (this.world.removeBody(t.data), this.onBodyRemoved.dispatch(t)), t
                    },
                    addSpring: function(t) {
                        return this.world.addSpring(t), this.onSpringAdded.dispatch(t), t
                    },
                    removeSpring: function(t) {
                        return this.world.removeSpring(t), this.onSpringRemoved.dispatch(t), t
                    },
                    createDistanceConstraint: function(t, e, i, s) {
                        return t = this.getBody(t), e = this.getBody(e), t && e ? this.addConstraint(new Phaser.Physics.P2.DistanceConstraint(this, t, e, i, s)) : void console.warn("Cannot create Constraint, invalid body objects given")
                    },
                    createGearConstraint: function(t, e, i, s) {
                        return t = this.getBody(t), e = this.getBody(e), t && e ? this.addConstraint(new Phaser.Physics.P2.GearConstraint(this, t, e, i, s)) : void console.warn("Cannot create Constraint, invalid body objects given")
                    },
                    createRevoluteConstraint: function(t, e, i, s, n) {
                        return t = this.getBody(t), i = this.getBody(i), t && i ? this.addConstraint(new Phaser.Physics.P2.RevoluteConstraint(this, t, e, i, s, n)) : void console.warn("Cannot create Constraint, invalid body objects given")
                    },
                    createLockConstraint: function(t, e, i, s, n) {
                        return t = this.getBody(t), e = this.getBody(e), t && e ? this.addConstraint(new Phaser.Physics.P2.LockConstraint(this, t, e, i, s, n)) : void console.warn("Cannot create Constraint, invalid body objects given")
                    },
                    createPrismaticConstraint: function(t, e, i, s, n, r, o) {
                        return t = this.getBody(t), e = this.getBody(e), t && e ? this.addConstraint(new Phaser.Physics.P2.PrismaticConstraint(this, t, e, i, s, n, r, o)) : void console.warn("Cannot create Constraint, invalid body objects given")
                    },
                    addConstraint: function(t) {
                        return this.world.addConstraint(t), this.onConstraintAdded.dispatch(t), t
                    },
                    removeConstraint: function(t) {
                        return this.world.removeConstraint(t), this.onConstraintRemoved.dispatch(t), t
                    },
                    addContactMaterial: function(t) {
                        return this.world.addContactMaterial(t), this.onContactMaterialAdded.dispatch(t), t
                    },
                    removeContactMaterial: function(t) {
                        return this.world.removeContactMaterial(t), this.onContactMaterialRemoved.dispatch(t), t
                    },
                    getContactMaterial: function(t, e) {
                        return this.world.getContactMaterial(t, e)
                    },
                    setMaterial: function(t, e) {
                        for (var i = e.length; i--;) e[i].setMaterial(t)
                    },
                    createMaterial: function(t, e) {
                        t = t || "";
                        var i = new Phaser.Physics.P2.Material(t);
                        return this.materials.push(i), "undefined" != typeof e && e.setMaterial(i), i
                    },
                    createContactMaterial: function(t, e, i) {
                        "undefined" == typeof t && (t = this.createMaterial()), "undefined" == typeof e && (e = this.createMaterial());
                        var s = new Phaser.Physics.P2.ContactMaterial(t, e, i);
                        return this.addContactMaterial(s)
                    },
                    getBodies: function() {
                        for (var t = [], e = this.world.bodies.length; e--;) t.push(this.world.bodies[e].parent);
                        return t
                    },
                    getBody: function(t) {
                        return t instanceof p2.Body ? t : t instanceof Phaser.Physics.P2.Body ? t.data : t.body && t.body.type === Phaser.Physics.P2JS ? t.body.data : null
                    },
                    getSprings: function() {
                        for (var t = [], e = this.world.springs.length; e--;) t.push(this.world.springs[e].parent);
                        return t
                    },
                    getConstraints: function() {
                        for (var t = [], e = this.world.constraints.length; e--;) t.push(this.world.constraints[e].parent);
                        return t
                    },
                    hitTest: function(t, e, i, s) {
                        "undefined" == typeof e && (e = this.world.bodies), "undefined" == typeof i && (i = 5), "undefined" == typeof s && (s = !1);
                        for (var n = [this.pxmi(t.x), this.pxmi(t.y)], r = [], o = e.length; o--;) e[o] instanceof Phaser.Physics.P2.Body && (!s || e[o].data.motionState !== p2.Body.STATIC) ? r.push(e[o].data) : e[o] instanceof p2.Body && e[o].parent && (!s || e[o].motionState !== p2.Body.STATIC) ? r.push(e[o]) : e[o] instanceof Phaser.Sprite && e[o].hasOwnProperty("body") && (!s || e[o].body.data.motionState !== p2.Body.STATIC) && r.push(e[o].body.data);
                        return this.world.hitTest(n, r, i)
                    },
                    toJSON: function() {
                        return this.world.toJSON()
                    },
                    createCollisionGroup: function(t) {
                        var e = Math.pow(2, this._collisionGroupID);
                        this.walls.left && (this.walls.left.shapes[0].collisionMask = this.walls.left.shapes[0].collisionMask | e), this.walls.right && (this.walls.right.shapes[0].collisionMask = this.walls.right.shapes[0].collisionMask | e), this.walls.top && (this.walls.top.shapes[0].collisionMask = this.walls.top.shapes[0].collisionMask | e), this.walls.bottom && (this.walls.bottom.shapes[0].collisionMask = this.walls.bottom.shapes[0].collisionMask | e), this._collisionGroupID++;
                        var i = new Phaser.Physics.P2.CollisionGroup(e);
                        return this.collisionGroups.push(i), t && this.setCollisionGroup(t, i), i
                    },
                    setCollisionGroup: function(t, e) {
                        if (t instanceof Phaser.Group)
                            for (var i = 0; i < t.total; i++) t.children[i].body && t.children[i].body.type === Phaser.Physics.P2JS && t.children[i].body.setCollisionGroup(e);
                        else t.body.setCollisionGroup(e)
                    },
                    createSpring: function(t, e, i, s, n, r, o, a, h) {
                        return t = this.getBody(t), e = this.getBody(e), t && e ? this.addSpring(new Phaser.Physics.P2.Spring(this, t, e, i, s, n, r, o, a, h)) : void console.warn("Cannot create Spring, invalid body objects given")
                    },
                    createBody: function(t, e, i, s, n, r) {
                        "undefined" == typeof s && (s = !1);
                        var o = new Phaser.Physics.P2.Body(this.game, null, t, e, i);
                        if (r) {
                            var a = o.addPolygon(n, r);
                            if (!a) return !1
                        }
                        return s && this.world.addBody(o.data), o
                    },
                    createParticle: function(t, e, i, s, n, r) {
                        "undefined" == typeof s && (s = !1);
                        var o = new Phaser.Physics.P2.Body(this.game, null, t, e, i);
                        if (r) {
                            var a = o.addPolygon(n, r);
                            if (!a) return !1
                        }
                        return s && this.world.addBody(o.data), o
                    },
                    convertCollisionObjects: function(t, e, i) {
                        "undefined" == typeof i && (i = !0);
                        for (var s = [], n = 0, r = t.collision[e].length; r > n; n++) {
                            var o = t.collision[e][n],
                                a = this.createBody(o.x, o.y, 0, i, {}, o.polyline);
                            a && s.push(a)
                        }
                        return s
                    },
                    clearTilemapLayerBodies: function(t, e) {
                        e = t.getLayer(e);
                        for (var i = t.layers[e].bodies.length; i--;) t.layers[e].bodies[i].destroy();
                        t.layers[e].bodies.length = 0
                    },
                    convertTilemap: function(t, e, i, s) {
                        e = t.getLayer(e), "undefined" == typeof i && (i = !0), "undefined" == typeof s && (s = !0), this.clearTilemapLayerBodies(t, e);
                        for (var n = 0, r = 0, o = 0, a = 0, h = t.layers[e].height; h > a; a++) {
                            n = 0;
                            for (var l = 0, c = t.layers[e].width; c > l; l++) {
                                var u = t.layers[e].data[a][l];
                                if (u && u.index > -1 && u.collides)
                                    if (s) {
                                        var d = t.getTileRight(e, l, a);
                                        if (0 === n && (r = u.x * u.width, o = u.y * u.height, n = u.width), d && d.collides) n += u.width;
                                        else {
                                            var p = this.createBody(r, o, 0, !1);
                                            p.addRectangle(n, u.height, n / 2, u.height / 2, 0), i && this.addBody(p), t.layers[e].bodies.push(p), n = 0
                                        }
                                    } else {
                                        var p = this.createBody(u.x * u.width, u.y * u.height, 0, !1);
                                        p.addRectangle(u.width, u.height, u.width / 2, u.height / 2, 0), i && this.addBody(p), t.layers[e].bodies.push(p)
                                    }
                            }
                        }
                        return t.layers[e].bodies
                    },
                    mpx: function(t) {
                        return t *= 20
                    },
                    pxm: function(t) {
                        return .05 * t
                    },
                    mpxi: function(t) {
                        return t *= -20
                    },
                    pxmi: function(t) {
                        return t * -.05
                    }
                }, Object.defineProperty(Phaser.Physics.P2.prototype, "friction", {
                    get: function() {
                        return this.world.defaultContactMaterial.friction
                    },
                    set: function(t) {
                        this.world.defaultContactMaterial.friction = t
                    }
                }), Object.defineProperty(Phaser.Physics.P2.prototype, "defaultFriction", {
                    get: function() {
                        return this.world.defaultContactMaterial.friction
                    },
                    set: function(t) {
                        this.world.defaultContactMaterial.friction = t
                    }
                }), Object.defineProperty(Phaser.Physics.P2.prototype, "restitution", {
                    get: function() {
                        return this.world.defaultContactMaterial.restitution
                    },
                    set: function(t) {
                        this.world.defaultContactMaterial.restitution = t
                    }
                }), Object.defineProperty(Phaser.Physics.P2.prototype, "defaultRestitution", {
                    get: function() {
                        return this.world.defaultContactMaterial.restitution
                    },
                    set: function(t) {
                        this.world.defaultContactMaterial.restitution = t
                    }
                }), Object.defineProperty(Phaser.Physics.P2.prototype, "contactMaterial", {
                    get: function() {
                        return this.world.defaultContactMaterial
                    },
                    set: function(t) {
                        this.world.defaultContactMaterial = t
                    }
                }), Object.defineProperty(Phaser.Physics.P2.prototype, "applySpringForces", {
                    get: function() {
                        return this.world.applySpringForces
                    },
                    set: function(t) {
                        this.world.applySpringForces = t
                    }
                }), Object.defineProperty(Phaser.Physics.P2.prototype, "applyDamping", {
                    get: function() {
                        return this.world.applyDamping
                    },
                    set: function(t) {
                        this.world.applyDamping = t
                    }
                }), Object.defineProperty(Phaser.Physics.P2.prototype, "applyGravity", {
                    get: function() {
                        return this.world.applyGravity
                    },
                    set: function(t) {
                        this.world.applyGravity = t
                    }
                }), Object.defineProperty(Phaser.Physics.P2.prototype, "solveConstraints", {
                    get: function() {
                        return this.world.solveConstraints
                    },
                    set: function(t) {
                        this.world.solveConstraints = t
                    }
                }), Object.defineProperty(Phaser.Physics.P2.prototype, "time", {
                    get: function() {
                        return this.world.time
                    }
                }), Object.defineProperty(Phaser.Physics.P2.prototype, "emitImpactEvent", {
                    get: function() {
                        return this.world.emitImpactEvent
                    },
                    set: function(t) {
                        this.world.emitImpactEvent = t
                    }
                }), Object.defineProperty(Phaser.Physics.P2.prototype, "enableBodySleeping", {
                    get: function() {
                        return this.world.enableBodySleeping
                    },
                    set: function(t) {
                        this.world.enableBodySleeping = t
                    }
                }), Object.defineProperty(Phaser.Physics.P2.prototype, "total", {
                    get: function() {
                        return this.world.bodies.length
                    }
                }), Phaser.Physics.P2.FixtureList = function(t) {
                    Array.isArray(t) || (t = [t]), this.rawList = t, this.init(), this.parse(this.rawList)
                }, Phaser.Physics.P2.FixtureList.prototype = {
                    init: function() {
                        this.namedFixtures = {}, this.groupedFixtures = [], this.allFixtures = []
                    },
                    setCategory: function(t, e) {
                        var i = function(e) {
                            e.collisionGroup = t
                        };
                        this.getFixtures(e).forEach(i)
                    },
                    setMask: function(t, e) {
                        var i = function(e) {
                            e.collisionMask = t
                        };
                        this.getFixtures(e).forEach(i)
                    },
                    setSensor: function(t, e) {
                        var i = function(e) {
                            e.sensor = t
                        };
                        this.getFixtures(e).forEach(i)
                    },
                    setMaterial: function(t, e) {
                        var i = function(e) {
                            e.material = t
                        };
                        this.getFixtures(e).forEach(i)
                    },
                    getFixtures: function(t) {
                        var e = [];
                        if (t) {
                            t instanceof Array || (t = [t]);
                            var i = this;
                            return t.forEach(function(t) {
                                i.namedFixtures[t] && e.push(i.namedFixtures[t])
                            }), this.flatten(e)
                        }
                        return this.allFixtures
                    },
                    getFixtureByKey: function(t) {
                        return this.namedFixtures[t]
                    },
                    getGroup: function(t) {
                        return this.groupedFixtures[t]
                    },
                    parse: function() {
                        var t, e, i, s;
                        i = this.rawList, s = [];
                        for (t in i) e = i[t], isNaN(t - 0) ? this.namedFixtures[t] = this.flatten(e) : (this.groupedFixtures[t] = this.groupedFixtures[t] || [], this.groupedFixtures[t] = this.groupedFixtures[t].concat(e)), s.push(this.allFixtures = this.flatten(this.groupedFixtures))
                    },
                    flatten: function(t) {
                        var e, i;
                        return e = [], i = arguments.callee, t.forEach(function(t) {
                            return Array.prototype.push.apply(e, Array.isArray(t) ? i(t) : [t])
                        }), e
                    }
                }, Phaser.Physics.P2.PointProxy = function(t, e) {
                    this.world = t, this.destination = e
                }, Phaser.Physics.P2.PointProxy.prototype.constructor = Phaser.Physics.P2.PointProxy, Object.defineProperty(Phaser.Physics.P2.PointProxy.prototype, "x", {
                    get: function() {
                        return this.destination[0]
                    },
                    set: function(t) {
                        this.destination[0] = this.world.pxm(t)
                    }
                }), Object.defineProperty(Phaser.Physics.P2.PointProxy.prototype, "y", {
                    get: function() {
                        return this.destination[1]
                    },
                    set: function(t) {
                        this.destination[1] = this.world.pxm(t)
                    }
                }), Phaser.Physics.P2.InversePointProxy = function(t, e) {
                    this.world = t, this.destination = e
                }, Phaser.Physics.P2.InversePointProxy.prototype.constructor = Phaser.Physics.P2.InversePointProxy, Object.defineProperty(Phaser.Physics.P2.InversePointProxy.prototype, "x", {
                    get: function() {
                        return this.destination[0]
                    },
                    set: function(t) {
                        this.destination[0] = this.world.pxm(-t)
                    }
                }), Object.defineProperty(Phaser.Physics.P2.InversePointProxy.prototype, "y", {
                    get: function() {
                        return this.destination[1]
                    },
                    set: function(t) {
                        this.destination[1] = this.world.pxm(-t)
                    }
                }), Phaser.Physics.P2.Body = function(t, e, i, s, n) {
                    e = e || null, i = i || 0, s = s || 0, "undefined" == typeof n && (n = 1), this.game = t, this.world = t.physics.p2, this.sprite = e, this.type = Phaser.Physics.P2JS, this.offset = new Phaser.Point, this.data = new p2.Body({
                        position: [this.world.pxmi(i), this.world.pxmi(s)],
                        mass: n
                    }), this.data.parent = this, this.velocity = new Phaser.Physics.P2.InversePointProxy(this.world, this.data.velocity), this.force = new Phaser.Physics.P2.InversePointProxy(this.world, this.data.force), this.gravity = new Phaser.Point, this.onBeginContact = new Phaser.Signal, this.onEndContact = new Phaser.Signal, this.collidesWith = [], this.removeNextStep = !1, this.debugBody = null, this._collideWorldBounds = !0, this._bodyCallbacks = {}, this._bodyCallbackContext = {}, this._groupCallbacks = {}, this._groupCallbackContext = {}, e && (this.setRectangleFromSprite(e), e.exists && this.game.physics.p2.addBody(this))
                }, Phaser.Physics.P2.Body.prototype = {
                    createBodyCallback: function(t, e, i) {
                        var s = -1;
                        t.id ? s = t.id : t.body && (s = t.body.id), s > -1 && (null === e ? (delete this._bodyCallbacks[s], delete this._bodyCallbackContext[s]) : (this._bodyCallbacks[s] = e, this._bodyCallbackContext[s] = i))
                    },
                    createGroupCallback: function(t, e, i) {
                        null === e ? (delete this._groupCallbacks[t.mask], delete this._groupCallbacksContext[t.mask]) : (this._groupCallbacks[t.mask] = e, this._groupCallbackContext[t.mask] = i)
                    },
                    getCollisionMask: function() {
                        var t = 0;
                        this._collideWorldBounds && (t = this.game.physics.p2.boundsCollisionGroup.mask);
                        for (var e = 0; e < this.collidesWith.length; e++) t |= this.collidesWith[e].mask;
                        return t
                    },
                    updateCollisionMask: function(t) {
                        var e = this.getCollisionMask();
                        if ("undefined" == typeof t)
                            for (var i = this.data.shapes.length - 1; i >= 0; i--) this.data.shapes[i].collisionMask = e;
                        else t.collisionMask = e
                    },
                    setCollisionGroup: function(t, e) {
                        var i = this.getCollisionMask();
                        if ("undefined" == typeof e)
                            for (var s = this.data.shapes.length - 1; s >= 0; s--) this.data.shapes[s].collisionGroup = t.mask, this.data.shapes[s].collisionMask = i;
                        else e.collisionGroup = t.mask, e.collisionMask = i
                    },
                    clearCollision: function(t, e, i) {
                        if ("undefined" == typeof i)
                            for (var s = this.data.shapes.length - 1; s >= 0; s--) t && (this.data.shapes[s].collisionGroup = null), e && (this.data.shapes[s].collisionMask = null);
                        else t && (i.collisionGroup = null), e && (i.collisionMask = null);
                        t && (this.collidesWith.length = 0)
                    },
                    collides: function(t, e, i, s) {
                        if (Array.isArray(t))
                            for (var n = 0; n < t.length; n++) - 1 === this.collidesWith.indexOf(t[n]) && (this.collidesWith.push(t[n]), e && this.createGroupCallback(t[n], e, i));
                        else -1 === this.collidesWith.indexOf(t) && (this.collidesWith.push(t), e && this.createGroupCallback(t, e, i));
                        var r = this.getCollisionMask();
                        if ("undefined" == typeof s)
                            for (var n = this.data.shapes.length - 1; n >= 0; n--) this.data.shapes[n].collisionMask = r;
                        else s.collisionMask = r
                    },
                    adjustCenterOfMass: function() {
                        this.data.adjustCenterOfMass()
                    },
                    applyDamping: function(t) {
                        this.data.applyDamping(t)
                    },
                    applyForce: function(t, e, i) {
                        this.data.applyForce(t, [this.world.pxmi(e), this.world.pxmi(i)])
                    },
                    setZeroForce: function() {
                        this.data.setZeroForce()
                    },
                    setZeroRotation: function() {
                        this.data.angularVelocity = 0
                    },
                    setZeroVelocity: function() {
                        this.data.velocity[0] = 0, this.data.velocity[1] = 0
                    },
                    setZeroDamping: function() {
                        this.data.damping = 0, this.data.angularDamping = 0
                    },
                    toLocalFrame: function(t, e) {
                        return this.data.toLocalFrame(t, e)
                    },
                    toWorldFrame: function(t, e) {
                        return this.data.toWorldFrame(t, e)
                    },
                    rotateLeft: function(t) {
                        this.data.angularVelocity = this.world.pxm(-t)
                    },
                    rotateRight: function(t) {
                        this.data.angularVelocity = this.world.pxm(t)
                    },
                    moveForward: function(t) {
                        var e = this.world.pxmi(-t),
                            i = this.data.angle + Math.PI / 2;
                        this.data.velocity[0] = e * Math.cos(i), this.data.velocity[1] = e * Math.sin(i)
                    },
                    moveBackward: function(t) {
                        var e = this.world.pxmi(-t),
                            i = this.data.angle + Math.PI / 2;
                        this.data.velocity[0] = -(e * Math.cos(i)), this.data.velocity[1] = -(e * Math.sin(i))
                    },
                    thrust: function(t) {
                        var e = this.world.pxmi(-t),
                            i = this.data.angle + Math.PI / 2;
                        this.data.force[0] += e * Math.cos(i), this.data.force[1] += e * Math.sin(i)
                    },
                    reverse: function(t) {
                        var e = this.world.pxmi(-t),
                            i = this.data.angle + Math.PI / 2;
                        this.data.force[0] -= e * Math.cos(i), this.data.force[1] -= e * Math.sin(i)
                    },
                    moveLeft: function(t) {
                        this.data.velocity[0] = this.world.pxmi(-t)
                    },
                    moveRight: function(t) {
                        this.data.velocity[0] = this.world.pxmi(t)
                    },
                    moveUp: function(t) {
                        this.data.velocity[1] = this.world.pxmi(-t)
                    },
                    moveDown: function(t) {
                        this.data.velocity[1] = this.world.pxmi(t)
                    },
                    preUpdate: function() {
                        this.removeNextStep && (this.removeFromWorld(), this.removeNextStep = !1)
                    },
                    postUpdate: function() {
                        this.sprite.x = this.world.mpxi(this.data.position[0]), this.sprite.y = this.world.mpxi(this.data.position[1]), this.fixedRotation || (this.sprite.rotation = this.data.angle)
                    },
                    reset: function(t, e, i, s) {
                        "undefined" == typeof i && (i = !1), "undefined" == typeof s && (s = !1), this.setZeroForce(), this.setZeroVelocity(), this.setZeroRotation(), i && this.setZeroDamping(), s && (this.mass = 1), this.x = t, this.y = e
                    },
                    addToWorld: function() {
                        if (this.game.physics.p2._toRemove)
                            for (var t = 0; t < this.game.physics.p2._toRemove.length; t++) this.game.physics.p2._toRemove[t] === this && this.game.physics.p2._toRemove.splice(t, 1);
                        this.data.world !== this.game.physics.p2.world && this.game.physics.p2.addBody(this)
                    },
                    removeFromWorld: function() {
                        this.data.world === this.game.physics.p2.world && this.game.physics.p2.removeBodyNextStep(this)
                    },
                    destroy: function() {
                        this.removeFromWorld(), this.clearShapes(), this._bodyCallbacks = {}, this._bodyCallbackContext = {}, this._groupCallbacks = {}, this._groupCallbackContext = {}, this.debugBody && this.debugBody.destroy(), this.debugBody = null, this.sprite = null
                    },
                    clearShapes: function() {
                        for (var t = this.data.shapes.length; t--;) this.data.removeShape(this.data.shapes[t]);
                        this.shapeChanged()
                    },
                    addShape: function(t, e, i, s) {
                        return "undefined" == typeof e && (e = 0), "undefined" == typeof i && (i = 0), "undefined" == typeof s && (s = 0), this.data.addShape(t, [this.world.pxmi(e), this.world.pxmi(i)], s), this.shapeChanged(), t
                    },
                    addCircle: function(t, e, i, s) {
                        var n = new p2.Circle(this.world.pxm(t));
                        return this.addShape(n, e, i, s)
                    },
                    addRectangle: function(t, e, i, s, n) {
                        var r = new p2.Rectangle(this.world.pxm(t), this.world.pxm(e));
                        return this.addShape(r, i, s, n)
                    },
                    addPlane: function(t, e, i) {
                        var s = new p2.Plane;
                        return this.addShape(s, t, e, i)
                    },
                    addParticle: function(t, e, i) {
                        var s = new p2.Particle;
                        return this.addShape(s, t, e, i)
                    },
                    addLine: function(t, e, i, s) {
                        var n = new p2.Line(this.world.pxm(t));
                        return this.addShape(n, e, i, s)
                    },
                    addCapsule: function(t, e, i, s, n) {
                        var r = new p2.Capsule(this.world.pxm(t), e);
                        return this.addShape(r, i, s, n)
                    },
                    addPolygon: function(t, e) {
                        t = t || {}, Array.isArray(e) || (e = Array.prototype.slice.call(arguments, 1));
                        var i = [];
                        if (1 === e.length && Array.isArray(e[0])) i = e[0].slice(0);
                        else if (Array.isArray(e[0])) i = e[0].slice(0);
                        else if ("number" == typeof e[0])
                            for (var s = 0, n = e.length; n > s; s += 2) i.push([e[s], e[s + 1]]);
                        var r = i.length - 1;
                        i[r][0] === i[0][0] && i[r][1] === i[0][1] && i.pop();
                        for (var o = 0; o < i.length; o++) i[o][0] = this.world.pxmi(i[o][0]), i[o][1] = this.world.pxmi(i[o][1]);
                        var a = this.data.fromPolygon(i, t);
                        return this.shapeChanged(), a
                    },
                    removeShape: function(t) {
                        var e = this.data.removeShape(t);
                        return this.shapeChanged(), e
                    },
                    setCircle: function(t, e, i, s) {
                        return this.clearShapes(), this.addCircle(t, e, i, s)
                    },
                    setRectangle: function(t, e, i, s, n) {
                        return "undefined" == typeof t && (t = 16), "undefined" == typeof e && (e = 16), this.clearShapes(), this.addRectangle(t, e, i, s, n)
                    },
                    setRectangleFromSprite: function(t) {
                        return "undefined" == typeof t && (t = this.sprite), this.clearShapes(), this.addRectangle(t.width, t.height, 0, 0, t.rotation)
                    },
                    setMaterial: function(t, e) {
                        if ("undefined" == typeof e)
                            for (var i = this.data.shapes.length - 1; i >= 0; i--) this.data.shapes[i].material = t;
                        else e.material = t
                    },
                    shapeChanged: function() {
                        this.debugBody && this.debugBody.draw()
                    },
                    addPhaserPolygon: function(t, e) {
                        for (var i = this.game.cache.getPhysicsData(t, e), s = [], n = 0; n < i.length; n++) {
                            var r = i[n],
                                o = this.addFixture(r);
                            s[r.filter.group] = s[r.filter.group] || [], s[r.filter.group] = s[r.filter.group].concat(o), r.fixtureKey && (s[r.fixtureKey] = o)
                        }
                        return this.data.aabbNeedsUpdate = !0, this.shapeChanged(), s
                    },
                    addFixture: function(t) {
                        var e = [];
                        if (t.circle) {
                            var i = new p2.Circle(this.world.pxm(t.circle.radius));
                            i.collisionGroup = t.filter.categoryBits, i.collisionMask = t.filter.maskBits, i.sensor = t.isSensor;
                            var s = p2.vec2.create();
                            s[0] = this.world.pxmi(t.circle.position[0] - this.sprite.width / 2), s[1] = this.world.pxmi(t.circle.position[1] - this.sprite.height / 2), this.data.addShape(i, s), e.push(i)
                        } else
                            for (var n = t.polygons, r = p2.vec2.create(), o = 0; o < n.length; o++) {
                                for (var a = n[o], h = [], l = 0; l < a.length; l += 2) h.push([this.world.pxmi(a[l]), this.world.pxmi(a[l + 1])]);
                                for (var i = new p2.Convex(h), c = 0; c !== i.vertices.length; c++) {
                                    var u = i.vertices[c];
                                    p2.vec2.sub(u, u, i.centerOfMass)
                                }
                                p2.vec2.scale(r, i.centerOfMass, 1), r[0] -= this.world.pxmi(this.sprite.width / 2), r[1] -= this.world.pxmi(this.sprite.height / 2), i.updateTriangles(), i.updateCenterOfMass(), i.updateBoundingRadius(), i.collisionGroup = t.filter.categoryBits, i.collisionMask = t.filter.maskBits, i.sensor = t.isSensor, this.data.addShape(i, r), e.push(i)
                            }
                        return e
                    },
                    loadPolygon: function(t, e) {
                        for (var i = this.game.cache.getPhysicsData(t, e), s = p2.vec2.create(), n = 0; n < i.length; n++) {
                            for (var r = [], o = 0; o < i[n].shape.length; o += 2) r.push([this.world.pxmi(i[n].shape[o]), this.world.pxmi(i[n].shape[o + 1])]);
                            for (var a = new p2.Convex(r), h = 0; h !== a.vertices.length; h++) {
                                var l = a.vertices[h];
                                p2.vec2.sub(l, l, a.centerOfMass)
                            }
                            p2.vec2.scale(s, a.centerOfMass, 1), s[0] -= this.world.pxmi(this.sprite.width / 2), s[1] -= this.world.pxmi(this.sprite.height / 2), a.updateTriangles(), a.updateCenterOfMass(), a.updateBoundingRadius(), this.data.addShape(a, s)
                        }
                        return this.data.aabbNeedsUpdate = !0, this.shapeChanged(), !0
                    },
                    loadData: function(t, e) {
                        var i = this.game.cache.getPhysicsData(t, e);
                        return i && i.shape ? (this.mass = i.density, this.loadPolygon(t, e)) : void 0
                    }
                }, Phaser.Physics.P2.Body.prototype.constructor = Phaser.Physics.P2.Body, Phaser.Physics.P2.Body.DYNAMIC = 1, Phaser.Physics.P2.Body.STATIC = 2, Phaser.Physics.P2.Body.KINEMATIC = 4, Object.defineProperty(Phaser.Physics.P2.Body.prototype, "static", {
                    get: function() {
                        return this.data.motionState === Phaser.Physics.P2.Body.STATIC
                    },
                    set: function(t) {
                        t && this.data.motionState !== Phaser.Physics.P2.Body.STATIC ? (this.data.motionState = Phaser.Physics.P2.Body.STATIC, this.mass = 0) : t || this.data.motionState !== Phaser.Physics.P2.Body.STATIC || (this.data.motionState = Phaser.Physics.P2.Body.DYNAMIC, 0 === this.mass && (this.mass = 1))
                    }
                }), Object.defineProperty(Phaser.Physics.P2.Body.prototype, "dynamic", {
                    get: function() {
                        return this.data.motionState === Phaser.Physics.P2.Body.DYNAMIC
                    },
                    set: function(t) {
                        t && this.data.motionState !== Phaser.Physics.P2.Body.DYNAMIC ? (this.data.motionState = Phaser.Physics.P2.Body.DYNAMIC, 0 === this.mass && (this.mass = 1)) : t || this.data.motionState !== Phaser.Physics.P2.Body.DYNAMIC || (this.data.motionState = Phaser.Physics.P2.Body.STATIC, this.mass = 0)
                    }
                }), Object.defineProperty(Phaser.Physics.P2.Body.prototype, "kinematic", {
                    get: function() {
                        return this.data.motionState === Phaser.Physics.P2.Body.KINEMATIC
                    },
                    set: function(t) {
                        t && this.data.motionState !== Phaser.Physics.P2.Body.KINEMATIC ? (this.data.motionState = Phaser.Physics.P2.Body.KINEMATIC, this.mass = 4) : t || this.data.motionState !== Phaser.Physics.P2.Body.KINEMATIC || (this.data.motionState = Phaser.Physics.P2.Body.STATIC, this.mass = 0)
                    }
                }), Object.defineProperty(Phaser.Physics.P2.Body.prototype, "allowSleep", {
                    get: function() {
                        return this.data.allowSleep
                    },
                    set: function(t) {
                        t !== this.data.allowSleep && (this.data.allowSleep = t)
                    }
                }), Object.defineProperty(Phaser.Physics.P2.Body.prototype, "angle", {
                    get: function() {
                        return Phaser.Math.wrapAngle(Phaser.Math.radToDeg(this.data.angle))
                    },
                    set: function(t) {
                        this.data.angle = Phaser.Math.degToRad(Phaser.Math.wrapAngle(t))
                    }
                }), Object.defineProperty(Phaser.Physics.P2.Body.prototype, "angularDamping", {
                    get: function() {
                        return this.data.angularDamping
                    },
                    set: function(t) {
                        this.data.angularDamping = t
                    }
                }), Object.defineProperty(Phaser.Physics.P2.Body.prototype, "angularForce", {
                    get: function() {
                        return this.data.angularForce
                    },
                    set: function(t) {
                        this.data.angularForce = t
                    }
                }), Object.defineProperty(Phaser.Physics.P2.Body.prototype, "angularVelocity", {
                    get: function() {
                        return this.data.angularVelocity
                    },
                    set: function(t) {
                        this.data.angularVelocity = t
                    }
                }), Object.defineProperty(Phaser.Physics.P2.Body.prototype, "damping", {
                    get: function() {
                        return this.data.damping
                    },
                    set: function(t) {
                        this.data.damping = t
                    }
                }), Object.defineProperty(Phaser.Physics.P2.Body.prototype, "fixedRotation", {
                    get: function() {
                        return this.data.fixedRotation
                    },
                    set: function(t) {
                        t !== this.data.fixedRotation && (this.data.fixedRotation = t)
                    }
                }), Object.defineProperty(Phaser.Physics.P2.Body.prototype, "inertia", {
                    get: function() {
                        return this.data.inertia
                    },
                    set: function(t) {
                        this.data.inertia = t
                    }
                }), Object.defineProperty(Phaser.Physics.P2.Body.prototype, "mass", {
                    get: function() {
                        return this.data.mass
                    },
                    set: function(t) {
                        t !== this.data.mass && (this.data.mass = t, this.data.updateMassProperties())
                    }
                }), Object.defineProperty(Phaser.Physics.P2.Body.prototype, "motionState", {
                    get: function() {
                        return this.data.motionState
                    },
                    set: function(t) {
                        t !== this.data.motionState && (this.data.motionState = t)
                    }
                }), Object.defineProperty(Phaser.Physics.P2.Body.prototype, "rotation", {
                    get: function() {
                        return this.data.angle
                    },
                    set: function(t) {
                        this.data.angle = t
                    }
                }), Object.defineProperty(Phaser.Physics.P2.Body.prototype, "sleepSpeedLimit", {
                    get: function() {
                        return this.data.sleepSpeedLimit
                    },
                    set: function(t) {
                        this.data.sleepSpeedLimit = t
                    }
                }), Object.defineProperty(Phaser.Physics.P2.Body.prototype, "x", {
                    get: function() {
                        return this.world.mpxi(this.data.position[0])
                    },
                    set: function(t) {
                        this.data.position[0] = this.world.pxmi(t)
                    }
                }), Object.defineProperty(Phaser.Physics.P2.Body.prototype, "y", {
                    get: function() {
                        return this.world.mpxi(this.data.position[1])
                    },
                    set: function(t) {
                        this.data.position[1] = this.world.pxmi(t)
                    }
                }), Object.defineProperty(Phaser.Physics.P2.Body.prototype, "id", {
                    get: function() {
                        return this.data.id
                    }
                }), Object.defineProperty(Phaser.Physics.P2.Body.prototype, "debug", {
                    get: function() {
                        return null !== this.debugBody
                    },
                    set: function(t) {
                        t && !this.debugBody ? this.debugBody = new Phaser.Physics.P2.BodyDebug(this.game, this.data) : !t && this.debugBody && (this.debugBody.destroy(), this.debugBody = null)
                    }
                }), Object.defineProperty(Phaser.Physics.P2.Body.prototype, "collideWorldBounds", {
                    get: function() {
                        return this._collideWorldBounds
                    },
                    set: function(t) {
                        t && !this._collideWorldBounds ? (this._collideWorldBounds = !0, this.updateCollisionMask()) : !t && this._collideWorldBounds && (this._collideWorldBounds = !1, this.updateCollisionMask())
                    }
                }), Phaser.Physics.P2.BodyDebug = function(t, e, i) {
                    Phaser.Group.call(this, t);
                    var s = {
                        pixelsPerLengthUnit: 20,
                        debugPolygons: !1,
                        lineWidth: 1,
                        alpha: .5
                    };
                    this.settings = Phaser.Utils.extend(s, i), this.ppu = this.settings.pixelsPerLengthUnit, this.ppu = -1 * this.ppu, this.body = e, this.canvas = new Phaser.Graphics(t), this.canvas.alpha = this.settings.alpha, this.add(this.canvas), this.draw()
                }, Phaser.Physics.P2.BodyDebug.prototype = Object.create(Phaser.Group.prototype), Phaser.Physics.P2.BodyDebug.prototype.constructor = Phaser.Physics.P2.BodyDebug, Phaser.Utils.extend(Phaser.Physics.P2.BodyDebug.prototype, {
                    update: function() {
                        this.updateSpriteTransform()
                    },
                    updateSpriteTransform: function() {
                        return this.position.x = this.body.position[0] * this.ppu, this.position.y = this.body.position[1] * this.ppu, this.rotation = this.body.angle
                    },
                    draw: function() {
                        var t, e, i, s, n, r, o, a, h, l, c, u, d, p, f;
                        if (a = this.body, l = this.canvas, l.clear(), i = parseInt(this.randomPastelHex(), 16), r = 16711680, o = this.lineWidth, a instanceof p2.Body && a.shapes.length) {
                            var g = a.shapes.length;
                            for (s = 0; s !== g;) {
                                if (e = a.shapes[s], h = a.shapeOffsets[s], t = a.shapeAngles[s], h = h || 0, t = t || 0, e instanceof p2.Circle) this.drawCircle(l, h[0] * this.ppu, h[1] * this.ppu, t, e.radius * this.ppu, i, o);
                                else if (e instanceof p2.Convex) {
                                    for (u = [], d = p2.vec2.create(), n = p = 0, f = e.vertices.length; f >= 0 ? f > p : p > f; n = f >= 0 ? ++p : --p) c = e.vertices[n], p2.vec2.rotate(d, c, t), u.push([(d[0] + h[0]) * this.ppu, -(d[1] + h[1]) * this.ppu]);
                                    this.drawConvex(l, u, e.triangles, r, i, o, this.settings.debugPolygons, [h[0] * this.ppu, -h[1] * this.ppu])
                                } else e instanceof p2.Plane ? this.drawPlane(l, h[0] * this.ppu, -h[1] * this.ppu, i, r, 5 * o, 10 * o, 10 * o, 100 * this.ppu, t) : e instanceof p2.Line ? this.drawLine(l, e.length * this.ppu, r, o) : e instanceof p2.Rectangle && this.drawRectangle(l, h[0] * this.ppu, -h[1] * this.ppu, t, e.width * this.ppu, e.height * this.ppu, r, i, o);
                                s++
                            }
                        }
                    },
                    drawRectangle: function(t, e, i, s, n, r, o, a, h) {
                        "undefined" == typeof h && (h = 1), "undefined" == typeof o && (o = 0), t.lineStyle(h, o, 1), t.beginFill(a), t.drawRect(e - n / 2, i - r / 2, n, r)
                    },
                    drawCircle: function(t, e, i, s, n, r, o) {
                        "undefined" == typeof o && (o = 1), "undefined" == typeof r && (r = 16777215), t.lineStyle(o, 0, 1), t.beginFill(r, 1), t.drawCircle(e, i, -n), t.endFill(), t.moveTo(e, i), t.lineTo(e + n * Math.cos(-s), i + n * Math.sin(-s))
                    },
                    drawLine: function(t, e, i, s) {
                        "undefined" == typeof s && (s = 1), "undefined" == typeof i && (i = 0), t.lineStyle(5 * s, i, 1), t.moveTo(-e / 2, 0), t.lineTo(e / 2, 0)
                    },
                    drawConvex: function(t, e, i, s, n, r, o, a) {
                        var h, l, c, u, d, p, f, g, m, y, v;
                        if ("undefined" == typeof r && (r = 1), "undefined" == typeof s && (s = 0), o) {
                            for (h = [16711680, 65280, 255], l = 0; l !== e.length + 1;) u = e[l % e.length], d = e[(l + 1) % e.length], f = u[0], y = u[1], g = d[0], v = d[1], t.lineStyle(r, h[l % h.length], 1), t.moveTo(f, -y), t.lineTo(g, -v), t.drawCircle(f, -y, 2 * r), l++;
                            return t.lineStyle(r, 0, 1), t.drawCircle(a[0], a[1], 2 * r)
                        }
                        for (t.lineStyle(r, s, 1), t.beginFill(n), l = 0; l !== e.length;) c = e[l], p = c[0], m = c[1], 0 === l ? t.moveTo(p, -m) : t.lineTo(p, -m), l++;
                        return t.endFill(), e.length > 2 ? (t.moveTo(e[e.length - 1][0], -e[e.length - 1][1]), t.lineTo(e[0][0], -e[0][1])) : void 0
                    },
                    drawPath: function(t, e, i, s, n) {
                        var r, o, a, h, l, c, u, d, p, f, g, m, y;
                        for ("undefined" == typeof n && (n = 1), "undefined" == typeof i && (i = 0), t.lineStyle(n, i, 1), "number" == typeof s && t.beginFill(s), a = null, h = null, o = 0; o < e.length;) g = e[o], m = g[0], y = g[1], (m !== a || y !== h) && (0 === o ? t.moveTo(m, y) : (l = a, c = h, u = m, d = y, p = e[(o + 1) % e.length][0], f = e[(o + 1) % e.length][1], r = (u - l) * (f - c) - (p - l) * (d - c), 0 !== r && t.lineTo(m, y)), a = m, h = y), o++;
                        "number" == typeof s && t.endFill(), e.length > 2 && "number" == typeof s && (t.moveTo(e[e.length - 1][0], e[e.length - 1][1]), t.lineTo(e[0][0], e[0][1]))
                    },
                    drawPlane: function(t, e, i, s, n, r, o, a, h, l) {
                        var c, u, d;
                        "undefined" == typeof r && (r = 1), "undefined" == typeof s && (s = 16777215), t.lineStyle(r, n, 11), t.beginFill(s), c = h, t.moveTo(e, -i), u = e + Math.cos(l) * this.game.width, d = i + Math.sin(l) * this.game.height, t.lineTo(u, -d), t.moveTo(e, -i), u = e + Math.cos(l) * -this.game.width, d = i + Math.sin(l) * -this.game.height, t.lineTo(u, -d)
                    },
                    randomPastelHex: function() {
                        var t, e, i, s;
                        return i = [255, 255, 255], s = Math.floor(256 * Math.random()), e = Math.floor(256 * Math.random()), t = Math.floor(256 * Math.random()), s = Math.floor((s + 3 * i[0]) / 4), e = Math.floor((e + 3 * i[1]) / 4), t = Math.floor((t + 3 * i[2]) / 4), this.rgbToHex(s, e, t)
                    },
                    rgbToHex: function(t, e, i) {
                        return this.componentToHex(t) + this.componentToHex(e) + this.componentToHex(i)
                    },
                    componentToHex: function(t) {
                        var e;
                        return e = t.toString(16), 2 === e.len ? e : e + "0"
                    }
                }), Phaser.Physics.P2.Spring = function(t, e, i, s, n, r, o, a, h, l) {
                    this.game = t.game, this.world = t, "undefined" == typeof s && (s = 1), "undefined" == typeof n && (n = 100), "undefined" == typeof r && (r = 1), s = t.pxm(s);
                    var c = {
                        restLength: s,
                        stiffness: n,
                        damping: r
                    };
                    "undefined" != typeof o && null !== o && (c.worldAnchorA = [t.pxm(o[0]), t.pxm(o[1])]), "undefined" != typeof a && null !== a && (c.worldAnchorB = [t.pxm(a[0]), t.pxm(a[1])]), "undefined" != typeof h && null !== h && (c.localAnchorA = [t.pxm(h[0]), t.pxm(h[1])]), "undefined" != typeof l && null !== l && (c.localAnchorB = [t.pxm(l[0]), t.pxm(l[1])]), p2.Spring.call(this, e, i, c)
                }, Phaser.Physics.P2.Spring.prototype = Object.create(p2.Spring.prototype), Phaser.Physics.P2.Spring.prototype.constructor = Phaser.Physics.P2.Spring, Phaser.Physics.P2.Material = function(t) {
                    this.name = t, p2.Material.call(this)
                }, Phaser.Physics.P2.Material.prototype = Object.create(p2.Material.prototype), Phaser.Physics.P2.Material.prototype.constructor = Phaser.Physics.P2.Material, Phaser.Physics.P2.ContactMaterial = function(t, e, i) {
                    p2.ContactMaterial.call(this, t, e, i)
                }, Phaser.Physics.P2.ContactMaterial.prototype = Object.create(p2.ContactMaterial.prototype), Phaser.Physics.P2.ContactMaterial.prototype.constructor = Phaser.Physics.P2.ContactMaterial, Phaser.Physics.P2.CollisionGroup = function(t) {
                    this.mask = t
                }, Phaser.Physics.P2.DistanceConstraint = function(t, e, i, s, n) {
                    "undefined" == typeof s && (s = 100), this.game = t.game, this.world = t, s = t.pxm(s), p2.DistanceConstraint.call(this, e, i, s, {
                        maxForce: n
                    })
                }, Phaser.Physics.P2.DistanceConstraint.prototype = Object.create(p2.DistanceConstraint.prototype), Phaser.Physics.P2.DistanceConstraint.prototype.constructor = Phaser.Physics.P2.DistanceConstraint, Phaser.Physics.P2.GearConstraint = function(t, e, i, s, n) {
                    "undefined" == typeof s && (s = 0), "undefined" == typeof n && (n = 1), this.game = t.game, this.world = t;
                    var r = {
                        angle: s,
                        ratio: n
                    };
                    p2.GearConstraint.call(this, e, i, r)
                }, Phaser.Physics.P2.GearConstraint.prototype = Object.create(p2.GearConstraint.prototype), Phaser.Physics.P2.GearConstraint.prototype.constructor = Phaser.Physics.P2.GearConstraint, Phaser.Physics.P2.LockConstraint = function(t, e, i, s, n, r) {
                    "undefined" == typeof s && (s = [0, 0]), "undefined" == typeof n && (n = 0), "undefined" == typeof r && (r = Number.MAX_VALUE), this.game = t.game, this.world = t, s = [t.pxm(s[0]), t.pxm(s[1])];
                    var o = {
                        localOffsetB: s,
                        localAngleB: n,
                        maxForce: r
                    };
                    p2.LockConstraint.call(this, e, i, o)
                }, Phaser.Physics.P2.LockConstraint.prototype = Object.create(p2.LockConstraint.prototype), Phaser.Physics.P2.LockConstraint.prototype.constructor = Phaser.Physics.P2.LockConstraint, Phaser.Physics.P2.PrismaticConstraint = function(t, e, i, s, n, r, o, a) {
                    "undefined" == typeof s && (s = !0), "undefined" == typeof n && (n = [0, 0]), "undefined" == typeof r && (r = [0, 0]), "undefined" == typeof o && (o = [0, 0]), "undefined" == typeof a && (a = Number.MAX_VALUE), this.game = t.game, this.world = t, n = [t.pxmi(n[0]), t.pxmi(n[1])], r = [t.pxmi(r[0]), t.pxmi(r[1])];
                    var h = {
                        localAnchorA: n,
                        localAnchorB: r,
                        localAxisA: o,
                        maxForce: a,
                        disableRotationalLock: !s
                    };
                    p2.PrismaticConstraint.call(this, e, i, h)
                }, Phaser.Physics.P2.PrismaticConstraint.prototype = Object.create(p2.PrismaticConstraint.prototype), Phaser.Physics.P2.PrismaticConstraint.prototype.constructor = Phaser.Physics.P2.PrismaticConstraint, Phaser.Physics.P2.RevoluteConstraint = function(t, e, i, s, n, r) {
                    "undefined" == typeof r && (r = Number.MAX_VALUE), this.game = t.game, this.world = t, i = [t.pxmi(i[0]), t.pxmi(i[1])], n = [t.pxmi(n[0]), t.pxmi(n[1])], p2.RevoluteConstraint.call(this, e, i, s, n, {
                        maxForce: r
                    })
                }, Phaser.Physics.P2.RevoluteConstraint.prototype = Object.create(p2.RevoluteConstraint.prototype), Phaser.Physics.P2.RevoluteConstraint.prototype.constructor = Phaser.Physics.P2.RevoluteConstraint, r("undefined" != typeof Phaser ? Phaser : window.Phaser)
            }).call(i, void 0, void 0, void 0, function(t) {
                e.exports = t
            })
        }).call(this, "undefined" != typeof self ? self : "undefined" != typeof window ? window : {})
    }, {}],
    AqMBDX: [function(t, e) {
        (function(t) {
            (function(t, e, i, s) {
                (function() {
                    var s = this,
                        n = n || {};
                    n.WEBGL_RENDERER = 0, n.CANVAS_RENDERER = 1, n.VERSION = "v1.6.1", n.blendModes = {
                        NORMAL: 0,
                        ADD: 1,
                        MULTIPLY: 2,
                        SCREEN: 3,
                        OVERLAY: 4,
                        DARKEN: 5,
                        LIGHTEN: 6,
                        COLOR_DODGE: 7,
                        COLOR_BURN: 8,
                        HARD_LIGHT: 9,
                        SOFT_LIGHT: 10,
                        DIFFERENCE: 11,
                        EXCLUSION: 12,
                        HUE: 13,
                        SATURATION: 14,
                        COLOR: 15,
                        LUMINOSITY: 16
                    }, n.scaleModes = {
                        DEFAULT: 0,
                        LINEAR: 0,
                        NEAREST: 1
                    }, n._UID = 0, "undefined" != typeof Float32Array ? (n.Float32Array = Float32Array, n.Uint16Array = Uint16Array) : (n.Float32Array = Array, n.Uint16Array = Array), n.INTERACTION_FREQUENCY = 30, n.AUTO_PREVENT_DEFAULT = !0, n.RAD_TO_DEG = 180 / Math.PI, n.DEG_TO_RAD = Math.PI / 180, n.dontSayHello = !1, n.sayHello = function(t) {
                        if (!n.dontSayHello) {
                            if (navigator.userAgent.toLowerCase().indexOf("chrome") > -1) {
                                var e = ["%c %c %c Pixi.js " + n.VERSION + " - " + t + "  %c  %c  http://www.pixijs.com/  %c %c ♥%c♥%c♥ ", "background: #ff66a5", "background: #ff66a5", "color: #ff66a5; background: #030307;", "background: #ff66a5", "background: #ffc3dc", "background: #ff66a5", "color: #ff2424; background: #fff", "color: #ff2424; background: #fff", "color: #ff2424; background: #fff"];
                                console.log.apply(console, e)
                            } else window.console && console.log("Pixi.js " + n.VERSION + " - http://www.pixijs.com/");
                            n.dontSayHello = !0
                        }
                    }, n.Point = function(t, e) {
                        this.x = t || 0, this.y = e || 0
                    }, n.Point.prototype.clone = function() {
                        return new n.Point(this.x, this.y)
                    }, n.Point.prototype.set = function(t, e) {
                        this.x = t || 0, this.y = e || (0 !== e ? this.x : 0)
                    }, n.Point.prototype.constructor = n.Point, n.Rectangle = function(t, e, i, s) {
                        this.x = t || 0, this.y = e || 0, this.width = i || 0, this.height = s || 0
                    }, n.Rectangle.prototype.clone = function() {
                        return new n.Rectangle(this.x, this.y, this.width, this.height)
                    }, n.Rectangle.prototype.contains = function(t, e) {
                        if (this.width <= 0 || this.height <= 0) return !1;
                        var i = this.x;
                        if (t >= i && t <= i + this.width) {
                            var s = this.y;
                            if (e >= s && e <= s + this.height) return !0
                        }
                        return !1
                    }, n.Rectangle.prototype.constructor = n.Rectangle, n.EmptyRectangle = new n.Rectangle(0, 0, 0, 0), n.Polygon = function(t) {
                        if (t instanceof Array || (t = Array.prototype.slice.call(arguments)), "number" == typeof t[0]) {
                            for (var e = [], i = 0, s = t.length; s > i; i += 2) e.push(new n.Point(t[i], t[i + 1]));
                            t = e
                        }
                        this.points = t
                    }, n.Polygon.prototype.clone = function() {
                        for (var t = [], e = 0; e < this.points.length; e++) t.push(this.points[e].clone());
                        return new n.Polygon(t)
                    }, n.Polygon.prototype.contains = function(t, e) {
                        for (var i = !1, s = 0, n = this.points.length - 1; s < this.points.length; n = s++) {
                            var r = this.points[s].x,
                                o = this.points[s].y,
                                a = this.points[n].x,
                                h = this.points[n].y,
                                l = o > e != h > e && (a - r) * (e - o) / (h - o) + r > t;
                            l && (i = !i)
                        }
                        return i
                    }, n.Polygon.prototype.constructor = n.Polygon, n.Circle = function(t, e, i) {
                        this.x = t || 0, this.y = e || 0, this.radius = i || 0
                    }, n.Circle.prototype.clone = function() {
                        return new n.Circle(this.x, this.y, this.radius)
                    }, n.Circle.prototype.contains = function(t, e) {
                        if (this.radius <= 0) return !1;
                        var i = this.x - t,
                            s = this.y - e,
                            n = this.radius * this.radius;
                        return i *= i, s *= s, n >= i + s
                    }, n.Circle.prototype.getBounds = function() {
                        return new n.Rectangle(this.x - this.radius, this.y - this.radius, this.width, this.height)
                    }, n.Circle.prototype.constructor = n.Circle, n.Ellipse = function(t, e, i, s) {
                        this.x = t || 0, this.y = e || 0, this.width = i || 0, this.height = s || 0
                    }, n.Ellipse.prototype.clone = function() {
                        return new n.Ellipse(this.x, this.y, this.width, this.height)
                    }, n.Ellipse.prototype.contains = function(t, e) {
                        if (this.width <= 0 || this.height <= 0) return !1;
                        var i = (t - this.x) / this.width,
                            s = (e - this.y) / this.height;
                        return i *= i, s *= s, 1 >= i + s
                    }, n.Ellipse.prototype.getBounds = function() {
                        return new n.Rectangle(this.x - this.width, this.y - this.height, this.width, this.height)
                    }, n.Ellipse.prototype.constructor = n.Ellipse, n.Matrix = function() {
                        this.a = 1, this.b = 0, this.c = 0, this.d = 1, this.tx = 0, this.ty = 0
                    }, n.Matrix.prototype.fromArray = function(t) {
                        this.a = t[0], this.b = t[1], this.c = t[3], this.d = t[4], this.tx = t[2], this.ty = t[5]
                    }, n.Matrix.prototype.toArray = function(t) {
                        this.array || (this.array = new Float32Array(9));
                        var e = this.array;
                        return t ? (e[0] = this.a, e[1] = this.c, e[2] = 0, e[3] = this.b, e[4] = this.d, e[5] = 0, e[6] = this.tx, e[7] = this.ty, e[8] = 1) : (e[0] = this.a, e[1] = this.b, e[2] = this.tx, e[3] = this.c, e[4] = this.d, e[5] = this.ty, e[6] = 0, e[7] = 0, e[8] = 1), e
                    }, n.identityMatrix = new n.Matrix, n.determineMatrixArrayType = function() {
                        return "undefined" != typeof Float32Array ? Float32Array : Array
                    }, n.Matrix2 = n.determineMatrixArrayType(), n.DisplayObject = function() {
                        this.position = new n.Point, this.scale = new n.Point(1, 1), this.pivot = new n.Point(0, 0), this.rotation = 0, this.alpha = 1, this.visible = !0, this.hitArea = null, this.buttonMode = !1, this.renderable = !1, this.parent = null, this.stage = null, this.worldAlpha = 1, this._interactive = !1, this.defaultCursor = "pointer", this.worldTransform = new n.Matrix, this.color = [], this.dynamic = !0, this._sr = 0, this._cr = 1, this.filterArea = null, this._bounds = new n.Rectangle(0, 0, 1, 1), this._currentBounds = null, this._mask = null, this._cacheAsBitmap = !1, this._cacheIsDirty = !1
                    }, n.DisplayObject.prototype.constructor = n.DisplayObject, n.DisplayObject.prototype.setInteractive = function(t) {
                        this.interactive = t
                    }, Object.defineProperty(n.DisplayObject.prototype, "interactive", {
                        get: function() {
                            return this._interactive
                        },
                        set: function(t) {
                            this._interactive = t, this.stage && (this.stage.dirty = !0)
                        }
                    }), Object.defineProperty(n.DisplayObject.prototype, "worldVisible", {
                        get: function() {
                            var t = this;
                            do {
                                if (!t.visible) return !1;
                                t = t.parent
                            } while (t);
                            return !0
                        }
                    }), Object.defineProperty(n.DisplayObject.prototype, "mask", {
                        get: function() {
                            return this._mask
                        },
                        set: function(t) {
                            this._mask && (this._mask.isMask = !1), this._mask = t, this._mask && (this._mask.isMask = !0)
                        }
                    }), Object.defineProperty(n.DisplayObject.prototype, "filters", {
                        get: function() {
                            return this._filters
                        },
                        set: function(t) {
                            if (t) {
                                for (var e = [], i = 0; i < t.length; i++)
                                    for (var s = t[i].passes, n = 0; n < s.length; n++) e.push(s[n]);
                                this._filterBlock = {
                                    target: this,
                                    filterPasses: e
                                }
                            }
                            this._filters = t
                        }
                    }), Object.defineProperty(n.DisplayObject.prototype, "cacheAsBitmap", {
                        get: function() {
                            return this._cacheAsBitmap
                        },
                        set: function(t) {
                            this._cacheAsBitmap !== t && (t ? this._generateCachedSprite() : this._destroyCachedSprite(), this._cacheAsBitmap = t)
                        }
                    }), n.DisplayObject.prototype.updateTransform = function() {
                        this.rotation !== this.rotationCache && (this.rotationCache = this.rotation, this._sr = Math.sin(this.rotation), this._cr = Math.cos(this.rotation));
                        var t = this.parent.worldTransform,
                            e = this.worldTransform,
                            i = this.pivot.x,
                            s = this.pivot.y,
                            n = this._cr * this.scale.x,
                            r = -this._sr * this.scale.y,
                            o = this._sr * this.scale.x,
                            a = this._cr * this.scale.y,
                            h = this.position.x - n * i - s * r,
                            l = this.position.y - a * s - i * o,
                            c = t.a,
                            u = t.b,
                            d = t.c,
                            p = t.d;
                        e.a = c * n + u * o, e.b = c * r + u * a, e.tx = c * h + u * l + t.tx, e.c = d * n + p * o, e.d = d * r + p * a, e.ty = d * h + p * l + t.ty, this.worldAlpha = this.alpha * this.parent.worldAlpha
                    }, n.DisplayObject.prototype.getBounds = function(t) {
                        return t = t, n.EmptyRectangle
                    }, n.DisplayObject.prototype.getLocalBounds = function() {
                        return this.getBounds(n.identityMatrix)
                    }, n.DisplayObject.prototype.setStageReference = function(t) {
                        this.stage = t, this._interactive && (this.stage.dirty = !0)
                    }, n.DisplayObject.prototype.generateTexture = function(t) {
                        var e = this.getLocalBounds(),
                            i = new n.RenderTexture(0 | e.width, 0 | e.height, t);
                        return i.render(this, new n.Point(-e.x, -e.y)), i
                    }, n.DisplayObject.prototype.updateCache = function() {
                        this._generateCachedSprite()
                    }, n.DisplayObject.prototype._renderCachedSprite = function(t) {
                        this._cachedSprite.worldAlpha = this.worldAlpha, t.gl ? n.Sprite.prototype._renderWebGL.call(this._cachedSprite, t) : n.Sprite.prototype._renderCanvas.call(this._cachedSprite, t)
                    }, n.DisplayObject.prototype._generateCachedSprite = function() {
                        this._cacheAsBitmap = !1;
                        var t = this.getLocalBounds();
                        if (this._cachedSprite) this._cachedSprite.texture.resize(0 | t.width, 0 | t.height);
                        else {
                            var e = new n.RenderTexture(0 | t.width, 0 | t.height);
                            this._cachedSprite = new n.Sprite(e), this._cachedSprite.worldTransform = this.worldTransform
                        }
                        var i = this._filters;
                        this._filters = null, this._cachedSprite.filters = i, this._cachedSprite.texture.render(this, new n.Point(-t.x, -t.y)), this._cachedSprite.anchor.x = -(t.x / t.width), this._cachedSprite.anchor.y = -(t.y / t.height), this._filters = i, this._cacheAsBitmap = !0
                    }, n.DisplayObject.prototype._destroyCachedSprite = function() {
                        this._cachedSprite && (this._cachedSprite.texture.destroy(!0), this._cachedSprite = null)
                    }, n.DisplayObject.prototype._renderWebGL = function(t) {
                        t = t
                    }, n.DisplayObject.prototype._renderCanvas = function(t) {
                        t = t
                    }, Object.defineProperty(n.DisplayObject.prototype, "x", {
                        get: function() {
                            return this.position.x
                        },
                        set: function(t) {
                            this.position.x = t
                        }
                    }), Object.defineProperty(n.DisplayObject.prototype, "y", {
                        get: function() {
                            return this.position.y
                        },
                        set: function(t) {
                            this.position.y = t
                        }
                    }), n.DisplayObjectContainer = function() {
                        n.DisplayObject.call(this), this.children = []
                    }, n.DisplayObjectContainer.prototype = Object.create(n.DisplayObject.prototype), n.DisplayObjectContainer.prototype.constructor = n.DisplayObjectContainer, Object.defineProperty(n.DisplayObjectContainer.prototype, "width", {
                        get: function() {
                            return this.scale.x * this.getLocalBounds().width
                        },
                        set: function(t) {
                            var e = this.getLocalBounds().width;
                            this.scale.x = 0 !== e ? t / (e / this.scale.x) : 1, this._width = t
                        }
                    }), Object.defineProperty(n.DisplayObjectContainer.prototype, "height", {
                        get: function() {
                            return this.scale.y * this.getLocalBounds().height
                        },
                        set: function(t) {
                            var e = this.getLocalBounds().height;
                            this.scale.y = 0 !== e ? t / (e / this.scale.y) : 1, this._height = t
                        }
                    }), n.DisplayObjectContainer.prototype.addChild = function(t) {
                        return this.addChildAt(t, this.children.length)
                    }, n.DisplayObjectContainer.prototype.addChildAt = function(t, e) {
                        if (e >= 0 && e <= this.children.length) return t.parent && t.parent.removeChild(t), t.parent = this, this.children.splice(e, 0, t), this.stage && t.setStageReference(this.stage), t;
                        throw new Error(t + " The index " + e + " supplied is out of bounds " + this.children.length)
                    }, n.DisplayObjectContainer.prototype.swapChildren = function(t, e) {
                        if (t !== e) {
                            var i = this.children.indexOf(t),
                                s = this.children.indexOf(e);
                            if (0 > i || 0 > s) throw new Error("swapChildren: Both the supplied DisplayObjects must be a child of the caller.");
                            this.children[i] = e, this.children[s] = t
                        }
                    }, n.DisplayObjectContainer.prototype.getChildAt = function(t) {
                        if (t >= 0 && t < this.children.length) return this.children[t];
                        throw new Error("Supplied index does not exist in the child list, or the supplied DisplayObject must be a child of the caller")
                    }, n.DisplayObjectContainer.prototype.removeChild = function(t) {
                        return this.removeChildAt(this.children.indexOf(t))
                    }, n.DisplayObjectContainer.prototype.removeChildAt = function(t) {
                        var e = this.getChildAt(t);
                        return this.stage && e.removeStageReference(), e.parent = void 0, this.children.splice(t, 1), e
                    }, n.DisplayObjectContainer.prototype.removeChildren = function(t, e) {
                        var i = t || 0,
                            s = "number" == typeof e ? e : this.children.length,
                            n = s - i;
                        if (n > 0 && s >= n) {
                            for (var r = this.children.splice(i, n), o = 0; o < r.length; o++) {
                                var a = r[o];
                                this.stage && a.removeStageReference(), a.parent = void 0
                            }
                            return r
                        }
                        throw new Error("Range Error, numeric values are outside the acceptable range")
                    }, n.DisplayObjectContainer.prototype.updateTransform = function() {
                        if (this.visible && (n.DisplayObject.prototype.updateTransform.call(this), !this._cacheAsBitmap))
                            for (var t = 0, e = this.children.length; e > t; t++) this.children[t].updateTransform()
                    }, n.DisplayObjectContainer.prototype.getBounds = function(t) {
                        if (0 === this.children.length) return n.EmptyRectangle;
                        if (t) {
                            var e = this.worldTransform;
                            this.worldTransform = t, this.updateTransform(), this.worldTransform = e
                        }
                        for (var i, s, r, o = 1 / 0, a = 1 / 0, h = -1 / 0, l = -1 / 0, c = !1, u = 0, d = this.children.length; d > u; u++) {
                            var p = this.children[u];
                            p.visible && (c = !0, i = this.children[u].getBounds(t), o = o < i.x ? o : i.x, a = a < i.y ? a : i.y, s = i.width + i.x, r = i.height + i.y, h = h > s ? h : s, l = l > r ? l : r)
                        }
                        if (!c) return n.EmptyRectangle;
                        var f = this._bounds;
                        return f.x = o, f.y = a, f.width = h - o, f.height = l - a, f
                    }, n.DisplayObjectContainer.prototype.getLocalBounds = function() {
                        var t = this.worldTransform;
                        this.worldTransform = n.identityMatrix;
                        for (var e = 0, i = this.children.length; i > e; e++) this.children[e].updateTransform();
                        var s = this.getBounds();
                        return this.worldTransform = t, s
                    }, n.DisplayObjectContainer.prototype.setStageReference = function(t) {
                        this.stage = t, this._interactive && (this.stage.dirty = !0);
                        for (var e = 0, i = this.children.length; i > e; e++) {
                            var s = this.children[e];
                            s.setStageReference(t)
                        }
                    }, n.DisplayObjectContainer.prototype.removeStageReference = function() {
                        for (var t = 0, e = this.children.length; e > t; t++) {
                            var i = this.children[t];
                            i.removeStageReference()
                        }
                        this._interactive && (this.stage.dirty = !0), this.stage = null
                    }, n.DisplayObjectContainer.prototype._renderWebGL = function(t) {
                        if (this.visible && !(this.alpha <= 0)) {
                            if (this._cacheAsBitmap) return void this._renderCachedSprite(t);
                            var e, i;
                            if (this._mask || this._filters) {
                                for (this._filters && (t.spriteBatch.flush(), t.filterManager.pushFilter(this._filterBlock)), this._mask && (t.spriteBatch.stop(), t.maskManager.pushMask(this.mask, t), t.spriteBatch.start()), e = 0, i = this.children.length; i > e; e++) this.children[e]._renderWebGL(t);
                                t.spriteBatch.stop(), this._mask && t.maskManager.popMask(this._mask, t), this._filters && t.filterManager.popFilter(), t.spriteBatch.start()
                            } else
                                for (e = 0, i = this.children.length; i > e; e++) this.children[e]._renderWebGL(t)
                        }
                    }, n.DisplayObjectContainer.prototype._renderCanvas = function(t) {
                        if (this.visible !== !1 && 0 !== this.alpha) {
                            if (this._cacheAsBitmap) return void this._renderCachedSprite(t);
                            this._mask && t.maskManager.pushMask(this._mask, t.context);
                            for (var e = 0, i = this.children.length; i > e; e++) {
                                var s = this.children[e];
                                s._renderCanvas(t)
                            }
                            this._mask && t.maskManager.popMask(t.context)
                        }
                    }, n.Sprite = function(t) {
                        n.DisplayObjectContainer.call(this), this.anchor = new n.Point, this.texture = t, this._width = 0, this._height = 0, this.tint = 16777215, this.blendMode = n.blendModes.NORMAL, t.baseTexture.hasLoaded ? this.onTextureUpdate() : (this.onTextureUpdateBind = this.onTextureUpdate.bind(this), this.texture.addEventListener("update", this.onTextureUpdateBind)), this.renderable = !0
                    }, n.Sprite.prototype = Object.create(n.DisplayObjectContainer.prototype), n.Sprite.prototype.constructor = n.Sprite, Object.defineProperty(n.Sprite.prototype, "width", {
                        get: function() {
                            return this.scale.x * this.texture.frame.width
                        },
                        set: function(t) {
                            this.scale.x = t / this.texture.frame.width, this._width = t
                        }
                    }), Object.defineProperty(n.Sprite.prototype, "height", {
                        get: function() {
                            return this.scale.y * this.texture.frame.height
                        },
                        set: function(t) {
                            this.scale.y = t / this.texture.frame.height, this._height = t
                        }
                    }), n.Sprite.prototype.setTexture = function(t) {
                        this.texture = t, this.cachedTint = 16777215
                    }, n.Sprite.prototype.onTextureUpdate = function() {
                        this._width && (this.scale.x = this._width / this.texture.frame.width), this._height && (this.scale.y = this._height / this.texture.frame.height)
                    }, n.Sprite.prototype.getBounds = function(t) {
                        var e = this.texture.frame.width,
                            i = this.texture.frame.height,
                            s = e * (1 - this.anchor.x),
                            n = e * -this.anchor.x,
                            r = i * (1 - this.anchor.y),
                            o = i * -this.anchor.y,
                            a = t || this.worldTransform,
                            h = a.a,
                            l = a.c,
                            c = a.b,
                            u = a.d,
                            d = a.tx,
                            p = a.ty,
                            f = h * n + c * o + d,
                            g = u * o + l * n + p,
                            m = h * s + c * o + d,
                            y = u * o + l * s + p,
                            v = h * s + c * r + d,
                            x = u * r + l * s + p,
                            b = h * n + c * r + d,
                            _ = u * r + l * n + p,
                            w = -1 / 0,
                            P = -1 / 0,
                            T = 1 / 0,
                            S = 1 / 0;
                        T = T > f ? f : T, T = T > m ? m : T, T = T > v ? v : T, T = T > b ? b : T, S = S > g ? g : S, S = S > y ? y : S, S = S > x ? x : S, S = S > _ ? _ : S, w = f > w ? f : w, w = m > w ? m : w, w = v > w ? v : w, w = b > w ? b : w, P = g > P ? g : P, P = y > P ? y : P, P = x > P ? x : P, P = _ > P ? _ : P;
                        var C = this._bounds;
                        return C.x = T, C.width = w - T, C.y = S, C.height = P - S, this._currentBounds = C, C
                    }, n.Sprite.prototype._renderWebGL = function(t) {
                        if (this.visible && !(this.alpha <= 0)) {
                            var e, i;
                            if (this._mask || this._filters) {
                                var s = t.spriteBatch;
                                for (this._filters && (s.flush(), t.filterManager.pushFilter(this._filterBlock)), this._mask && (s.stop(), t.maskManager.pushMask(this.mask, t), s.start()), s.render(this), e = 0, i = this.children.length; i > e; e++) this.children[e]._renderWebGL(t);
                                s.stop(), this._mask && t.maskManager.popMask(this._mask, t), this._filters && t.filterManager.popFilter(), s.start()
                            } else
                                for (t.spriteBatch.render(this), e = 0, i = this.children.length; i > e; e++) this.children[e]._renderWebGL(t)
                        }
                    }, n.Sprite.prototype._renderCanvas = function(t) {
                        if (this.visible !== !1 && 0 !== this.alpha) {
                            if (this.blendMode !== t.currentBlendMode && (t.currentBlendMode = this.blendMode, t.context.globalCompositeOperation = n.blendModesCanvas[t.currentBlendMode]), this._mask && t.maskManager.pushMask(this._mask, t.context), this.texture.valid) {
                                t.context.globalAlpha = this.worldAlpha, t.roundPixels ? t.context.setTransform(this.worldTransform.a, this.worldTransform.c, this.worldTransform.b, this.worldTransform.d, 0 | this.worldTransform.tx, 0 | this.worldTransform.ty) : t.context.setTransform(this.worldTransform.a, this.worldTransform.c, this.worldTransform.b, this.worldTransform.d, this.worldTransform.tx, this.worldTransform.ty), t.smoothProperty && t.scaleMode !== this.texture.baseTexture.scaleMode && (t.scaleMode = this.texture.baseTexture.scaleMode, t.context[t.smoothProperty] = t.scaleMode === n.scaleModes.LINEAR);
                                var e = this.texture.trim ? this.texture.trim.x - this.anchor.x * this.texture.trim.width : this.anchor.x * -this.texture.frame.width,
                                    i = this.texture.trim ? this.texture.trim.y - this.anchor.y * this.texture.trim.height : this.anchor.y * -this.texture.frame.height;
                                16777215 !== this.tint ? (this.cachedTint !== this.tint && (this.cachedTint = this.tint, this.tintedTexture = n.CanvasTinter.getTintedTexture(this, this.tint)), t.context.drawImage(this.tintedTexture, 0, 0, this.texture.crop.width, this.texture.crop.height, e, i, this.texture.crop.width, this.texture.crop.height)) : t.context.drawImage(this.texture.baseTexture.source, this.texture.crop.x, this.texture.crop.y, this.texture.crop.width, this.texture.crop.height, e, i, this.texture.crop.width, this.texture.crop.height)
                            }
                            for (var s = 0, r = this.children.length; r > s; s++) this.children[s]._renderCanvas(t);
                            this._mask && t.maskManager.popMask(t.context)
                        }
                    }, n.Sprite.fromFrame = function(t) {
                        var e = n.TextureCache[t];
                        if (!e) throw new Error('The frameId "' + t + '" does not exist in the texture cache' + this);
                        return new n.Sprite(e)
                    }, n.Sprite.fromImage = function(t, e, i) {
                        var s = n.Texture.fromImage(t, e, i);
                        return new n.Sprite(s)
                    }, n.SpriteBatch = function(t) {
                        n.DisplayObjectContainer.call(this), this.textureThing = t, this.ready = !1
                    }, n.SpriteBatch.prototype = Object.create(n.DisplayObjectContainer.prototype), n.SpriteBatch.constructor = n.SpriteBatch, n.SpriteBatch.prototype.initWebGL = function(t) {
                        this.fastSpriteBatch = new n.WebGLFastSpriteBatch(t), this.ready = !0
                    }, n.SpriteBatch.prototype.updateTransform = function() {
                        n.DisplayObject.prototype.updateTransform.call(this)
                    }, n.SpriteBatch.prototype._renderWebGL = function(t) {
                        !this.visible || this.alpha <= 0 || !this.children.length || (this.ready || this.initWebGL(t.gl), t.spriteBatch.stop(), t.shaderManager.setShader(t.shaderManager.fastShader), this.fastSpriteBatch.begin(this, t), this.fastSpriteBatch.render(this), t.spriteBatch.start())
                    }, n.SpriteBatch.prototype._renderCanvas = function(t) {
                        var e = t.context;
                        e.globalAlpha = this.worldAlpha, n.DisplayObject.prototype.updateTransform.call(this);
                        for (var i = this.worldTransform, s = !0, r = 0; r < this.children.length; r++) {
                            var o = this.children[r];
                            if (o.visible) {
                                var a = o.texture,
                                    h = a.frame;
                                if (e.globalAlpha = this.worldAlpha * o.alpha, o.rotation % (2 * Math.PI) === 0) s && (e.setTransform(i.a, i.c, i.b, i.d, i.tx, i.ty), s = !1), e.drawImage(a.baseTexture.source, h.x, h.y, h.width, h.height, o.anchor.x * -h.width * o.scale.x + o.position.x + .5 | 0, o.anchor.y * -h.height * o.scale.y + o.position.y + .5 | 0, h.width * o.scale.x, h.height * o.scale.y);
                                else {
                                    s || (s = !0), n.DisplayObject.prototype.updateTransform.call(o);
                                    var l = o.worldTransform;
                                    t.roundPixels ? e.setTransform(l.a, l.c, l.b, l.d, 0 | l.tx, 0 | l.ty) : e.setTransform(l.a, l.c, l.b, l.d, l.tx, l.ty), e.drawImage(a.baseTexture.source, h.x, h.y, h.width, h.height, o.anchor.x * -h.width + .5 | 0, o.anchor.y * -h.height + .5 | 0, h.width, h.height)
                                }
                            }
                        }
                    }, n.AbstractFilter = function(t, e) {
                        this.passes = [this], this.shaders = [], this.dirty = !0, this.padding = 0, this.uniforms = e || {}, this.fragmentSrc = t || []
                    }, n.FilterBlock = function() {
                        this.visible = !0, this.renderable = !0
                    }, n.Text = function(t, e) {
                        this.canvas = document.createElement("canvas"), this.context = this.canvas.getContext("2d"), n.Sprite.call(this, n.Texture.fromCanvas(this.canvas)), this.setText(t), this.setStyle(e)
                    }, n.Text.prototype = Object.create(n.Sprite.prototype), n.Text.prototype.constructor = n.Text, Object.defineProperty(n.Text.prototype, "width", {
                        get: function() {
                            return this.dirty && (this.updateText(), this.dirty = !1), this.scale.x * this.texture.frame.width
                        },
                        set: function(t) {
                            this.scale.x = t / this.texture.frame.width, this._width = t
                        }
                    }), Object.defineProperty(n.Text.prototype, "height", {
                        get: function() {
                            return this.dirty && (this.updateText(), this.dirty = !1), this.scale.y * this.texture.frame.height
                        },
                        set: function(t) {
                            this.scale.y = t / this.texture.frame.height, this._height = t
                        }
                    }), n.Text.prototype.setStyle = function(t) {
                        t = t || {}, t.font = t.font || "bold 20pt Arial", t.fill = t.fill || "black", t.align = t.align || "left", t.stroke = t.stroke || "black", t.strokeThickness = t.strokeThickness || 0, t.wordWrap = t.wordWrap || !1, t.wordWrapWidth = t.wordWrapWidth || 100, t.wordWrapWidth = t.wordWrapWidth || 100, t.dropShadow = t.dropShadow || !1, t.dropShadowAngle = t.dropShadowAngle || Math.PI / 6, t.dropShadowDistance = t.dropShadowDistance || 4, t.dropShadowColor = t.dropShadowColor || "black", this.style = t, this.dirty = !0
                    }, n.Text.prototype.setText = function(t) {
                        this.text = t.toString() || " ", this.dirty = !0
                    }, n.Text.prototype.updateText = function() {
                        this.context.font = this.style.font;
                        var t = this.text;
                        this.style.wordWrap && (t = this.wordWrap(this.text));
                        for (var e = t.split(/(?:\r\n|\r|\n)/), i = [], s = 0, n = 0; n < e.length; n++) {
                            var r = this.context.measureText(e[n]).width;
                            i[n] = r, s = Math.max(s, r)
                        }
                        var o = s + this.style.strokeThickness;
                        this.style.dropShadow && (o += this.style.dropShadowDistance), this.canvas.width = o + this.context.lineWidth;
                        var a = this.determineFontHeight("font: " + this.style.font + ";") + this.style.strokeThickness,
                            h = a * e.length;
                        this.style.dropShadow && (h += this.style.dropShadowDistance), this.canvas.height = h, navigator.isCocoonJS && this.context.clearRect(0, 0, this.canvas.width, this.canvas.height), this.context.font = this.style.font, this.context.strokeStyle = this.style.stroke, this.context.lineWidth = this.style.strokeThickness, this.context.textBaseline = "top";
                        var l, c;
                        if (this.style.dropShadow) {
                            this.context.fillStyle = this.style.dropShadowColor;
                            var u = Math.sin(this.style.dropShadowAngle) * this.style.dropShadowDistance,
                                d = Math.cos(this.style.dropShadowAngle) * this.style.dropShadowDistance;
                            for (n = 0; n < e.length; n++) l = this.style.strokeThickness / 2, c = this.style.strokeThickness / 2 + n * a, "right" === this.style.align ? l += s - i[n] : "center" === this.style.align && (l += (s - i[n]) / 2), this.style.fill && this.context.fillText(e[n], l + u, c + d)
                        }
                        for (this.context.fillStyle = this.style.fill, n = 0; n < e.length; n++) l = this.style.strokeThickness / 2, c = this.style.strokeThickness / 2 + n * a, "right" === this.style.align ? l += s - i[n] : "center" === this.style.align && (l += (s - i[n]) / 2), this.style.stroke && this.style.strokeThickness && this.context.strokeText(e[n], l, c), this.style.fill && this.context.fillText(e[n], l, c);
                        this.updateTexture()
                    }, n.Text.prototype.updateTexture = function() {
                        this.texture.baseTexture.width = this.canvas.width, this.texture.baseTexture.height = this.canvas.height, this.texture.crop.width = this.texture.frame.width = this.canvas.width, this.texture.crop.height = this.texture.frame.height = this.canvas.height, this._width = this.canvas.width, this._height = this.canvas.height, this.requiresUpdate = !0
                    }, n.Text.prototype._renderWebGL = function(t) {
                        this.requiresUpdate && (this.requiresUpdate = !1, n.updateWebGLTexture(this.texture.baseTexture, t.gl)), n.Sprite.prototype._renderWebGL.call(this, t)
                    }, n.Text.prototype.updateTransform = function() {
                        this.dirty && (this.updateText(), this.dirty = !1), n.Sprite.prototype.updateTransform.call(this)
                    }, n.Text.prototype.determineFontHeight = function(t) {
                        var e = n.Text.heightCache[t];
                        if (!e) {
                            var i = document.getElementsByTagName("body")[0],
                                s = document.createElement("div"),
                                r = document.createTextNode("M");
                            s.appendChild(r), s.setAttribute("style", t + ";position:absolute;top:0;left:0"), i.appendChild(s), e = s.offsetHeight, n.Text.heightCache[t] = e, i.removeChild(s)
                        }
                        return e
                    }, n.Text.prototype.wordWrap = function(t) {
                        for (var e = "", i = t.split("\n"), s = 0; s < i.length; s++) {
                            for (var n = this.style.wordWrapWidth, r = i[s].split(" "), o = 0; o < r.length; o++) {
                                var a = this.context.measureText(r[o]).width,
                                    h = a + this.context.measureText(" ").width;
                                0 === o || h > n ? (o > 0 && (e += "\n"), e += r[o], n = this.style.wordWrapWidth - a) : (n -= h, e += " " + r[o])
                            }
                            s < i.length - 1 && (e += "\n")
                        }
                        return e
                    }, n.Text.prototype.destroy = function(t) {
                        this.context = null, this.canvas = null, this.texture.destroy(void 0 === t ? !0 : t)
                    }, n.Text.heightCache = {}, n.BitmapText = function(t, e) {
                        n.DisplayObjectContainer.call(this), this._pool = [], this.setText(t), this.setStyle(e), this.updateText(), this.dirty = !1
                    }, n.BitmapText.prototype = Object.create(n.DisplayObjectContainer.prototype), n.BitmapText.prototype.constructor = n.BitmapText, n.BitmapText.prototype.setText = function(t) {
                        this.text = t || " ", this.dirty = !0
                    }, n.BitmapText.prototype.setStyle = function(t) {
                        t = t || {}, t.align = t.align || "left", this.style = t;
                        var e = t.font.split(" ");
                        this.fontName = e[e.length - 1], this.fontSize = e.length >= 2 ? parseInt(e[e.length - 2], 10) : n.BitmapText.fonts[this.fontName].size, this.dirty = !0, this.tint = t.tint
                    }, n.BitmapText.prototype.updateText = function() {
                        for (var t = n.BitmapText.fonts[this.fontName], e = new n.Point, i = null, s = [], r = 0, o = [], a = 0, h = this.fontSize / t.size, l = 0; l < this.text.length; l++) {
                            var c = this.text.charCodeAt(l);
                            if (/(?:\r\n|\r|\n)/.test(this.text.charAt(l))) o.push(e.x), r = Math.max(r, e.x), a++, e.x = 0, e.y += t.lineHeight, i = null;
                            else {
                                var u = t.chars[c];
                                u && (i && u[i] && (e.x += u.kerning[i]), s.push({
                                    texture: u.texture,
                                    line: a,
                                    charCode: c,
                                    position: new n.Point(e.x + u.xOffset, e.y + u.yOffset)
                                }), e.x += u.xAdvance, i = c)
                            }
                        }
                        o.push(e.x), r = Math.max(r, e.x);
                        var d = [];
                        for (l = 0; a >= l; l++) {
                            var p = 0;
                            "right" === this.style.align ? p = r - o[l] : "center" === this.style.align && (p = (r - o[l]) / 2), d.push(p)
                        }
                        var f = this.children.length,
                            g = s.length,
                            m = this.tint || 16777215;
                        for (l = 0; g > l; l++) {
                            var y = f > l ? this.children[l] : this._pool.pop();
                            y ? y.setTexture(s[l].texture) : y = new n.Sprite(s[l].texture), y.position.x = (s[l].position.x + d[s[l].line]) * h, y.position.y = s[l].position.y * h, y.scale.x = y.scale.y = h, y.tint = m, y.parent || this.addChild(y)
                        }
                        for (; this.children.length > g;) {
                            var v = this.getChildAt(this.children.length - 1);
                            this._pool.push(v), this.removeChild(v)
                        }
                        this.textWidth = r * h, this.textHeight = (e.y + t.lineHeight) * h
                    }, n.BitmapText.prototype.updateTransform = function() {
                        this.dirty && (this.updateText(), this.dirty = !1), n.DisplayObjectContainer.prototype.updateTransform.call(this)
                    }, n.BitmapText.fonts = {}, n.Stage = function(t) {
                        n.DisplayObjectContainer.call(this), this.worldTransform = new n.Matrix, this.interactive = !0, this.interactionManager = new n.InteractionManager(this), this.dirty = !0, this.stage = this, this.stage.hitArea = new n.Rectangle(0, 0, 1e5, 1e5), this.setBackgroundColor(t)
                    }, n.Stage.prototype = Object.create(n.DisplayObjectContainer.prototype), n.Stage.prototype.constructor = n.Stage, n.Stage.prototype.setInteractionDelegate = function(t) {
                        this.interactionManager.setTargetDomElement(t)
                    }, n.Stage.prototype.updateTransform = function() {
                        this.worldAlpha = 1;
                        for (var t = 0, e = this.children.length; e > t; t++) this.children[t].updateTransform();
                        this.dirty && (this.dirty = !1, this.interactionManager.dirty = !0), this.interactive && this.interactionManager.update()
                    }, n.Stage.prototype.setBackgroundColor = function(t) {
                        this.backgroundColor = t || 0, this.backgroundColorSplit = n.hex2rgb(this.backgroundColor);
                        var e = this.backgroundColor.toString(16);
                        e = "000000".substr(0, 6 - e.length) + e, this.backgroundColorString = "#" + e
                    }, n.Stage.prototype.getMousePosition = function() {
                        return this.interactionManager.mouse.global
                    };
                    for (var r = 0, o = ["ms", "moz", "webkit", "o"], a = 0; a < o.length && !window.requestAnimationFrame; ++a) window.requestAnimationFrame = window[o[a] + "RequestAnimationFrame"], window.cancelAnimationFrame = window[o[a] + "CancelAnimationFrame"] || window[o[a] + "CancelRequestAnimationFrame"];
                    window.requestAnimationFrame || (window.requestAnimationFrame = function(t) {
                        var e = (new Date).getTime(),
                            i = Math.max(0, 16 - (e - r)),
                            s = window.setTimeout(function() {
                                t(e + i)
                            }, i);
                        return r = e + i, s
                    }), window.cancelAnimationFrame || (window.cancelAnimationFrame = function(t) {
                        clearTimeout(t)
                    }), window.requestAnimFrame = window.requestAnimationFrame, n.hex2rgb = function(t) {
                        return [(t >> 16 & 255) / 255, (t >> 8 & 255) / 255, (255 & t) / 255]
                    }, n.rgb2hex = function(t) {
                        return (255 * t[0] << 16) + (255 * t[1] << 8) + 255 * t[2]
                    }, "function" != typeof Function.prototype.bind && (Function.prototype.bind = function() {
                        var t = Array.prototype.slice;
                        return function(e) {
                            function i() {
                                var r = n.concat(t.call(arguments));
                                s.apply(this instanceof i ? this : e, r)
                            }
                            var s = this,
                                n = t.call(arguments, 1);
                            if ("function" != typeof s) throw new TypeError;
                            return i.prototype = function r(t) {
                                return t && (r.prototype = t), this instanceof r ? void 0 : new r
                            }(s.prototype), i
                        }
                    }()), n.AjaxRequest = function() {
                        var t = ["Msxml2.XMLHTTP.6.0", "Msxml2.XMLHTTP.3.0", "Microsoft.XMLHTTP"];
                        if (!window.ActiveXObject) return window.XMLHttpRequest ? new window.XMLHttpRequest : !1;
                        for (var e = 0; e < t.length; e++) try {
                            return new window.ActiveXObject(t[e])
                        } catch (i) {}
                    }, n.canUseNewCanvasBlendModes = function() {
                        var t = document.createElement("canvas");
                        t.width = 1, t.height = 1;
                        var e = t.getContext("2d");
                        return e.fillStyle = "#000", e.fillRect(0, 0, 1, 1), e.globalCompositeOperation = "multiply", e.fillStyle = "#fff", e.fillRect(0, 0, 1, 1), 0 === e.getImageData(0, 0, 1, 1).data[0]
                    }, n.getNextPowerOfTwo = function(t) {
                        if (t > 0 && 0 === (t & t - 1)) return t;
                        for (var e = 1; t > e;) e <<= 1;
                        return e
                    }, n.EventTarget = function() {
                        var t = {};
                        this.addEventListener = this.on = function(e, i) {
                            void 0 === t[e] && (t[e] = []), -1 === t[e].indexOf(i) && t[e].unshift(i)
                        }, this.dispatchEvent = this.emit = function(e) {
                            if (t[e.type] && t[e.type].length)
                                for (var i = t[e.type].length - 1; i >= 0; i--) t[e.type][i](e)
                        }, this.removeEventListener = this.off = function(e, i) {
                            if (void 0 !== t[e]) {
                                var s = t[e].indexOf(i); - 1 !== s && t[e].splice(s, 1)
                            }
                        }, this.removeAllEventListeners = function(e) {
                            var i = t[e];
                            i && (i.length = 0)
                        }
                    }, n.PolyK = {}, n.PolyK.Triangulate = function(t) {
                        var e = !0,
                            i = t.length >> 1;
                        if (3 > i) return [];
                        for (var s = [], r = [], o = 0; i > o; o++) r.push(o);
                        o = 0;
                        for (var a = i; a > 3;) {
                            var h = r[(o + 0) % a],
                                l = r[(o + 1) % a],
                                c = r[(o + 2) % a],
                                u = t[2 * h],
                                d = t[2 * h + 1],
                                p = t[2 * l],
                                f = t[2 * l + 1],
                                g = t[2 * c],
                                m = t[2 * c + 1],
                                y = !1;
                            if (n.PolyK._convex(u, d, p, f, g, m, e)) {
                                y = !0;
                                for (var v = 0; a > v; v++) {
                                    var x = r[v];
                                    if (x !== h && x !== l && x !== c && n.PolyK._PointInTriangle(t[2 * x], t[2 * x + 1], u, d, p, f, g, m)) {
                                        y = !1;
                                        break
                                    }
                                }
                            }
                            if (y) s.push(h, l, c), r.splice((o + 1) % a, 1), a--, o = 0;
                            else if (o++ > 3 * a) {
                                if (!e) return window.console.log("PIXI Warning: shape too complex to fill"), [];
                                for (s = [], r = [], o = 0; i > o; o++) r.push(o);
                                o = 0, a = i, e = !1
                            }
                        }
                        return s.push(r[0], r[1], r[2]), s
                    }, n.PolyK._PointInTriangle = function(t, e, i, s, n, r, o, a) {
                        var h = o - i,
                            l = a - s,
                            c = n - i,
                            u = r - s,
                            d = t - i,
                            p = e - s,
                            f = h * h + l * l,
                            g = h * c + l * u,
                            m = h * d + l * p,
                            y = c * c + u * u,
                            v = c * d + u * p,
                            x = 1 / (f * y - g * g),
                            b = (y * m - g * v) * x,
                            _ = (f * v - g * m) * x;
                        return b >= 0 && _ >= 0 && 1 > b + _
                    }, n.PolyK._convex = function(t, e, i, s, n, r, o) {
                        return (e - s) * (n - i) + (i - t) * (r - s) >= 0 === o
                    }, n.initDefaultShaders = function() {}, n.CompileVertexShader = function(t, e) {
                        return n._CompileShader(t, e, t.VERTEX_SHADER)
                    }, n.CompileFragmentShader = function(t, e) {
                        return n._CompileShader(t, e, t.FRAGMENT_SHADER)
                    }, n._CompileShader = function(t, e, i) {
                        var s = e.join("\n"),
                            n = t.createShader(i);
                        return t.shaderSource(n, s), t.compileShader(n), t.getShaderParameter(n, t.COMPILE_STATUS) ? n : (window.console.log(t.getShaderInfoLog(n)), null)
                    }, n.compileProgram = function(t, e, i) {
                        var s = n.CompileFragmentShader(t, i),
                            r = n.CompileVertexShader(t, e),
                            o = t.createProgram();
                        return t.attachShader(o, r), t.attachShader(o, s), t.linkProgram(o), t.getProgramParameter(o, t.LINK_STATUS) || window.console.log("Could not initialise shaders"), o
                    }, n.PixiShader = function(t) {
                        this._UID = n._UID++, this.gl = t, this.program = null, this.fragmentSrc = ["precision lowp float;", "varying vec2 vTextureCoord;", "varying vec4 vColor;", "uniform sampler2D uSampler;", "void main(void) {", "   gl_FragColor = texture2D(uSampler, vTextureCoord) * vColor ;", "}"], this.textureCount = 0, this.attributes = [], this.init()
                    }, n.PixiShader.prototype.init = function() {
                        var t = this.gl,
                            e = n.compileProgram(t, this.vertexSrc || n.PixiShader.defaultVertexSrc, this.fragmentSrc);
                        t.useProgram(e), this.uSampler = t.getUniformLocation(e, "uSampler"), this.projectionVector = t.getUniformLocation(e, "projectionVector"), this.offsetVector = t.getUniformLocation(e, "offsetVector"), this.dimensions = t.getUniformLocation(e, "dimensions"), this.aVertexPosition = t.getAttribLocation(e, "aVertexPosition"), this.aTextureCoord = t.getAttribLocation(e, "aTextureCoord"), this.colorAttribute = t.getAttribLocation(e, "aColor"), -1 === this.colorAttribute && (this.colorAttribute = 2), this.attributes = [this.aVertexPosition, this.aTextureCoord, this.colorAttribute];
                        for (var i in this.uniforms) this.uniforms[i].uniformLocation = t.getUniformLocation(e, i);
                        this.initUniforms(), this.program = e
                    }, n.PixiShader.prototype.initUniforms = function() {
                        this.textureCount = 1;
                        var t, e = this.gl;
                        for (var i in this.uniforms) {
                            t = this.uniforms[i];
                            var s = t.type;
                            "sampler2D" === s ? (t._init = !1, null !== t.value && this.initSampler2D(t)) : "mat2" === s || "mat3" === s || "mat4" === s ? (t.glMatrix = !0, t.glValueLength = 1, "mat2" === s ? t.glFunc = e.uniformMatrix2fv : "mat3" === s ? t.glFunc = e.uniformMatrix3fv : "mat4" === s && (t.glFunc = e.uniformMatrix4fv)) : (t.glFunc = e["uniform" + s], t.glValueLength = "2f" === s || "2i" === s ? 2 : "3f" === s || "3i" === s ? 3 : "4f" === s || "4i" === s ? 4 : 1)
                        }
                    }, n.PixiShader.prototype.initSampler2D = function(t) {
                        if (t.value && t.value.baseTexture && t.value.baseTexture.hasLoaded) {
                            var e = this.gl;
                            if (e.activeTexture(e["TEXTURE" + this.textureCount]), e.bindTexture(e.TEXTURE_2D, t.value.baseTexture._glTextures[e.id]), t.textureData) {
                                var i = t.textureData,
                                    s = i.magFilter ? i.magFilter : e.LINEAR,
                                    n = i.minFilter ? i.minFilter : e.LINEAR,
                                    r = i.wrapS ? i.wrapS : e.CLAMP_TO_EDGE,
                                    o = i.wrapT ? i.wrapT : e.CLAMP_TO_EDGE,
                                    a = i.luminance ? e.LUMINANCE : e.RGBA;
                                if (i.repeat && (r = e.REPEAT, o = e.REPEAT), e.pixelStorei(e.UNPACK_FLIP_Y_WEBGL, !!i.flipY), i.width) {
                                    var h = i.width ? i.width : 512,
                                        l = i.height ? i.height : 2,
                                        c = i.border ? i.border : 0;
                                    e.texImage2D(e.TEXTURE_2D, 0, a, h, l, c, a, e.UNSIGNED_BYTE, null)
                                } else e.texImage2D(e.TEXTURE_2D, 0, a, e.RGBA, e.UNSIGNED_BYTE, t.value.baseTexture.source);
                                e.texParameteri(e.TEXTURE_2D, e.TEXTURE_MAG_FILTER, s), e.texParameteri(e.TEXTURE_2D, e.TEXTURE_MIN_FILTER, n), e.texParameteri(e.TEXTURE_2D, e.TEXTURE_WRAP_S, r), e.texParameteri(e.TEXTURE_2D, e.TEXTURE_WRAP_T, o)
                            }
                            e.uniform1i(t.uniformLocation, this.textureCount), t._init = !0, this.textureCount++
                        }
                    }, n.PixiShader.prototype.syncUniforms = function() {
                        this.textureCount = 1;
                        var t, e = this.gl;
                        for (var i in this.uniforms) t = this.uniforms[i], 1 === t.glValueLength ? t.glMatrix === !0 ? t.glFunc.call(e, t.uniformLocation, t.transpose, t.value) : t.glFunc.call(e, t.uniformLocation, t.value) : 2 === t.glValueLength ? t.glFunc.call(e, t.uniformLocation, t.value.x, t.value.y) : 3 === t.glValueLength ? t.glFunc.call(e, t.uniformLocation, t.value.x, t.value.y, t.value.z) : 4 === t.glValueLength ? t.glFunc.call(e, t.uniformLocation, t.value.x, t.value.y, t.value.z, t.value.w) : "sampler2D" === t.type && (t._init ? (e.activeTexture(e["TEXTURE" + this.textureCount]), e.bindTexture(e.TEXTURE_2D, t.value.baseTexture._glTextures[e.id] || n.createWebGLTexture(t.value.baseTexture, e)), e.uniform1i(t.uniformLocation, this.textureCount), this.textureCount++) : this.initSampler2D(t))
                    }, n.PixiShader.prototype.destroy = function() {
                        this.gl.deleteProgram(this.program), this.uniforms = null, this.gl = null, this.attributes = null
                    }, n.PixiShader.defaultVertexSrc = ["attribute vec2 aVertexPosition;", "attribute vec2 aTextureCoord;", "attribute vec2 aColor;", "uniform vec2 projectionVector;", "uniform vec2 offsetVector;", "varying vec2 vTextureCoord;", "varying vec4 vColor;", "const vec2 center = vec2(-1.0, 1.0);", "void main(void) {", "   gl_Position = vec4( ((aVertexPosition + offsetVector) / projectionVector) + center , 0.0, 1.0);", "   vTextureCoord = aTextureCoord;", "   vec3 color = mod(vec3(aColor.y/65536.0, aColor.y/256.0, aColor.y), 256.0) / 256.0;", "   vColor = vec4(color * aColor.x, aColor.x);", "}"], n.PixiFastShader = function(t) {
                        this._UID = n._UID++, this.gl = t, this.program = null, this.fragmentSrc = ["precision lowp float;", "varying vec2 vTextureCoord;", "varying float vColor;", "uniform sampler2D uSampler;", "void main(void) {", "   gl_FragColor = texture2D(uSampler, vTextureCoord) * vColor ;", "}"], this.vertexSrc = ["attribute vec2 aVertexPosition;", "attribute vec2 aPositionCoord;", "attribute vec2 aScale;", "attribute float aRotation;", "attribute vec2 aTextureCoord;", "attribute float aColor;", "uniform vec2 projectionVector;", "uniform vec2 offsetVector;", "uniform mat3 uMatrix;", "varying vec2 vTextureCoord;", "varying float vColor;", "const vec2 center = vec2(-1.0, 1.0);", "void main(void) {", "   vec2 v;", "   vec2 sv = aVertexPosition * aScale;", "   v.x = (sv.x) * cos(aRotation) - (sv.y) * sin(aRotation);", "   v.y = (sv.x) * sin(aRotation) + (sv.y) * cos(aRotation);", "   v = ( uMatrix * vec3(v + aPositionCoord , 1.0) ).xy ;", "   gl_Position = vec4( ( v / projectionVector) + center , 0.0, 1.0);", "   vTextureCoord = aTextureCoord;", "   vColor = aColor;", "}"], this.textureCount = 0, this.init()
                    }, n.PixiFastShader.prototype.init = function() {
                        var t = this.gl,
                            e = n.compileProgram(t, this.vertexSrc, this.fragmentSrc);
                        t.useProgram(e), this.uSampler = t.getUniformLocation(e, "uSampler"), this.projectionVector = t.getUniformLocation(e, "projectionVector"), this.offsetVector = t.getUniformLocation(e, "offsetVector"), this.dimensions = t.getUniformLocation(e, "dimensions"), this.uMatrix = t.getUniformLocation(e, "uMatrix"), this.aVertexPosition = t.getAttribLocation(e, "aVertexPosition"), this.aPositionCoord = t.getAttribLocation(e, "aPositionCoord"), this.aScale = t.getAttribLocation(e, "aScale"), this.aRotation = t.getAttribLocation(e, "aRotation"), this.aTextureCoord = t.getAttribLocation(e, "aTextureCoord"), this.colorAttribute = t.getAttribLocation(e, "aColor"), -1 === this.colorAttribute && (this.colorAttribute = 2), this.attributes = [this.aVertexPosition, this.aPositionCoord, this.aScale, this.aRotation, this.aTextureCoord, this.colorAttribute], this.program = e
                    }, n.PixiFastShader.prototype.destroy = function() {
                        this.gl.deleteProgram(this.program), this.uniforms = null, this.gl = null, this.attributes = null
                    }, n.StripShader = function(t) {
                        this._UID = n._UID++, this.gl = t, this.program = null, this.fragmentSrc = ["precision mediump float;", "varying vec2 vTextureCoord;", "uniform float alpha;", "uniform sampler2D uSampler;", "void main(void) {", "   gl_FragColor = texture2D(uSampler, vec2(vTextureCoord.x, vTextureCoord.y));", "}"], this.vertexSrc = ["attribute vec2 aVertexPosition;", "attribute vec2 aTextureCoord;", "uniform mat3 translationMatrix;", "uniform vec2 projectionVector;", "uniform vec2 offsetVector;", "varying vec2 vTextureCoord;", "void main(void) {", "   vec3 v = translationMatrix * vec3(aVertexPosition , 1.0);", "   v -= offsetVector.xyx;", "   gl_Position = vec4( v.x / projectionVector.x -1.0, v.y / -projectionVector.y + 1.0 , 0.0, 1.0);", "   vTextureCoord = aTextureCoord;", "}"], this.init()
                    }, n.StripShader.prototype.init = function() {
                        var t = this.gl,
                            e = n.compileProgram(t, this.vertexSrc, this.fragmentSrc);
                        t.useProgram(e), this.uSampler = t.getUniformLocation(e, "uSampler"), this.projectionVector = t.getUniformLocation(e, "projectionVector"), this.offsetVector = t.getUniformLocation(e, "offsetVector"), this.colorAttribute = t.getAttribLocation(e, "aColor"), this.aVertexPosition = t.getAttribLocation(e, "aVertexPosition"), this.aTextureCoord = t.getAttribLocation(e, "aTextureCoord"), this.attributes = [this.aVertexPosition, this.aTextureCoord], this.translationMatrix = t.getUniformLocation(e, "translationMatrix"), this.alpha = t.getUniformLocation(e, "alpha"), this.program = e
                    }, n.PrimitiveShader = function(t) {
                        this._UID = n._UID++, this.gl = t, this.program = null, this.fragmentSrc = ["precision mediump float;", "varying vec4 vColor;", "void main(void) {", "   gl_FragColor = vColor;", "}"], this.vertexSrc = ["attribute vec2 aVertexPosition;", "attribute vec4 aColor;", "uniform mat3 translationMatrix;", "uniform vec2 projectionVector;", "uniform vec2 offsetVector;", "uniform float alpha;", "uniform vec3 tint;", "varying vec4 vColor;", "void main(void) {", "   vec3 v = translationMatrix * vec3(aVertexPosition , 1.0);", "   v -= offsetVector.xyx;", "   gl_Position = vec4( v.x / projectionVector.x -1.0, v.y / -projectionVector.y + 1.0 , 0.0, 1.0);", "   vColor = aColor * vec4(tint * alpha, alpha);", "}"], this.init()
                    }, n.PrimitiveShader.prototype.init = function() {
                        var t = this.gl,
                            e = n.compileProgram(t, this.vertexSrc, this.fragmentSrc);
                        t.useProgram(e), this.projectionVector = t.getUniformLocation(e, "projectionVector"), this.offsetVector = t.getUniformLocation(e, "offsetVector"), this.tintColor = t.getUniformLocation(e, "tint"), this.aVertexPosition = t.getAttribLocation(e, "aVertexPosition"), this.colorAttribute = t.getAttribLocation(e, "aColor"), this.attributes = [this.aVertexPosition, this.colorAttribute], this.translationMatrix = t.getUniformLocation(e, "translationMatrix"), this.alpha = t.getUniformLocation(e, "alpha"), this.program = e
                    }, n.PrimitiveShader.prototype.destroy = function() {
                        this.gl.deleteProgram(this.program), this.uniforms = null, this.gl = null, this.attribute = null
                    }, n.ComplexPrimitiveShader = function(t) {
                        this._UID = n._UID++, this.gl = t, this.program = null, this.fragmentSrc = ["precision mediump float;", "varying vec4 vColor;", "void main(void) {", "   gl_FragColor = vColor;", "}"], this.vertexSrc = ["attribute vec2 aVertexPosition;", "uniform mat3 translationMatrix;", "uniform vec2 projectionVector;", "uniform vec2 offsetVector;", "uniform vec3 tint;", "uniform float alpha;", "uniform vec3 color;", "varying vec4 vColor;", "void main(void) {", "   vec3 v = translationMatrix * vec3(aVertexPosition , 1.0);", "   v -= offsetVector.xyx;", "   gl_Position = vec4( v.x / projectionVector.x -1.0, v.y / -projectionVector.y + 1.0 , 0.0, 1.0);", "   vColor = vec4(color * alpha * tint, alpha);", "}"], this.init()
                    }, n.ComplexPrimitiveShader.prototype.init = function() {
                        var t = this.gl,
                            e = n.compileProgram(t, this.vertexSrc, this.fragmentSrc);
                        t.useProgram(e), this.projectionVector = t.getUniformLocation(e, "projectionVector"), this.offsetVector = t.getUniformLocation(e, "offsetVector"), this.tintColor = t.getUniformLocation(e, "tint"), this.color = t.getUniformLocation(e, "color"), this.aVertexPosition = t.getAttribLocation(e, "aVertexPosition"), this.attributes = [this.aVertexPosition, this.colorAttribute], this.translationMatrix = t.getUniformLocation(e, "translationMatrix"), this.alpha = t.getUniformLocation(e, "alpha"), this.program = e
                    }, n.ComplexPrimitiveShader.prototype.destroy = function() {
                        this.gl.deleteProgram(this.program), this.uniforms = null, this.gl = null, this.attribute = null
                    }, n.WebGLGraphics = function() {}, n.WebGLGraphics.renderGraphics = function(t, e) {
                        var i, s = e.gl,
                            r = e.projection,
                            o = e.offset,
                            a = e.shaderManager.primitiveShader;
                        t.dirty && n.WebGLGraphics.updateGraphics(t, s);
                        for (var h = t._webGL[s.id], l = 0; l < h.data.length; l++) 1 === h.data[l].mode ? (i = h.data[l], e.stencilManager.pushStencil(t, i, e), s.drawElements(s.TRIANGLE_FAN, 4, s.UNSIGNED_SHORT, 2 * (i.indices.length - 4)), e.stencilManager.popStencil(t, i, e), this.last = i.mode) : (i = h.data[l], e.shaderManager.setShader(a), a = e.shaderManager.primitiveShader, s.uniformMatrix3fv(a.translationMatrix, !1, t.worldTransform.toArray(!0)), s.uniform2f(a.projectionVector, r.x, -r.y), s.uniform2f(a.offsetVector, -o.x, -o.y), s.uniform3fv(a.tintColor, n.hex2rgb(t.tint)), s.uniform1f(a.alpha, t.worldAlpha), s.bindBuffer(s.ARRAY_BUFFER, i.buffer), s.vertexAttribPointer(a.aVertexPosition, 2, s.FLOAT, !1, 24, 0), s.vertexAttribPointer(a.colorAttribute, 4, s.FLOAT, !1, 24, 8), s.bindBuffer(s.ELEMENT_ARRAY_BUFFER, i.indexBuffer), s.drawElements(s.TRIANGLE_STRIP, i.indices.length, s.UNSIGNED_SHORT, 0))
                    }, n.WebGLGraphics.updateGraphics = function(t, e) {
                        var i = t._webGL[e.id];
                        i || (i = t._webGL[e.id] = {
                            lastIndex: 0,
                            data: [],
                            gl: e
                        }), t.dirty = !1;
                        var s;
                        if (t.clearDirty) {
                            for (t.clearDirty = !1, s = 0; s < i.data.length; s++) {
                                var r = i.data[s];
                                r.reset(), n.WebGLGraphics.graphicsDataPool.push(r)
                            }
                            i.data = [], i.lastIndex = 0
                        }
                        var o;
                        for (s = i.lastIndex; s < t.graphicsData.length; s++) {
                            var a = t.graphicsData[s];
                            a.type === n.Graphics.POLY ? (a.fill && a.points.length > 6 && (a.points.length > 10 ? (o = n.WebGLGraphics.switchMode(i, 1), n.WebGLGraphics.buildComplexPoly(a, o)) : (o = n.WebGLGraphics.switchMode(i, 0), n.WebGLGraphics.buildPoly(a, o))), a.lineWidth > 0 && (o = n.WebGLGraphics.switchMode(i, 0), n.WebGLGraphics.buildLine(a, o))) : (o = n.WebGLGraphics.switchMode(i, 0), a.type === n.Graphics.RECT ? n.WebGLGraphics.buildRectangle(a, o) : a.type === n.Graphics.CIRC || a.type === n.Graphics.ELIP ? n.WebGLGraphics.buildCircle(a, o) : a.type === n.Graphics.RREC && n.WebGLGraphics.buildRoundedRectangle(a, o)), i.lastIndex++
                        }
                        for (s = 0; s < i.data.length; s++) o = i.data[s], o.dirty && o.upload()
                    }, n.WebGLGraphics.switchMode = function(t, e) {
                        var i;
                        return t.data.length ? (i = t.data[t.data.length - 1], (i.mode !== e || 1 === e) && (i = n.WebGLGraphics.graphicsDataPool.pop() || new n.WebGLGraphicsData(t.gl), i.mode = e, t.data.push(i))) : (i = n.WebGLGraphics.graphicsDataPool.pop() || new n.WebGLGraphicsData(t.gl), i.mode = e, t.data.push(i)), i.dirty = !0, i
                    }, n.WebGLGraphics.buildRectangle = function(t, e) {
                        var i = t.points,
                            s = i[0],
                            r = i[1],
                            o = i[2],
                            a = i[3];
                        if (t.fill) {
                            var h = n.hex2rgb(t.fillColor),
                                l = t.fillAlpha,
                                c = h[0] * l,
                                u = h[1] * l,
                                d = h[2] * l,
                                p = e.points,
                                f = e.indices,
                                g = p.length / 6;
                            p.push(s, r), p.push(c, u, d, l), p.push(s + o, r), p.push(c, u, d, l), p.push(s, r + a), p.push(c, u, d, l), p.push(s + o, r + a), p.push(c, u, d, l), f.push(g, g, g + 1, g + 2, g + 3, g + 3)
                        }
                        if (t.lineWidth) {
                            var m = t.points;
                            t.points = [s, r, s + o, r, s + o, r + a, s, r + a, s, r], n.WebGLGraphics.buildLine(t, e), t.points = m
                        }
                    }, n.WebGLGraphics.buildRoundedRectangle = function(t, e) {
                        var i = t.points,
                            s = i[0],
                            r = i[1],
                            o = i[2],
                            a = i[3],
                            h = i[4],
                            l = [];
                        if (l.push(s, r + h), l = l.concat(n.WebGLGraphics.quadraticBezierCurve(s, r + a - h, s, r + a, s + h, r + a)), l = l.concat(n.WebGLGraphics.quadraticBezierCurve(s + o - h, r + a, s + o, r + a, s + o, r + a - h)), l = l.concat(n.WebGLGraphics.quadraticBezierCurve(s + o, r + h, s + o, r, s + o - h, r)), l = l.concat(n.WebGLGraphics.quadraticBezierCurve(s + h, r, s, r, s, r + h)), t.fill) {
                            var c = n.hex2rgb(t.fillColor),
                                u = t.fillAlpha,
                                d = c[0] * u,
                                p = c[1] * u,
                                f = c[2] * u,
                                g = e.points,
                                m = e.indices,
                                y = g.length / 6,
                                v = n.PolyK.Triangulate(l),
                                x = 0;
                            for (x = 0; x < v.length; x += 3) m.push(v[x] + y), m.push(v[x] + y), m.push(v[x + 1] + y), m.push(v[x + 2] + y), m.push(v[x + 2] + y);
                            for (x = 0; x < l.length; x++) g.push(l[x], l[++x], d, p, f, u)
                        }
                        if (t.lineWidth) {
                            var b = t.points;
                            t.points = l, n.WebGLGraphics.buildLine(t, e), t.points = b
                        }
                    }, n.WebGLGraphics.quadraticBezierCurve = function(t, e, i, s, n, r) {
                        function o(t, e, i) {
                            var s = e - t;
                            return t + s * i
                        }
                        for (var a, h, l, c, u, d, p = 20, f = [], g = 0, m = 0; p >= m; m++) g = m / p, a = o(t, i, g), h = o(e, s, g), l = o(i, n, g), c = o(s, r, g), u = o(a, l, g), d = o(h, c, g), f.push(u, d);
                        return f
                    }, n.WebGLGraphics.buildCircle = function(t, e) {
                        var i = t.points,
                            s = i[0],
                            r = i[1],
                            o = i[2],
                            a = i[3],
                            h = 40,
                            l = 2 * Math.PI / h,
                            c = 0;
                        if (t.fill) {
                            var u = n.hex2rgb(t.fillColor),
                                d = t.fillAlpha,
                                p = u[0] * d,
                                f = u[1] * d,
                                g = u[2] * d,
                                m = e.points,
                                y = e.indices,
                                v = m.length / 6;
                            for (y.push(v), c = 0; h + 1 > c; c++) m.push(s, r, p, f, g, d), m.push(s + Math.sin(l * c) * o, r + Math.cos(l * c) * a, p, f, g, d), y.push(v++, v++);
                            y.push(v - 1)
                        }
                        if (t.lineWidth) {
                            var x = t.points;
                            for (t.points = [], c = 0; h + 1 > c; c++) t.points.push(s + Math.sin(l * c) * o, r + Math.cos(l * c) * a);
                            n.WebGLGraphics.buildLine(t, e), t.points = x
                        }
                    }, n.WebGLGraphics.buildLine = function(t, e) {
                        var i = 0,
                            s = t.points;
                        if (0 !== s.length) {
                            if (t.lineWidth % 2)
                                for (i = 0; i < s.length; i++) s[i] += .5;
                            var r = new n.Point(s[0], s[1]),
                                o = new n.Point(s[s.length - 2], s[s.length - 1]);
                            if (r.x === o.x && r.y === o.y) {
                                s = s.slice(), s.pop(), s.pop(), o = new n.Point(s[s.length - 2], s[s.length - 1]);
                                var a = o.x + .5 * (r.x - o.x),
                                    h = o.y + .5 * (r.y - o.y);
                                s.unshift(a, h), s.push(a, h)
                            }
                            var l, c, u, d, p, f, g, m, y, v, x, b, _, w, P, T, S, C, A, E, M, L, R, B = e.points,
                                O = e.indices,
                                I = s.length / 2,
                                k = s.length,
                                D = B.length / 6,
                                F = t.lineWidth / 2,
                                G = n.hex2rgb(t.lineColor),
                                U = t.lineAlpha,
                                N = G[0] * U,
                                j = G[1] * U,
                                W = G[2] * U;
                            for (u = s[0], d = s[1], p = s[2], f = s[3], y = -(d - f), v = u - p, R = Math.sqrt(y * y + v * v), y /= R, v /= R, y *= F, v *= F, B.push(u - y, d - v, N, j, W, U), B.push(u + y, d + v, N, j, W, U), i = 1; I - 1 > i; i++) u = s[2 * (i - 1)], d = s[2 * (i - 1) + 1], p = s[2 * i], f = s[2 * i + 1], g = s[2 * (i + 1)], m = s[2 * (i + 1) + 1], y = -(d - f), v = u - p, R = Math.sqrt(y * y + v * v), y /= R, v /= R, y *= F, v *= F, x = -(f - m), b = p - g, R = Math.sqrt(x * x + b * b), x /= R, b /= R, x *= F, b *= F, P = -v + d - (-v + f), T = -y + p - (-y + u), S = (-y + u) * (-v + f) - (-y + p) * (-v + d), C = -b + m - (-b + f), A = -x + p - (-x + g), E = (-x + g) * (-b + f) - (-x + p) * (-b + m), M = P * A - C * T, Math.abs(M) < .1 ? (M += 10.1, B.push(p - y, f - v, N, j, W, U), B.push(p + y, f + v, N, j, W, U)) : (l = (T * E - A * S) / M, c = (C * S - P * E) / M, L = (l - p) * (l - p) + (c - f) + (c - f), L > 19600 ? (_ = y - x, w = v - b, R = Math.sqrt(_ * _ + w * w), _ /= R, w /= R, _ *= F, w *= F, B.push(p - _, f - w), B.push(N, j, W, U), B.push(p + _, f + w), B.push(N, j, W, U), B.push(p - _, f - w), B.push(N, j, W, U), k++) : (B.push(l, c), B.push(N, j, W, U), B.push(p - (l - p), f - (c - f)), B.push(N, j, W, U)));
                            for (u = s[2 * (I - 2)], d = s[2 * (I - 2) + 1], p = s[2 * (I - 1)], f = s[2 * (I - 1) + 1], y = -(d - f), v = u - p, R = Math.sqrt(y * y + v * v), y /= R, v /= R, y *= F, v *= F, B.push(p - y, f - v), B.push(N, j, W, U), B.push(p + y, f + v), B.push(N, j, W, U), O.push(D), i = 0; k > i; i++) O.push(D++);
                            O.push(D - 1)
                        }
                    }, n.WebGLGraphics.buildComplexPoly = function(t, e) {
                        var i = t.points.slice();
                        if (!(i.length < 6)) {
                            var s = e.indices;
                            e.points = i, e.alpha = t.fillAlpha, e.color = n.hex2rgb(t.fillColor);
                            for (var r, o, a = 1 / 0, h = -1 / 0, l = 1 / 0, c = -1 / 0, u = 0; u < i.length; u += 2) r = i[u], o = i[u + 1], a = a > r ? r : a, h = r > h ? r : h, l = l > o ? o : l, c = o > c ? o : c;
                            i.push(a, l, h, l, h, c, a, c);
                            var d = i.length / 2;
                            for (u = 0; d > u; u++) s.push(u)
                        }
                    }, n.WebGLGraphics.buildPoly = function(t, e) {
                        var i = t.points;
                        if (!(i.length < 6)) {
                            var s = e.points,
                                r = e.indices,
                                o = i.length / 2,
                                a = n.hex2rgb(t.fillColor),
                                h = t.fillAlpha,
                                l = a[0] * h,
                                c = a[1] * h,
                                u = a[2] * h,
                                d = n.PolyK.Triangulate(i),
                                p = s.length / 6,
                                f = 0;
                            for (f = 0; f < d.length; f += 3) r.push(d[f] + p), r.push(d[f] + p), r.push(d[f + 1] + p), r.push(d[f + 2] + p), r.push(d[f + 2] + p);
                            for (f = 0; o > f; f++) s.push(i[2 * f], i[2 * f + 1], l, c, u, h)
                        }
                    }, n.WebGLGraphics.graphicsDataPool = [], n.WebGLGraphicsData = function(t) {
                        this.gl = t, this.color = [0, 0, 0], this.points = [], this.indices = [], this.lastIndex = 0, this.buffer = t.createBuffer(), this.indexBuffer = t.createBuffer(), this.mode = 1, this.alpha = 1, this.dirty = !0
                    }, n.WebGLGraphicsData.prototype.reset = function() {
                        this.points = [], this.indices = [], this.lastIndex = 0
                    }, n.WebGLGraphicsData.prototype.upload = function() {
                        var t = this.gl;
                        this.glPoints = new Float32Array(this.points), t.bindBuffer(t.ARRAY_BUFFER, this.buffer), t.bufferData(t.ARRAY_BUFFER, this.glPoints, t.STATIC_DRAW), this.glIndicies = new Uint16Array(this.indices), t.bindBuffer(t.ELEMENT_ARRAY_BUFFER, this.indexBuffer), t.bufferData(t.ELEMENT_ARRAY_BUFFER, this.glIndicies, t.STATIC_DRAW), this.dirty = !1
                    }, n.glContexts = [], n.WebGLRenderer = function(t, e, i, s, r, o) {
                        n.defaultRenderer || (n.sayHello("webGL"), n.defaultRenderer = this), this.type = n.WEBGL_RENDERER, this.transparent = !!s, this.preserveDrawingBuffer = o, this.width = t || 800, this.height = e || 600, this.view = i || document.createElement("canvas"), this.view.width = this.width, this.view.height = this.height, this.contextLost = this.handleContextLost.bind(this), this.contextRestoredLost = this.handleContextRestored.bind(this), this.view.addEventListener("webglcontextlost", this.contextLost, !1), this.view.addEventListener("webglcontextrestored", this.contextRestoredLost, !1), this.options = {
                            alpha: this.transparent,
                            antialias: !!r,
                            premultipliedAlpha: !!s,
                            stencil: !0,
                            preserveDrawingBuffer: o
                        };
                        var a = null;
                        if (["experimental-webgl", "webgl"].forEach(function(t) {
                                try {
                                    a = a || this.view.getContext(t, this.options)
                                } catch (e) {}
                            }, this), !a) throw new Error("This browser does not support webGL. Try using the canvas renderer" + this);
                        this.gl = a, this.glContextId = a.id = n.WebGLRenderer.glContextId++, n.glContexts[this.glContextId] = a, n.blendModesWebGL || (n.blendModesWebGL = [], n.blendModesWebGL[n.blendModes.NORMAL] = [a.ONE, a.ONE_MINUS_SRC_ALPHA], n.blendModesWebGL[n.blendModes.ADD] = [a.SRC_ALPHA, a.DST_ALPHA], n.blendModesWebGL[n.blendModes.MULTIPLY] = [a.DST_COLOR, a.ONE_MINUS_SRC_ALPHA], n.blendModesWebGL[n.blendModes.SCREEN] = [a.SRC_ALPHA, a.ONE], n.blendModesWebGL[n.blendModes.OVERLAY] = [a.ONE, a.ONE_MINUS_SRC_ALPHA], n.blendModesWebGL[n.blendModes.DARKEN] = [a.ONE, a.ONE_MINUS_SRC_ALPHA], n.blendModesWebGL[n.blendModes.LIGHTEN] = [a.ONE, a.ONE_MINUS_SRC_ALPHA], n.blendModesWebGL[n.blendModes.COLOR_DODGE] = [a.ONE, a.ONE_MINUS_SRC_ALPHA], n.blendModesWebGL[n.blendModes.COLOR_BURN] = [a.ONE, a.ONE_MINUS_SRC_ALPHA], n.blendModesWebGL[n.blendModes.HARD_LIGHT] = [a.ONE, a.ONE_MINUS_SRC_ALPHA], n.blendModesWebGL[n.blendModes.SOFT_LIGHT] = [a.ONE, a.ONE_MINUS_SRC_ALPHA], n.blendModesWebGL[n.blendModes.DIFFERENCE] = [a.ONE, a.ONE_MINUS_SRC_ALPHA], n.blendModesWebGL[n.blendModes.EXCLUSION] = [a.ONE, a.ONE_MINUS_SRC_ALPHA], n.blendModesWebGL[n.blendModes.HUE] = [a.ONE, a.ONE_MINUS_SRC_ALPHA], n.blendModesWebGL[n.blendModes.SATURATION] = [a.ONE, a.ONE_MINUS_SRC_ALPHA], n.blendModesWebGL[n.blendModes.COLOR] = [a.ONE, a.ONE_MINUS_SRC_ALPHA], n.blendModesWebGL[n.blendModes.LUMINOSITY] = [a.ONE, a.ONE_MINUS_SRC_ALPHA]), this.projection = new n.Point, this.projection.x = this.width / 2, this.projection.y = -this.height / 2, this.offset = new n.Point(0, 0), this.resize(this.width, this.height), this.contextLost = !1, this.shaderManager = new n.WebGLShaderManager(a), this.spriteBatch = new n.WebGLSpriteBatch(a), this.maskManager = new n.WebGLMaskManager(a), this.filterManager = new n.WebGLFilterManager(a, this.transparent), this.stencilManager = new n.WebGLStencilManager(a), this.blendModeManager = new n.WebGLBlendModeManager(a), this.renderSession = {}, this.renderSession.gl = this.gl, this.renderSession.drawCount = 0, this.renderSession.shaderManager = this.shaderManager, this.renderSession.maskManager = this.maskManager, this.renderSession.filterManager = this.filterManager, this.renderSession.blendModeManager = this.blendModeManager, this.renderSession.spriteBatch = this.spriteBatch, this.renderSession.stencilManager = this.stencilManager, this.renderSession.renderer = this, a.useProgram(this.shaderManager.defaultShader.program), a.disable(a.DEPTH_TEST), a.disable(a.CULL_FACE), a.enable(a.BLEND), a.colorMask(!0, !0, !0, this.transparent)
                    }, n.WebGLRenderer.prototype.constructor = n.WebGLRenderer, n.WebGLRenderer.prototype.render = function(t) {
                        if (!this.contextLost) {
                            this.__stage !== t && (t.interactive && t.interactionManager.removeEvents(), this.__stage = t), n.WebGLRenderer.updateTextures(), t.updateTransform(), t._interactive && (t._interactiveEventsAdded || (t._interactiveEventsAdded = !0, t.interactionManager.setTarget(this)));
                            var e = this.gl;
                            e.viewport(0, 0, this.width, this.height), e.bindFramebuffer(e.FRAMEBUFFER, null), this.transparent ? e.clearColor(0, 0, 0, 0) : e.clearColor(t.backgroundColorSplit[0], t.backgroundColorSplit[1], t.backgroundColorSplit[2], 1), e.clear(e.COLOR_BUFFER_BIT), this.renderDisplayObject(t, this.projection), t.interactive ? t._interactiveEventsAdded || (t._interactiveEventsAdded = !0, t.interactionManager.setTarget(this)) : t._interactiveEventsAdded && (t._interactiveEventsAdded = !1, t.interactionManager.setTarget(this))
                        }
                    }, n.WebGLRenderer.prototype.renderDisplayObject = function(t, e, i) {
                        this.renderSession.blendModeManager.setBlendMode(n.blendModes.NORMAL), this.renderSession.drawCount = 0, this.renderSession.currentBlendMode = 9999, this.renderSession.projection = e, this.renderSession.offset = this.offset, this.spriteBatch.begin(this.renderSession), this.filterManager.begin(this.renderSession, i), t._renderWebGL(this.renderSession), this.spriteBatch.end()
                    }, n.WebGLRenderer.updateTextures = function() {
                        var t = 0;
                        for (t = 0; t < n.Texture.frameUpdates.length; t++) n.WebGLRenderer.updateTextureFrame(n.Texture.frameUpdates[t]);
                        for (t = 0; t < n.texturesToDestroy.length; t++) n.WebGLRenderer.destroyTexture(n.texturesToDestroy[t]);
                        n.texturesToUpdate.length = 0, n.texturesToDestroy.length = 0, n.Texture.frameUpdates.length = 0
                    }, n.WebGLRenderer.destroyTexture = function(t) {
                        for (var e = t._glTextures.length - 1; e >= 0; e--) {
                            var i = t._glTextures[e],
                                s = n.glContexts[e];
                            s && i && s.deleteTexture(i)
                        }
                        t._glTextures.length = 0
                    }, n.WebGLRenderer.updateTextureFrame = function(t) {
                        t._updateWebGLuvs()
                    }, n.WebGLRenderer.prototype.resize = function(t, e) {
                        this.width = t, this.height = e, this.view.width = t, this.view.height = e, this.gl.viewport(0, 0, this.width, this.height), this.projection.x = this.width / 2, this.projection.y = -this.height / 2
                    }, n.createWebGLTexture = function(t, e) {
                        return t.hasLoaded && (t._glTextures[e.id] = e.createTexture(), e.bindTexture(e.TEXTURE_2D, t._glTextures[e.id]), e.pixelStorei(e.UNPACK_PREMULTIPLY_ALPHA_WEBGL, t.premultipliedAlpha), e.texImage2D(e.TEXTURE_2D, 0, e.RGBA, e.RGBA, e.UNSIGNED_BYTE, t.source), e.texParameteri(e.TEXTURE_2D, e.TEXTURE_MAG_FILTER, t.scaleMode === n.scaleModes.LINEAR ? e.LINEAR : e.NEAREST), e.texParameteri(e.TEXTURE_2D, e.TEXTURE_MIN_FILTER, t.scaleMode === n.scaleModes.LINEAR ? e.LINEAR : e.NEAREST), t._powerOf2 ? (e.texParameteri(e.TEXTURE_2D, e.TEXTURE_WRAP_S, e.REPEAT), e.texParameteri(e.TEXTURE_2D, e.TEXTURE_WRAP_T, e.REPEAT)) : (e.texParameteri(e.TEXTURE_2D, e.TEXTURE_WRAP_S, e.CLAMP_TO_EDGE), e.texParameteri(e.TEXTURE_2D, e.TEXTURE_WRAP_T, e.CLAMP_TO_EDGE)), e.bindTexture(e.TEXTURE_2D, null), t._dirty[e.id] = !1), t._glTextures[e.id]
                    }, n.updateWebGLTexture = function(t, e) {
                        t._glTextures[e.id] && (e.bindTexture(e.TEXTURE_2D, t._glTextures[e.id]), e.pixelStorei(e.UNPACK_PREMULTIPLY_ALPHA_WEBGL, t.premultipliedAlpha), e.texImage2D(e.TEXTURE_2D, 0, e.RGBA, e.RGBA, e.UNSIGNED_BYTE, t.source), e.texParameteri(e.TEXTURE_2D, e.TEXTURE_MAG_FILTER, t.scaleMode === n.scaleModes.LINEAR ? e.LINEAR : e.NEAREST), e.texParameteri(e.TEXTURE_2D, e.TEXTURE_MIN_FILTER, t.scaleMode === n.scaleModes.LINEAR ? e.LINEAR : e.NEAREST), t._powerOf2 ? (e.texParameteri(e.TEXTURE_2D, e.TEXTURE_WRAP_S, e.REPEAT), e.texParameteri(e.TEXTURE_2D, e.TEXTURE_WRAP_T, e.REPEAT)) : (e.texParameteri(e.TEXTURE_2D, e.TEXTURE_WRAP_S, e.CLAMP_TO_EDGE), e.texParameteri(e.TEXTURE_2D, e.TEXTURE_WRAP_T, e.CLAMP_TO_EDGE)), t._dirty[e.id] = !1)
                    }, n.WebGLRenderer.prototype.handleContextLost = function(t) {
                        t.preventDefault(), this.contextLost = !0
                    }, n.WebGLRenderer.prototype.handleContextRestored = function() {
                        try {
                            this.gl = this.view.getContext("experimental-webgl", this.options)
                        } catch (t) {
                            try {
                                this.gl = this.view.getContext("webgl", this.options)
                            } catch (e) {
                                throw new Error(" This browser does not support webGL. Try using the canvas renderer" + this)
                            }
                        }
                        var i = this.gl;
                        i.id = n.WebGLRenderer.glContextId++, this.shaderManager.setContext(i), this.spriteBatch.setContext(i), this.primitiveBatch.setContext(i), this.maskManager.setContext(i), this.filterManager.setContext(i), this.renderSession.gl = this.gl, i.disable(i.DEPTH_TEST), i.disable(i.CULL_FACE), i.enable(i.BLEND), i.colorMask(!0, !0, !0, this.transparent), this.gl.viewport(0, 0, this.width, this.height);
                        for (var s in n.TextureCache) {
                            var r = n.TextureCache[s].baseTexture;
                            r._glTextures = []
                        }
                        this.contextLost = !1
                    }, n.WebGLRenderer.prototype.destroy = function() {
                        this.view.removeEventListener("webglcontextlost", this.contextLost), this.view.removeEventListener("webglcontextrestored", this.contextRestoredLost), n.glContexts[this.glContextId] = null, this.projection = null, this.offset = null, this.shaderManager.destroy(), this.spriteBatch.destroy(), this.primitiveBatch.destroy(), this.maskManager.destroy(), this.filterManager.destroy(), this.shaderManager = null, this.spriteBatch = null, this.maskManager = null, this.filterManager = null, this.gl = null, this.renderSession = null
                    }, n.WebGLRenderer.glContextId = 0, n.WebGLBlendModeManager = function(t) {
                        this.gl = t, this.currentBlendMode = 99999
                    }, n.WebGLBlendModeManager.prototype.setBlendMode = function(t) {
                        if (this.currentBlendMode === t) return !1;
                        this.currentBlendMode = t;
                        var e = n.blendModesWebGL[this.currentBlendMode];
                        return this.gl.blendFunc(e[0], e[1]), !0
                    }, n.WebGLBlendModeManager.prototype.destroy = function() {
                        this.gl = null
                    }, n.WebGLMaskManager = function(t) {
                        this.maskStack = [], this.maskPosition = 0, this.setContext(t), this.reverse = !1, this.count = 0
                    }, n.WebGLMaskManager.prototype.setContext = function(t) {
                        this.gl = t
                    }, n.WebGLMaskManager.prototype.pushMask = function(t, e) {
                        var i = e.gl;
                        t.dirty && n.WebGLGraphics.updateGraphics(t, i), t._webGL[i.id].data.length && e.stencilManager.pushStencil(t, t._webGL[i.id].data[0], e)
                    }, n.WebGLMaskManager.prototype.popMask = function(t, e) {
                        var i = this.gl;
                        e.stencilManager.popStencil(t, t._webGL[i.id].data[0], e)
                    }, n.WebGLMaskManager.prototype.destroy = function() {
                        this.maskStack = null, this.gl = null
                    }, n.WebGLStencilManager = function(t) {
                        this.stencilStack = [], this.setContext(t), this.reverse = !0, this.count = 0
                    }, n.WebGLStencilManager.prototype.setContext = function(t) {
                        this.gl = t
                    }, n.WebGLStencilManager.prototype.pushStencil = function(t, e, i) {
                        var s = this.gl;
                        this.bindGraphics(t, e, i), 0 === this.stencilStack.length && (s.enable(s.STENCIL_TEST), s.clear(s.STENCIL_BUFFER_BIT), this.reverse = !0, this.count = 0), this.stencilStack.push(e);
                        var n = this.count;
                        s.colorMask(!1, !1, !1, !1), s.stencilFunc(s.ALWAYS, 0, 255), s.stencilOp(s.KEEP, s.KEEP, s.INVERT), 1 === e.mode ? (s.drawElements(s.TRIANGLE_FAN, e.indices.length - 4, s.UNSIGNED_SHORT, 0), this.reverse ? (s.stencilFunc(s.EQUAL, 255 - n, 255), s.stencilOp(s.KEEP, s.KEEP, s.DECR)) : (s.stencilFunc(s.EQUAL, n, 255), s.stencilOp(s.KEEP, s.KEEP, s.INCR)), s.drawElements(s.TRIANGLE_FAN, 4, s.UNSIGNED_SHORT, 2 * (e.indices.length - 4)), this.reverse ? s.stencilFunc(s.EQUAL, 255 - (n + 1), 255) : s.stencilFunc(s.EQUAL, n + 1, 255), this.reverse = !this.reverse) : (this.reverse ? (s.stencilFunc(s.EQUAL, n, 255), s.stencilOp(s.KEEP, s.KEEP, s.INCR)) : (s.stencilFunc(s.EQUAL, 255 - n, 255), s.stencilOp(s.KEEP, s.KEEP, s.DECR)), s.drawElements(s.TRIANGLE_STRIP, e.indices.length, s.UNSIGNED_SHORT, 0), this.reverse ? s.stencilFunc(s.EQUAL, n + 1, 255) : s.stencilFunc(s.EQUAL, 255 - (n + 1), 255)), s.colorMask(!0, !0, !0, !0), s.stencilOp(s.KEEP, s.KEEP, s.KEEP), this.count++
                    }, n.WebGLStencilManager.prototype.bindGraphics = function(t, e, i) {
                        this._currentGraphics = t;
                        var s, r = this.gl,
                            o = i.projection,
                            a = i.offset;
                        1 === e.mode ? (s = i.shaderManager.complexPrimativeShader, i.shaderManager.setShader(s), r.uniformMatrix3fv(s.translationMatrix, !1, t.worldTransform.toArray(!0)), r.uniform2f(s.projectionVector, o.x, -o.y), r.uniform2f(s.offsetVector, -a.x, -a.y), r.uniform3fv(s.tintColor, n.hex2rgb(t.tint)), r.uniform3fv(s.color, e.color), r.uniform1f(s.alpha, t.worldAlpha * e.alpha), r.bindBuffer(r.ARRAY_BUFFER, e.buffer), r.vertexAttribPointer(s.aVertexPosition, 2, r.FLOAT, !1, 8, 0), r.bindBuffer(r.ELEMENT_ARRAY_BUFFER, e.indexBuffer)) : (s = i.shaderManager.primitiveShader, i.shaderManager.setShader(s), r.uniformMatrix3fv(s.translationMatrix, !1, t.worldTransform.toArray(!0)), r.uniform2f(s.projectionVector, o.x, -o.y), r.uniform2f(s.offsetVector, -a.x, -a.y), r.uniform3fv(s.tintColor, n.hex2rgb(t.tint)), r.uniform1f(s.alpha, t.worldAlpha), r.bindBuffer(r.ARRAY_BUFFER, e.buffer), r.vertexAttribPointer(s.aVertexPosition, 2, r.FLOAT, !1, 24, 0), r.vertexAttribPointer(s.colorAttribute, 4, r.FLOAT, !1, 24, 8), r.bindBuffer(r.ELEMENT_ARRAY_BUFFER, e.indexBuffer))
                    }, n.WebGLStencilManager.prototype.popStencil = function(t, e, i) {
                        var s = this.gl;
                        if (this.stencilStack.pop(), this.count--, 0 === this.stencilStack.length) s.disable(s.STENCIL_TEST);
                        else {
                            var n = this.count;
                            this.bindGraphics(t, e, i), s.colorMask(!1, !1, !1, !1), 1 === e.mode ? (this.reverse = !this.reverse, this.reverse ? (s.stencilFunc(s.EQUAL, 255 - (n + 1), 255), s.stencilOp(s.KEEP, s.KEEP, s.INCR)) : (s.stencilFunc(s.EQUAL, n + 1, 255), s.stencilOp(s.KEEP, s.KEEP, s.DECR)), s.drawElements(s.TRIANGLE_FAN, 4, s.UNSIGNED_SHORT, 2 * (e.indices.length - 4)), s.stencilFunc(s.ALWAYS, 0, 255), s.stencilOp(s.KEEP, s.KEEP, s.INVERT), s.drawElements(s.TRIANGLE_FAN, e.indices.length - 4, s.UNSIGNED_SHORT, 0), this.reverse ? s.stencilFunc(s.EQUAL, n, 255) : s.stencilFunc(s.EQUAL, 255 - n, 255)) : (this.reverse ? (s.stencilFunc(s.EQUAL, n + 1, 255), s.stencilOp(s.KEEP, s.KEEP, s.DECR)) : (s.stencilFunc(s.EQUAL, 255 - (n + 1), 255), s.stencilOp(s.KEEP, s.KEEP, s.INCR)), s.drawElements(s.TRIANGLE_STRIP, e.indices.length, s.UNSIGNED_SHORT, 0), this.reverse ? s.stencilFunc(s.EQUAL, n, 255) : s.stencilFunc(s.EQUAL, 255 - n, 255)), s.colorMask(!0, !0, !0, !0), s.stencilOp(s.KEEP, s.KEEP, s.KEEP)
                        }
                    }, n.WebGLStencilManager.prototype.destroy = function() {
                        this.maskStack = null, this.gl = null
                    }, n.WebGLShaderManager = function(t) {
                        this.maxAttibs = 10, this.attribState = [], this.tempAttribState = [], this.shaderMap = [];
                        for (var e = 0; e < this.maxAttibs; e++) this.attribState[e] = !1;
                        this.setContext(t)
                    }, n.WebGLShaderManager.prototype.setContext = function(t) {
                        this.gl = t, this.primitiveShader = new n.PrimitiveShader(t), this.complexPrimativeShader = new n.ComplexPrimitiveShader(t), this.defaultShader = new n.PixiShader(t), this.fastShader = new n.PixiFastShader(t), this.stripShader = new n.StripShader(t), this.setShader(this.defaultShader)
                    }, n.WebGLShaderManager.prototype.setAttribs = function(t) {
                        var e;
                        for (e = 0; e < this.tempAttribState.length; e++) this.tempAttribState[e] = !1;
                        for (e = 0; e < t.length; e++) {
                            var i = t[e];
                            this.tempAttribState[i] = !0
                        }
                        var s = this.gl;
                        for (e = 0; e < this.attribState.length; e++) this.attribState[e] !== this.tempAttribState[e] && (this.attribState[e] = this.tempAttribState[e], this.tempAttribState[e] ? s.enableVertexAttribArray(e) : s.disableVertexAttribArray(e))
                    }, n.WebGLShaderManager.prototype.setShader = function(t) {
                        return this._currentId === t._UID ? !1 : (this._currentId = t._UID, this.currentShader = t, this.gl.useProgram(t.program), this.setAttribs(t.attributes), !0)
                    }, n.WebGLShaderManager.prototype.destroy = function() {
                        this.attribState = null, this.tempAttribState = null, this.primitiveShader.destroy(), this.defaultShader.destroy(), this.fastShader.destroy(), this.stripShader.destroy(), this.gl = null
                    }, n.WebGLSpriteBatch = function(t) {
                        this.vertSize = 6, this.size = 2e3;
                        var e = 4 * this.size * this.vertSize,
                            i = 6 * this.size;
                        this.vertices = new Float32Array(e), this.indices = new Uint16Array(i), this.lastIndexCount = 0;
                        for (var s = 0, n = 0; i > s; s += 6, n += 4) this.indices[s + 0] = n + 0, this.indices[s + 1] = n + 1, this.indices[s + 2] = n + 2, this.indices[s + 3] = n + 0, this.indices[s + 4] = n + 2, this.indices[s + 5] = n + 3;
                        this.drawing = !1, this.currentBatchSize = 0, this.currentBaseTexture = null, this.setContext(t), this.dirty = !0, this.textures = [], this.blendModes = []
                    }, n.WebGLSpriteBatch.prototype.setContext = function(t) {
                        this.gl = t, this.vertexBuffer = t.createBuffer(), this.indexBuffer = t.createBuffer(), t.bindBuffer(t.ELEMENT_ARRAY_BUFFER, this.indexBuffer), t.bufferData(t.ELEMENT_ARRAY_BUFFER, this.indices, t.STATIC_DRAW), t.bindBuffer(t.ARRAY_BUFFER, this.vertexBuffer), t.bufferData(t.ARRAY_BUFFER, this.vertices, t.DYNAMIC_DRAW), this.currentBlendMode = 99999
                    }, n.WebGLSpriteBatch.prototype.begin = function(t) {
                        this.renderSession = t, this.shader = this.renderSession.shaderManager.defaultShader, this.start()
                    }, n.WebGLSpriteBatch.prototype.end = function() {
                        this.flush()
                    }, n.WebGLSpriteBatch.prototype.render = function(t) {
                        var e = t.texture;
                        this.currentBatchSize >= this.size && (this.flush(), this.currentBaseTexture = e.baseTexture);
                        var i = e._uvs;
                        if (i) {
                            var s, n, r, o, a = t.worldAlpha,
                                h = t.tint,
                                l = this.vertices,
                                c = t.anchor.x,
                                u = t.anchor.y;
                            if (e.trim) {
                                var d = e.trim;
                                n = d.x - c * d.width, s = n + e.crop.width, o = d.y - u * d.height, r = o + e.crop.height
                            } else s = e.frame.width * (1 - c), n = e.frame.width * -c, r = e.frame.height * (1 - u), o = e.frame.height * -u;
                            var p = 4 * this.currentBatchSize * this.vertSize,
                                f = t.worldTransform,
                                g = f.a,
                                m = f.c,
                                y = f.b,
                                v = f.d,
                                x = f.tx,
                                b = f.ty;
                            l[p++] = g * n + y * o + x, l[p++] = v * o + m * n + b, l[p++] = i.x0, l[p++] = i.y0, l[p++] = a, l[p++] = h, l[p++] = g * s + y * o + x, l[p++] = v * o + m * s + b, l[p++] = i.x1, l[p++] = i.y1, l[p++] = a, l[p++] = h, l[p++] = g * s + y * r + x, l[p++] = v * r + m * s + b, l[p++] = i.x2, l[p++] = i.y2, l[p++] = a, l[p++] = h, l[p++] = g * n + y * r + x, l[p++] = v * r + m * n + b, l[p++] = i.x3, l[p++] = i.y3, l[p++] = a, l[p++] = h, this.textures[this.currentBatchSize] = t.texture.baseTexture, this.blendModes[this.currentBatchSize] = t.blendMode, this.currentBatchSize++
                        }
                    }, n.WebGLSpriteBatch.prototype.renderTilingSprite = function(t) {
                        var e = t.tilingTexture;
                        this.currentBatchSize >= this.size && (this.flush(), this.currentBaseTexture = e.baseTexture), t._uvs || (t._uvs = new n.TextureUvs);
                        var i = t._uvs;
                        t.tilePosition.x %= e.baseTexture.width * t.tileScaleOffset.x, t.tilePosition.y %= e.baseTexture.height * t.tileScaleOffset.y;
                        var s = t.tilePosition.x / (e.baseTexture.width * t.tileScaleOffset.x),
                            r = t.tilePosition.y / (e.baseTexture.height * t.tileScaleOffset.y),
                            o = t.width / e.baseTexture.width / (t.tileScale.x * t.tileScaleOffset.x),
                            a = t.height / e.baseTexture.height / (t.tileScale.y * t.tileScaleOffset.y);
                        i.x0 = 0 - s, i.y0 = 0 - r, i.x1 = 1 * o - s, i.y1 = 0 - r, i.x2 = 1 * o - s, i.y2 = 1 * a - r, i.x3 = 0 - s, i.y3 = 1 * a - r;
                        var h = t.worldAlpha,
                            l = t.tint,
                            c = this.vertices,
                            u = t.width,
                            d = t.height,
                            p = t.anchor.x,
                            f = t.anchor.y,
                            g = u * (1 - p),
                            m = u * -p,
                            y = d * (1 - f),
                            v = d * -f,
                            x = 4 * this.currentBatchSize * this.vertSize,
                            b = t.worldTransform,
                            _ = b.a,
                            w = b.c,
                            P = b.b,
                            T = b.d,
                            S = b.tx,
                            C = b.ty;
                        c[x++] = _ * m + P * v + S, c[x++] = T * v + w * m + C, c[x++] = i.x0, c[x++] = i.y0, c[x++] = h, c[x++] = l, c[x++] = _ * g + P * v + S, c[x++] = T * v + w * g + C, c[x++] = i.x1, c[x++] = i.y1, c[x++] = h, c[x++] = l, c[x++] = _ * g + P * y + S, c[x++] = T * y + w * g + C, c[x++] = i.x2, c[x++] = i.y2, c[x++] = h, c[x++] = l, c[x++] = _ * m + P * y + S, c[x++] = T * y + w * m + C, c[x++] = i.x3, c[x++] = i.y3, c[x++] = h, c[x++] = l, this.textures[this.currentBatchSize] = e.baseTexture, this.blendModes[this.currentBatchSize] = t.blendMode, this.currentBatchSize++
                    }, n.WebGLSpriteBatch.prototype.flush = function() {
                        if (0 !== this.currentBatchSize) {
                            var t = this.gl;
                            if (this.renderSession.shaderManager.setShader(this.renderSession.shaderManager.defaultShader), this.dirty) {
                                this.dirty = !1, t.activeTexture(t.TEXTURE0), t.bindBuffer(t.ARRAY_BUFFER, this.vertexBuffer), t.bindBuffer(t.ELEMENT_ARRAY_BUFFER, this.indexBuffer);
                                var e = this.renderSession.projection;
                                t.uniform2f(this.shader.projectionVector, e.x, e.y);
                                var i = 4 * this.vertSize;
                                t.vertexAttribPointer(this.shader.aVertexPosition, 2, t.FLOAT, !1, i, 0), t.vertexAttribPointer(this.shader.aTextureCoord, 2, t.FLOAT, !1, i, 8), t.vertexAttribPointer(this.shader.colorAttribute, 2, t.FLOAT, !1, i, 16)
                            }
                            if (this.currentBatchSize > .5 * this.size) t.bufferSubData(t.ARRAY_BUFFER, 0, this.vertices);
                            else {
                                var s = this.vertices.subarray(0, 4 * this.currentBatchSize * this.vertSize);
                                t.bufferSubData(t.ARRAY_BUFFER, 0, s)
                            }
                            for (var n, r, o = 0, a = 0, h = null, l = this.renderSession.blendModeManager.currentBlendMode, c = 0, u = this.currentBatchSize; u > c; c++) n = this.textures[c], r = this.blendModes[c], (h !== n || l !== r) && (this.renderBatch(h, o, a), a = c, o = 0, h = n, l = r, this.renderSession.blendModeManager.setBlendMode(l)), o++;
                            this.renderBatch(h, o, a), this.currentBatchSize = 0
                        }
                    }, n.WebGLSpriteBatch.prototype.renderBatch = function(t, e, i) {
                        if (0 !== e) {
                            var s = this.gl;
                            s.bindTexture(s.TEXTURE_2D, t._glTextures[s.id] || n.createWebGLTexture(t, s)), t._dirty[s.id] && n.updateWebGLTexture(this.currentBaseTexture, s), s.drawElements(s.TRIANGLES, 6 * e, s.UNSIGNED_SHORT, 6 * i * 2), this.renderSession.drawCount++
                        }
                    }, n.WebGLSpriteBatch.prototype.stop = function() {
                        this.flush()
                    }, n.WebGLSpriteBatch.prototype.start = function() {
                        this.dirty = !0
                    }, n.WebGLSpriteBatch.prototype.destroy = function() {
                        this.vertices = null, this.indices = null, this.gl.deleteBuffer(this.vertexBuffer), this.gl.deleteBuffer(this.indexBuffer), this.currentBaseTexture = null, this.gl = null
                    }, n.WebGLFastSpriteBatch = function(t) {
                        this.vertSize = 10, this.maxSize = 6e3, this.size = this.maxSize;
                        var e = 4 * this.size * this.vertSize,
                            i = 6 * this.maxSize;
                        this.vertices = new Float32Array(e), this.indices = new Uint16Array(i), this.vertexBuffer = null, this.indexBuffer = null, this.lastIndexCount = 0;
                        for (var s = 0, n = 0; i > s; s += 6, n += 4) this.indices[s + 0] = n + 0, this.indices[s + 1] = n + 1, this.indices[s + 2] = n + 2, this.indices[s + 3] = n + 0, this.indices[s + 4] = n + 2, this.indices[s + 5] = n + 3;
                        this.drawing = !1, this.currentBatchSize = 0, this.currentBaseTexture = null, this.currentBlendMode = 0, this.renderSession = null, this.shader = null, this.matrix = null, this.setContext(t)
                    }, n.WebGLFastSpriteBatch.prototype.setContext = function(t) {
                        this.gl = t, this.vertexBuffer = t.createBuffer(), this.indexBuffer = t.createBuffer(), t.bindBuffer(t.ELEMENT_ARRAY_BUFFER, this.indexBuffer), t.bufferData(t.ELEMENT_ARRAY_BUFFER, this.indices, t.STATIC_DRAW), t.bindBuffer(t.ARRAY_BUFFER, this.vertexBuffer), t.bufferData(t.ARRAY_BUFFER, this.vertices, t.DYNAMIC_DRAW)
                    }, n.WebGLFastSpriteBatch.prototype.begin = function(t, e) {
                        this.renderSession = e, this.shader = this.renderSession.shaderManager.fastShader, this.matrix = t.worldTransform.toArray(!0), this.start()
                    }, n.WebGLFastSpriteBatch.prototype.end = function() {
                        this.flush()
                    }, n.WebGLFastSpriteBatch.prototype.render = function(t) {
                        var e = t.children,
                            i = e[0];
                        if (i.texture._uvs) {
                            this.currentBaseTexture = i.texture.baseTexture, i.blendMode !== this.renderSession.blendModeManager.currentBlendMode && (this.flush(), this.renderSession.blendModeManager.setBlendMode(i.blendMode));
                            for (var s = 0, n = e.length; n > s; s++) this.renderSprite(e[s]);
                            this.flush()
                        }
                    }, n.WebGLFastSpriteBatch.prototype.renderSprite = function(t) {
                        if (t.visible && (t.texture.baseTexture === this.currentBaseTexture || (this.flush(), this.currentBaseTexture = t.texture.baseTexture, t.texture._uvs))) {
                            var e, i, s, n, r, o, a, h, l = this.vertices;
                            if (e = t.texture._uvs, i = t.texture.frame.width, s = t.texture.frame.height, t.texture.trim) {
                                var c = t.texture.trim;
                                r = c.x - t.anchor.x * c.width, n = r + t.texture.crop.width, a = c.y - t.anchor.y * c.height, o = a + t.texture.crop.height
                            } else n = t.texture.frame.width * (1 - t.anchor.x), r = t.texture.frame.width * -t.anchor.x, o = t.texture.frame.height * (1 - t.anchor.y), a = t.texture.frame.height * -t.anchor.y;
                            h = 4 * this.currentBatchSize * this.vertSize, l[h++] = r, l[h++] = a, l[h++] = t.position.x, l[h++] = t.position.y, l[h++] = t.scale.x, l[h++] = t.scale.y, l[h++] = t.rotation, l[h++] = e.x0, l[h++] = e.y1, l[h++] = t.alpha, l[h++] = n, l[h++] = a, l[h++] = t.position.x, l[h++] = t.position.y, l[h++] = t.scale.x, l[h++] = t.scale.y, l[h++] = t.rotation, l[h++] = e.x1, l[h++] = e.y1, l[h++] = t.alpha, l[h++] = n, l[h++] = o, l[h++] = t.position.x, l[h++] = t.position.y, l[h++] = t.scale.x, l[h++] = t.scale.y, l[h++] = t.rotation, l[h++] = e.x2, l[h++] = e.y2, l[h++] = t.alpha, l[h++] = r, l[h++] = o, l[h++] = t.position.x, l[h++] = t.position.y, l[h++] = t.scale.x, l[h++] = t.scale.y, l[h++] = t.rotation, l[h++] = e.x3, l[h++] = e.y3, l[h++] = t.alpha, this.currentBatchSize++, this.currentBatchSize >= this.size && this.flush()
                        }
                    }, n.WebGLFastSpriteBatch.prototype.flush = function() {
                        if (0 !== this.currentBatchSize) {
                            var t = this.gl;
                            if (this.currentBaseTexture._glTextures[t.id] || n.createWebGLTexture(this.currentBaseTexture, t), t.bindTexture(t.TEXTURE_2D, this.currentBaseTexture._glTextures[t.id]), this.currentBatchSize > .5 * this.size) t.bufferSubData(t.ARRAY_BUFFER, 0, this.vertices);
                            else {
                                var e = this.vertices.subarray(0, 4 * this.currentBatchSize * this.vertSize);
                                t.bufferSubData(t.ARRAY_BUFFER, 0, e)
                            }
                            t.drawElements(t.TRIANGLES, 6 * this.currentBatchSize, t.UNSIGNED_SHORT, 0), this.currentBatchSize = 0, this.renderSession.drawCount++
                        }
                    }, n.WebGLFastSpriteBatch.prototype.stop = function() {
                        this.flush()
                    }, n.WebGLFastSpriteBatch.prototype.start = function() {
                        var t = this.gl;
                        t.activeTexture(t.TEXTURE0), t.bindBuffer(t.ARRAY_BUFFER, this.vertexBuffer), t.bindBuffer(t.ELEMENT_ARRAY_BUFFER, this.indexBuffer);
                        var e = this.renderSession.projection;
                        t.uniform2f(this.shader.projectionVector, e.x, e.y), t.uniformMatrix3fv(this.shader.uMatrix, !1, this.matrix);
                        var i = 4 * this.vertSize;
                        t.vertexAttribPointer(this.shader.aVertexPosition, 2, t.FLOAT, !1, i, 0), t.vertexAttribPointer(this.shader.aPositionCoord, 2, t.FLOAT, !1, i, 8), t.vertexAttribPointer(this.shader.aScale, 2, t.FLOAT, !1, i, 16), t.vertexAttribPointer(this.shader.aRotation, 1, t.FLOAT, !1, i, 24), t.vertexAttribPointer(this.shader.aTextureCoord, 2, t.FLOAT, !1, i, 28), t.vertexAttribPointer(this.shader.colorAttribute, 1, t.FLOAT, !1, i, 36)
                    }, n.WebGLFilterManager = function(t, e) {
                        this.transparent = e, this.filterStack = [], this.offsetX = 0, this.offsetY = 0, this.setContext(t)
                    }, n.WebGLFilterManager.prototype.setContext = function(t) {
                        this.gl = t, this.texturePool = [], this.initShaderBuffers()
                    }, n.WebGLFilterManager.prototype.begin = function(t, e) {
                        this.renderSession = t, this.defaultShader = t.shaderManager.defaultShader;
                        var i = this.renderSession.projection;
                        this.width = 2 * i.x, this.height = 2 * -i.y, this.buffer = e
                    }, n.WebGLFilterManager.prototype.pushFilter = function(t) {
                        var e = this.gl,
                            i = this.renderSession.projection,
                            s = this.renderSession.offset;
                        t._filterArea = t.target.filterArea || t.target.getBounds(), this.filterStack.push(t);
                        var r = t.filterPasses[0];
                        this.offsetX += t._filterArea.x, this.offsetY += t._filterArea.y;
                        var o = this.texturePool.pop();
                        o ? o.resize(this.width, this.height) : o = new n.FilterTexture(this.gl, this.width, this.height), e.bindTexture(e.TEXTURE_2D, o.texture);
                        var a = t._filterArea,
                            h = r.padding;
                        a.x -= h, a.y -= h, a.width += 2 * h, a.height += 2 * h, a.x < 0 && (a.x = 0), a.width > this.width && (a.width = this.width), a.y < 0 && (a.y = 0), a.height > this.height && (a.height = this.height), e.bindFramebuffer(e.FRAMEBUFFER, o.frameBuffer), e.viewport(0, 0, a.width, a.height), i.x = a.width / 2, i.y = -a.height / 2, s.x = -a.x, s.y = -a.y, this.renderSession.shaderManager.setShader(this.defaultShader), e.uniform2f(this.defaultShader.projectionVector, a.width / 2, -a.height / 2), e.uniform2f(this.defaultShader.offsetVector, -a.x, -a.y), e.colorMask(!0, !0, !0, !0), e.clearColor(0, 0, 0, 0), e.clear(e.COLOR_BUFFER_BIT), t._glFilterTexture = o
                    }, n.WebGLFilterManager.prototype.popFilter = function() {
                        var t = this.gl,
                            e = this.filterStack.pop(),
                            i = e._filterArea,
                            s = e._glFilterTexture,
                            r = this.renderSession.projection,
                            o = this.renderSession.offset;
                        if (e.filterPasses.length > 1) {
                            t.viewport(0, 0, i.width, i.height), t.bindBuffer(t.ARRAY_BUFFER, this.vertexBuffer), this.vertexArray[0] = 0, this.vertexArray[1] = i.height, this.vertexArray[2] = i.width, this.vertexArray[3] = i.height, this.vertexArray[4] = 0, this.vertexArray[5] = 0, this.vertexArray[6] = i.width, this.vertexArray[7] = 0, t.bufferSubData(t.ARRAY_BUFFER, 0, this.vertexArray), t.bindBuffer(t.ARRAY_BUFFER, this.uvBuffer), this.uvArray[2] = i.width / this.width, this.uvArray[5] = i.height / this.height, this.uvArray[6] = i.width / this.width, this.uvArray[7] = i.height / this.height, t.bufferSubData(t.ARRAY_BUFFER, 0, this.uvArray);
                            var a = s,
                                h = this.texturePool.pop();
                            h || (h = new n.FilterTexture(this.gl, this.width, this.height)), h.resize(this.width, this.height), t.bindFramebuffer(t.FRAMEBUFFER, h.frameBuffer), t.clear(t.COLOR_BUFFER_BIT), t.disable(t.BLEND);
                            for (var l = 0; l < e.filterPasses.length - 1; l++) {
                                var c = e.filterPasses[l];
                                t.bindFramebuffer(t.FRAMEBUFFER, h.frameBuffer), t.activeTexture(t.TEXTURE0), t.bindTexture(t.TEXTURE_2D, a.texture), this.applyFilterPass(c, i, i.width, i.height);
                                var u = a;
                                a = h, h = u
                            }
                            t.enable(t.BLEND), s = a, this.texturePool.push(h)
                        }
                        var d = e.filterPasses[e.filterPasses.length - 1];
                        this.offsetX -= i.x, this.offsetY -= i.y;
                        var p = this.width,
                            f = this.height,
                            g = 0,
                            m = 0,
                            y = this.buffer;
                        if (0 === this.filterStack.length) t.colorMask(!0, !0, !0, !0);
                        else {
                            var v = this.filterStack[this.filterStack.length - 1];
                            i = v._filterArea, p = i.width, f = i.height, g = i.x, m = i.y, y = v._glFilterTexture.frameBuffer
                        }
                        r.x = p / 2, r.y = -f / 2, o.x = g, o.y = m, i = e._filterArea;
                        var x = i.x - g,
                            b = i.y - m;
                        t.bindBuffer(t.ARRAY_BUFFER, this.vertexBuffer), this.vertexArray[0] = x, this.vertexArray[1] = b + i.height, this.vertexArray[2] = x + i.width, this.vertexArray[3] = b + i.height, this.vertexArray[4] = x, this.vertexArray[5] = b, this.vertexArray[6] = x + i.width, this.vertexArray[7] = b, t.bufferSubData(t.ARRAY_BUFFER, 0, this.vertexArray), t.bindBuffer(t.ARRAY_BUFFER, this.uvBuffer), this.uvArray[2] = i.width / this.width, this.uvArray[5] = i.height / this.height, this.uvArray[6] = i.width / this.width, this.uvArray[7] = i.height / this.height, t.bufferSubData(t.ARRAY_BUFFER, 0, this.uvArray), t.viewport(0, 0, p, f), t.bindFramebuffer(t.FRAMEBUFFER, y), t.activeTexture(t.TEXTURE0), t.bindTexture(t.TEXTURE_2D, s.texture), this.applyFilterPass(d, i, p, f), this.renderSession.shaderManager.setShader(this.defaultShader), t.uniform2f(this.defaultShader.projectionVector, p / 2, -f / 2), t.uniform2f(this.defaultShader.offsetVector, -g, -m), this.texturePool.push(s), e._glFilterTexture = null
                    }, n.WebGLFilterManager.prototype.applyFilterPass = function(t, e, i, s) {
                        var r = this.gl,
                            o = t.shaders[r.id];
                        o || (o = new n.PixiShader(r), o.fragmentSrc = t.fragmentSrc, o.uniforms = t.uniforms, o.init(), t.shaders[r.id] = o), this.renderSession.shaderManager.setShader(o), r.uniform2f(o.projectionVector, i / 2, -s / 2), r.uniform2f(o.offsetVector, 0, 0), t.uniforms.dimensions && (t.uniforms.dimensions.value[0] = this.width, t.uniforms.dimensions.value[1] = this.height, t.uniforms.dimensions.value[2] = this.vertexArray[0], t.uniforms.dimensions.value[3] = this.vertexArray[5]), o.syncUniforms(), r.bindBuffer(r.ARRAY_BUFFER, this.vertexBuffer), r.vertexAttribPointer(o.aVertexPosition, 2, r.FLOAT, !1, 0, 0), r.bindBuffer(r.ARRAY_BUFFER, this.uvBuffer), r.vertexAttribPointer(o.aTextureCoord, 2, r.FLOAT, !1, 0, 0), r.bindBuffer(r.ARRAY_BUFFER, this.colorBuffer), r.vertexAttribPointer(o.colorAttribute, 2, r.FLOAT, !1, 0, 0), r.bindBuffer(r.ELEMENT_ARRAY_BUFFER, this.indexBuffer), r.drawElements(r.TRIANGLES, 6, r.UNSIGNED_SHORT, 0), this.renderSession.drawCount++
                    }, n.WebGLFilterManager.prototype.initShaderBuffers = function() {
                        var t = this.gl;
                        this.vertexBuffer = t.createBuffer(), this.uvBuffer = t.createBuffer(), this.colorBuffer = t.createBuffer(), this.indexBuffer = t.createBuffer(), this.vertexArray = new Float32Array([0, 0, 1, 0, 0, 1, 1, 1]), t.bindBuffer(t.ARRAY_BUFFER, this.vertexBuffer), t.bufferData(t.ARRAY_BUFFER, this.vertexArray, t.STATIC_DRAW), this.uvArray = new Float32Array([0, 0, 1, 0, 0, 1, 1, 1]), t.bindBuffer(t.ARRAY_BUFFER, this.uvBuffer), t.bufferData(t.ARRAY_BUFFER, this.uvArray, t.STATIC_DRAW), this.colorArray = new Float32Array([1, 16777215, 1, 16777215, 1, 16777215, 1, 16777215]), t.bindBuffer(t.ARRAY_BUFFER, this.colorBuffer), t.bufferData(t.ARRAY_BUFFER, this.colorArray, t.STATIC_DRAW), t.bindBuffer(t.ELEMENT_ARRAY_BUFFER, this.indexBuffer), t.bufferData(t.ELEMENT_ARRAY_BUFFER, new Uint16Array([0, 1, 2, 1, 3, 2]), t.STATIC_DRAW)
                    }, n.WebGLFilterManager.prototype.destroy = function() {
                        var t = this.gl;
                        this.filterStack = null, this.offsetX = 0, this.offsetY = 0;
                        for (var e = 0; e < this.texturePool.length; e++) this.texturePool[e].destroy();
                        this.texturePool = null, t.deleteBuffer(this.vertexBuffer), t.deleteBuffer(this.uvBuffer), t.deleteBuffer(this.colorBuffer), t.deleteBuffer(this.indexBuffer)
                    }, n.FilterTexture = function(t, e, i, s) {
                        this.gl = t, this.frameBuffer = t.createFramebuffer(), this.texture = t.createTexture(), s = s || n.scaleModes.DEFAULT, t.bindTexture(t.TEXTURE_2D, this.texture), t.texParameteri(t.TEXTURE_2D, t.TEXTURE_MAG_FILTER, s === n.scaleModes.LINEAR ? t.LINEAR : t.NEAREST), t.texParameteri(t.TEXTURE_2D, t.TEXTURE_MIN_FILTER, s === n.scaleModes.LINEAR ? t.LINEAR : t.NEAREST), t.texParameteri(t.TEXTURE_2D, t.TEXTURE_WRAP_S, t.CLAMP_TO_EDGE), t.texParameteri(t.TEXTURE_2D, t.TEXTURE_WRAP_T, t.CLAMP_TO_EDGE), t.bindFramebuffer(t.FRAMEBUFFER, this.framebuffer), t.bindFramebuffer(t.FRAMEBUFFER, this.frameBuffer), t.framebufferTexture2D(t.FRAMEBUFFER, t.COLOR_ATTACHMENT0, t.TEXTURE_2D, this.texture, 0), this.renderBuffer = t.createRenderbuffer(), t.bindRenderbuffer(t.RENDERBUFFER, this.renderBuffer), t.framebufferRenderbuffer(t.FRAMEBUFFER, t.DEPTH_STENCIL_ATTACHMENT, t.RENDERBUFFER, this.renderBuffer), this.resize(e, i)
                    }, n.FilterTexture.prototype.clear = function() {
                        var t = this.gl;
                        t.clearColor(0, 0, 0, 0), t.clear(t.COLOR_BUFFER_BIT)
                    }, n.FilterTexture.prototype.resize = function(t, e) {
                        if (this.width !== t || this.height !== e) {
                            this.width = t, this.height = e;
                            var i = this.gl;
                            i.bindTexture(i.TEXTURE_2D, this.texture), i.texImage2D(i.TEXTURE_2D, 0, i.RGBA, t, e, 0, i.RGBA, i.UNSIGNED_BYTE, null), i.bindRenderbuffer(i.RENDERBUFFER, this.renderBuffer), i.renderbufferStorage(i.RENDERBUFFER, i.DEPTH_STENCIL, t, e)
                        }
                    }, n.FilterTexture.prototype.destroy = function() {
                        var t = this.gl;
                        t.deleteFramebuffer(this.frameBuffer), t.deleteTexture(this.texture), this.frameBuffer = null, this.texture = null
                    }, n.CanvasMaskManager = function() {}, n.CanvasMaskManager.prototype.pushMask = function(t, e) {
                        e.save();
                        var i = t.alpha,
                            s = t.worldTransform;
                        e.setTransform(s.a, s.c, s.b, s.d, s.tx, s.ty), n.CanvasGraphics.renderGraphicsMask(t, e), e.clip(), t.worldAlpha = i
                    }, n.CanvasMaskManager.prototype.popMask = function(t) {
                        t.restore()
                    }, n.CanvasTinter = function() {}, n.CanvasTinter.getTintedTexture = function(t, e) {
                        var i = t.texture;
                        e = n.CanvasTinter.roundColor(e);
                        var s = "#" + ("00000" + (0 | e).toString(16)).substr(-6);
                        if (i.tintCache = i.tintCache || {}, i.tintCache[s]) return i.tintCache[s];
                        var r = n.CanvasTinter.canvas || document.createElement("canvas");
                        if (n.CanvasTinter.tintMethod(i, e, r), n.CanvasTinter.convertTintToImage) {
                            var o = new Image;
                            o.src = r.toDataURL(), i.tintCache[s] = o
                        } else i.tintCache[s] = r, n.CanvasTinter.canvas = null;
                        return r
                    }, n.CanvasTinter.tintWithMultiply = function(t, e, i) {
                        var s = i.getContext("2d"),
                            n = t.frame;
                        i.width = n.width, i.height = n.height, s.fillStyle = "#" + ("00000" + (0 | e).toString(16)).substr(-6), s.fillRect(0, 0, n.width, n.height), s.globalCompositeOperation = "multiply", s.drawImage(t.baseTexture.source, n.x, n.y, n.width, n.height, 0, 0, n.width, n.height), s.globalCompositeOperation = "destination-atop", s.drawImage(t.baseTexture.source, n.x, n.y, n.width, n.height, 0, 0, n.width, n.height)
                    }, n.CanvasTinter.tintWithOverlay = function(t, e, i) {
                        var s = i.getContext("2d"),
                            n = t.frame;
                        i.width = n.width, i.height = n.height, s.globalCompositeOperation = "copy", s.fillStyle = "#" + ("00000" + (0 | e).toString(16)).substr(-6), s.fillRect(0, 0, n.width, n.height), s.globalCompositeOperation = "destination-atop", s.drawImage(t.baseTexture.source, n.x, n.y, n.width, n.height, 0, 0, n.width, n.height)
                    }, n.CanvasTinter.tintWithPerPixel = function(t, e, i) {
                        var s = i.getContext("2d"),
                            r = t.frame;
                        i.width = r.width, i.height = r.height, s.globalCompositeOperation = "copy", s.drawImage(t.baseTexture.source, r.x, r.y, r.width, r.height, 0, 0, r.width, r.height);
                        for (var o = n.hex2rgb(e), a = o[0], h = o[1], l = o[2], c = s.getImageData(0, 0, r.width, r.height), u = c.data, d = 0; d < u.length; d += 4) u[d + 0] *= a, u[d + 1] *= h, u[d + 2] *= l;
                        s.putImageData(c, 0, 0)
                    }, n.CanvasTinter.roundColor = function(t) {
                        var e = n.CanvasTinter.cacheStepsPerColorChannel,
                            i = n.hex2rgb(t);
                        return i[0] = Math.min(255, i[0] / e * e), i[1] = Math.min(255, i[1] / e * e), i[2] = Math.min(255, i[2] / e * e), n.rgb2hex(i)
                    }, n.CanvasTinter.cacheStepsPerColorChannel = 8, n.CanvasTinter.convertTintToImage = !1, n.CanvasTinter.canUseMultiply = n.canUseNewCanvasBlendModes(), n.CanvasTinter.tintMethod = n.CanvasTinter.canUseMultiply ? n.CanvasTinter.tintWithMultiply : n.CanvasTinter.tintWithPerPixel, n.CanvasRenderer = function(t, e, i, s) {
                        n.defaultRenderer || (n.sayHello("Canvas"), n.defaultRenderer = this), this.type = n.CANVAS_RENDERER, this.clearBeforeRender = !0, this.transparent = !!s, n.blendModesCanvas || (n.blendModesCanvas = [], n.canUseNewCanvasBlendModes() ? (n.blendModesCanvas[n.blendModes.NORMAL] = "source-over", n.blendModesCanvas[n.blendModes.ADD] = "lighter", n.blendModesCanvas[n.blendModes.MULTIPLY] = "multiply", n.blendModesCanvas[n.blendModes.SCREEN] = "screen", n.blendModesCanvas[n.blendModes.OVERLAY] = "overlay", n.blendModesCanvas[n.blendModes.DARKEN] = "darken", n.blendModesCanvas[n.blendModes.LIGHTEN] = "lighten", n.blendModesCanvas[n.blendModes.COLOR_DODGE] = "color-dodge", n.blendModesCanvas[n.blendModes.COLOR_BURN] = "color-burn", n.blendModesCanvas[n.blendModes.HARD_LIGHT] = "hard-light", n.blendModesCanvas[n.blendModes.SOFT_LIGHT] = "soft-light", n.blendModesCanvas[n.blendModes.DIFFERENCE] = "difference", n.blendModesCanvas[n.blendModes.EXCLUSION] = "exclusion", n.blendModesCanvas[n.blendModes.HUE] = "hue", n.blendModesCanvas[n.blendModes.SATURATION] = "saturation", n.blendModesCanvas[n.blendModes.COLOR] = "color", n.blendModesCanvas[n.blendModes.LUMINOSITY] = "luminosity") : (n.blendModesCanvas[n.blendModes.NORMAL] = "source-over", n.blendModesCanvas[n.blendModes.ADD] = "lighter", n.blendModesCanvas[n.blendModes.MULTIPLY] = "source-over", n.blendModesCanvas[n.blendModes.SCREEN] = "source-over", n.blendModesCanvas[n.blendModes.OVERLAY] = "source-over", n.blendModesCanvas[n.blendModes.DARKEN] = "source-over", n.blendModesCanvas[n.blendModes.LIGHTEN] = "source-over", n.blendModesCanvas[n.blendModes.COLOR_DODGE] = "source-over", n.blendModesCanvas[n.blendModes.COLOR_BURN] = "source-over", n.blendModesCanvas[n.blendModes.HARD_LIGHT] = "source-over", n.blendModesCanvas[n.blendModes.SOFT_LIGHT] = "source-over", n.blendModesCanvas[n.blendModes.DIFFERENCE] = "source-over", n.blendModesCanvas[n.blendModes.EXCLUSION] = "source-over", n.blendModesCanvas[n.blendModes.HUE] = "source-over", n.blendModesCanvas[n.blendModes.SATURATION] = "source-over", n.blendModesCanvas[n.blendModes.COLOR] = "source-over", n.blendModesCanvas[n.blendModes.LUMINOSITY] = "source-over")), this.width = t || 800, this.height = e || 600, this.view = i || document.createElement("canvas"), this.context = this.view.getContext("2d", {
                            alpha: this.transparent
                        }), this.refresh = !0, this.view.width = this.width, this.view.height = this.height, this.count = 0, this.maskManager = new n.CanvasMaskManager, this.renderSession = {
                            context: this.context,
                            maskManager: this.maskManager,
                            scaleMode: null,
                            smoothProperty: null,
                            roundPixels: !1
                        }, "imageSmoothingEnabled" in this.context ? this.renderSession.smoothProperty = "imageSmoothingEnabled" : "webkitImageSmoothingEnabled" in this.context ? this.renderSession.smoothProperty = "webkitImageSmoothingEnabled" : "mozImageSmoothingEnabled" in this.context ? this.renderSession.smoothProperty = "mozImageSmoothingEnabled" : "oImageSmoothingEnabled" in this.context && (this.renderSession.smoothProperty = "oImageSmoothingEnabled")
                    }, n.CanvasRenderer.prototype.constructor = n.CanvasRenderer, n.CanvasRenderer.prototype.render = function(t) {
                        n.texturesToUpdate.length = 0, n.texturesToDestroy.length = 0, t.updateTransform(), this.context.setTransform(1, 0, 0, 1, 0, 0), this.context.globalAlpha = 1, navigator.isCocoonJS && this.view.screencanvas && (this.context.fillStyle = "black", this.context.clear()), !this.transparent && this.clearBeforeRender ? (this.context.fillStyle = t.backgroundColorString, this.context.fillRect(0, 0, this.width, this.height)) : this.transparent && this.clearBeforeRender && this.context.clearRect(0, 0, this.width, this.height), this.renderDisplayObject(t), t.interactive && (t._interactiveEventsAdded || (t._interactiveEventsAdded = !0, t.interactionManager.setTarget(this))), n.Texture.frameUpdates.length > 0 && (n.Texture.frameUpdates.length = 0)
                    }, n.CanvasRenderer.prototype.resize = function(t, e) {
                        this.width = t, this.height = e, this.view.width = t, this.view.height = e
                    }, n.CanvasRenderer.prototype.renderDisplayObject = function(t, e) {
                        this.renderSession.context = e || this.context, t._renderCanvas(this.renderSession)
                    }, n.CanvasRenderer.prototype.renderStripFlat = function(t) {
                        var e = this.context,
                            i = t.verticies,
                            s = i.length / 2;
                        this.count++, e.beginPath();
                        for (var n = 1; s - 2 > n; n++) {
                            var r = 2 * n,
                                o = i[r],
                                a = i[r + 2],
                                h = i[r + 4],
                                l = i[r + 1],
                                c = i[r + 3],
                                u = i[r + 5];
                            e.moveTo(o, l), e.lineTo(a, c), e.lineTo(h, u)
                        }
                        e.fillStyle = "#FF0000", e.fill(), e.closePath()
                    }, n.CanvasRenderer.prototype.renderStrip = function(t) {
                        var e = this.context,
                            i = t.verticies,
                            s = t.uvs,
                            n = i.length / 2;
                        this.count++;
                        for (var r = 1; n - 2 > r; r++) {
                            var o = 2 * r,
                                a = i[o],
                                h = i[o + 2],
                                l = i[o + 4],
                                c = i[o + 1],
                                u = i[o + 3],
                                d = i[o + 5],
                                p = s[o] * t.texture.width,
                                f = s[o + 2] * t.texture.width,
                                g = s[o + 4] * t.texture.width,
                                m = s[o + 1] * t.texture.height,
                                y = s[o + 3] * t.texture.height,
                                v = s[o + 5] * t.texture.height;
                            e.save(), e.beginPath(), e.moveTo(a, c), e.lineTo(h, u), e.lineTo(l, d), e.closePath(), e.clip();
                            var x = p * y + m * g + f * v - y * g - m * f - p * v,
                                b = a * y + m * l + h * v - y * l - m * h - a * v,
                                _ = p * h + a * g + f * l - h * g - a * f - p * l,
                                w = p * y * l + m * h * g + a * f * v - a * y * g - m * f * l - p * h * v,
                                P = c * y + m * d + u * v - y * d - m * u - c * v,
                                T = p * u + c * g + f * d - u * g - c * f - p * d,
                                S = p * y * d + m * u * g + c * f * v - c * y * g - m * f * d - p * u * v;
                            e.transform(b / x, P / x, _ / x, T / x, w / x, S / x), e.drawImage(t.texture.baseTexture.source, 0, 0), e.restore()
                        }
                    }, n.CanvasBuffer = function(t, e) {
                        this.width = t, this.height = e, this.canvas = document.createElement("canvas"), this.context = this.canvas.getContext("2d"), this.canvas.width = t, this.canvas.height = e
                    }, n.CanvasBuffer.prototype.clear = function() {
                        this.context.clearRect(0, 0, this.width, this.height)
                    }, n.CanvasBuffer.prototype.resize = function(t, e) {
                        this.width = this.canvas.width = t, this.height = this.canvas.height = e
                    }, n.CanvasGraphics = function() {}, n.CanvasGraphics.renderGraphics = function(t, e) {
                        for (var i = t.worldAlpha, s = "", r = 0; r < t.graphicsData.length; r++) {
                            var o = t.graphicsData[r],
                                a = o.points;
                            if (e.strokeStyle = s = "#" + ("00000" + (0 | o.lineColor).toString(16)).substr(-6), e.lineWidth = o.lineWidth, o.type === n.Graphics.POLY) {
                                e.beginPath(), e.moveTo(a[0], a[1]);
                                for (var h = 1; h < a.length / 2; h++) e.lineTo(a[2 * h], a[2 * h + 1]);
                                a[0] === a[a.length - 2] && a[1] === a[a.length - 1] && e.closePath(), o.fill && (e.globalAlpha = o.fillAlpha * i, e.fillStyle = s = "#" + ("00000" + (0 | o.fillColor).toString(16)).substr(-6), e.fill()), o.lineWidth && (e.globalAlpha = o.lineAlpha * i, e.stroke())
                            } else if (o.type === n.Graphics.RECT)(o.fillColor || 0 === o.fillColor) && (e.globalAlpha = o.fillAlpha * i, e.fillStyle = s = "#" + ("00000" + (0 | o.fillColor).toString(16)).substr(-6), e.fillRect(a[0], a[1], a[2], a[3])), o.lineWidth && (e.globalAlpha = o.lineAlpha * i, e.strokeRect(a[0], a[1], a[2], a[3]));
                            else if (o.type === n.Graphics.CIRC) e.beginPath(), e.arc(a[0], a[1], a[2], 0, 2 * Math.PI), e.closePath(), o.fill && (e.globalAlpha = o.fillAlpha * i, e.fillStyle = s = "#" + ("00000" + (0 | o.fillColor).toString(16)).substr(-6), e.fill()), o.lineWidth && (e.globalAlpha = o.lineAlpha * i, e.stroke());
                            else if (o.type === n.Graphics.ELIP) {
                                var l = o.points,
                                    c = 2 * l[2],
                                    u = 2 * l[3],
                                    d = l[0] - c / 2,
                                    p = l[1] - u / 2;
                                e.beginPath();
                                var f = .5522848,
                                    g = c / 2 * f,
                                    m = u / 2 * f,
                                    y = d + c,
                                    v = p + u,
                                    x = d + c / 2,
                                    b = p + u / 2;
                                e.moveTo(d, b), e.bezierCurveTo(d, b - m, x - g, p, x, p), e.bezierCurveTo(x + g, p, y, b - m, y, b), e.bezierCurveTo(y, b + m, x + g, v, x, v), e.bezierCurveTo(x - g, v, d, b + m, d, b), e.closePath(), o.fill && (e.globalAlpha = o.fillAlpha * i, e.fillStyle = s = "#" + ("00000" + (0 | o.fillColor).toString(16)).substr(-6), e.fill()), o.lineWidth && (e.globalAlpha = o.lineAlpha * i, e.stroke())
                            } else if (o.type === n.Graphics.RREC) {
                                var _ = a[0],
                                    w = a[1],
                                    P = a[2],
                                    T = a[3],
                                    S = a[4],
                                    C = Math.min(P, T) / 2 | 0;
                                S = S > C ? C : S, e.beginPath(), e.moveTo(_, w + S), e.lineTo(_, w + T - S), e.quadraticCurveTo(_, w + T, _ + S, w + T), e.lineTo(_ + P - S, w + T), e.quadraticCurveTo(_ + P, w + T, _ + P, w + T - S), e.lineTo(_ + P, w + S), e.quadraticCurveTo(_ + P, w, _ + P - S, w), e.lineTo(_ + S, w), e.quadraticCurveTo(_, w, _, w + S), e.closePath(), (o.fillColor || 0 === o.fillColor) && (e.globalAlpha = o.fillAlpha * i, e.fillStyle = s = "#" + ("00000" + (0 | o.fillColor).toString(16)).substr(-6), e.fill()), o.lineWidth && (e.globalAlpha = o.lineAlpha * i, e.stroke())
                            }
                        }
                    }, n.CanvasGraphics.renderGraphicsMask = function(t, e) {
                        var i = t.graphicsData.length;
                        if (0 !== i) {
                            i > 1 && (i = 1, window.console.log("Pixi.js warning: masks in canvas can only mask using the first path in the graphics object"));
                            for (var s = 0; 1 > s; s++) {
                                var r = t.graphicsData[s],
                                    o = r.points;
                                if (r.type === n.Graphics.POLY) {
                                    e.beginPath(), e.moveTo(o[0], o[1]);
                                    for (var a = 1; a < o.length / 2; a++) e.lineTo(o[2 * a], o[2 * a + 1]);
                                    o[0] === o[o.length - 2] && o[1] === o[o.length - 1] && e.closePath()
                                } else if (r.type === n.Graphics.RECT) e.beginPath(), e.rect(o[0], o[1], o[2], o[3]), e.closePath();
                                else if (r.type === n.Graphics.CIRC) e.beginPath(), e.arc(o[0], o[1], o[2], 0, 2 * Math.PI), e.closePath();
                                else if (r.type === n.Graphics.ELIP) {
                                    var h = r.points,
                                        l = 2 * h[2],
                                        c = 2 * h[3],
                                        u = h[0] - l / 2,
                                        d = h[1] - c / 2;
                                    e.beginPath();
                                    var p = .5522848,
                                        f = l / 2 * p,
                                        g = c / 2 * p,
                                        m = u + l,
                                        y = d + c,
                                        v = u + l / 2,
                                        x = d + c / 2;
                                    e.moveTo(u, x), e.bezierCurveTo(u, x - g, v - f, d, v, d), e.bezierCurveTo(v + f, d, m, x - g, m, x), e.bezierCurveTo(m, x + g, v + f, y, v, y), e.bezierCurveTo(v - f, y, u, x + g, u, x), e.closePath()
                                } else if (r.type === n.Graphics.RREC) {
                                    var b = o[0],
                                        _ = o[1],
                                        w = o[2],
                                        P = o[3],
                                        T = o[4],
                                        S = Math.min(w, P) / 2 | 0;
                                    T = T > S ? S : T, e.beginPath(), e.moveTo(b, _ + T), e.lineTo(b, _ + P - T), e.quadraticCurveTo(b, _ + P, b + T, _ + P), e.lineTo(b + w - T, _ + P), e.quadraticCurveTo(b + w, _ + P, b + w, _ + P - T), e.lineTo(b + w, _ + T), e.quadraticCurveTo(b + w, _, b + w - T, _), e.lineTo(b + T, _), e.quadraticCurveTo(b, _, b, _ + T), e.closePath()
                                }
                            }
                        }
                    }, n.Graphics = function() {
                        n.DisplayObjectContainer.call(this), this.renderable = !0, this.fillAlpha = 1, this.lineWidth = 0, this.lineColor = "black", this.graphicsData = [], this.tint = 16777215, this.blendMode = n.blendModes.NORMAL, this.currentPath = {
                            points: []
                        }, this._webGL = [], this.isMask = !1, this.bounds = null, this.boundsPadding = 10, this.dirty = !0
                    }, n.Graphics.prototype = Object.create(n.DisplayObjectContainer.prototype), n.Graphics.prototype.constructor = n.Graphics, Object.defineProperty(n.Graphics.prototype, "cacheAsBitmap", {
                        get: function() {
                            return this._cacheAsBitmap
                        },
                        set: function(t) {
                            this._cacheAsBitmap = t, this._cacheAsBitmap ? this._generateCachedSprite() : (this.destroyCachedSprite(), this.dirty = !0)
                        }
                    }), n.Graphics.prototype.lineStyle = function(t, e, i) {
                        return this.currentPath.points.length || this.graphicsData.pop(), this.lineWidth = t || 0, this.lineColor = e || 0, this.lineAlpha = arguments.length < 3 ? 1 : i, this.currentPath = {
                            lineWidth: this.lineWidth,
                            lineColor: this.lineColor,
                            lineAlpha: this.lineAlpha,
                            fillColor: this.fillColor,
                            fillAlpha: this.fillAlpha,
                            fill: this.filling,
                            points: [],
                            type: n.Graphics.POLY
                        }, this.graphicsData.push(this.currentPath), this
                    }, n.Graphics.prototype.moveTo = function(t, e) {
                        return this.currentPath.points.length || this.graphicsData.pop(), this.currentPath = this.currentPath = {
                            lineWidth: this.lineWidth,
                            lineColor: this.lineColor,
                            lineAlpha: this.lineAlpha,
                            fillColor: this.fillColor,
                            fillAlpha: this.fillAlpha,
                            fill: this.filling,
                            points: [],
                            type: n.Graphics.POLY
                        }, this.currentPath.points.push(t, e), this.graphicsData.push(this.currentPath), this
                    }, n.Graphics.prototype.lineTo = function(t, e) {
                        return this.currentPath.points.push(t, e), this.dirty = !0, this
                    }, n.Graphics.prototype.quadraticCurveTo = function(t, e, i, s) {
                        0 === this.currentPath.points.length && this.moveTo(0, 0);
                        var n, r, o = 20,
                            a = this.currentPath.points;
                        0 === a.length && this.moveTo(0, 0);
                        for (var h = a[a.length - 2], l = a[a.length - 1], c = 0, u = 1; o >= u; u++) c = u / o, n = h + (t - h) * c, r = l + (e - l) * c, a.push(n + (t + (i - t) * c - n) * c, r + (e + (s - e) * c - r) * c);
                        return this.dirty = !0, this
                    }, n.Graphics.prototype.bezierCurveTo = function(t, e, i, s, n, r) {
                        0 === this.currentPath.points.length && this.moveTo(0, 0);
                        for (var o, a, h, l, c, u = 20, d = this.currentPath.points, p = d[d.length - 2], f = d[d.length - 1], g = 0, m = 1; u > m; m++) g = m / u, o = 1 - g, a = o * o, h = a * o, l = g * g, c = l * g, d.push(h * p + 3 * a * g * t + 3 * o * l * i + c * n, h * f + 3 * a * g * e + 3 * o * l * s + c * r);
                        return this.dirty = !0, this
                    }, n.Graphics.prototype.arcTo = function(t, e, i, s, n) {
                        0 === this.currentPath.points.length && this.moveTo(t, e);
                        var r = this.currentPath.points,
                            o = r[r.length - 2],
                            a = r[r.length - 1],
                            h = a - e,
                            l = o - t,
                            c = s - e,
                            u = i - t,
                            d = Math.abs(h * u - l * c);
                        if (1e-8 > d || 0 === n) r.push(t, e);
                        else {
                            var p = h * h + l * l,
                                f = c * c + u * u,
                                g = h * c + l * u,
                                m = n * Math.sqrt(p) / d,
                                y = n * Math.sqrt(f) / d,
                                v = m * g / p,
                                x = y * g / f,
                                b = m * u + y * l,
                                _ = m * c + y * h,
                                w = l * (y + v),
                                P = h * (y + v),
                                T = u * (m + x),
                                S = c * (m + x),
                                C = Math.atan2(P - _, w - b),
                                A = Math.atan2(S - _, T - b);
                            this.arc(b + t, _ + e, n, C, A, l * c > u * h)
                        }
                        return this.dirty = !0, this
                    }, n.Graphics.prototype.arc = function(t, e, i, s, n, r) {
                        var o = t + Math.cos(s) * i,
                            a = e + Math.sin(s) * i,
                            h = this.currentPath.points;
                        if ((0 !== h.length && h[h.length - 2] !== o || h[h.length - 1] !== a) && (this.moveTo(o, a), h = this.currentPath.points), s === n) return this;
                        !r && s >= n ? n += 2 * Math.PI : r && n >= s && (s += 2 * Math.PI);
                        var l = r ? -1 * (s - n) : n - s,
                            c = Math.abs(l) / (2 * Math.PI) * 40;
                        if (0 === l) return this;
                        for (var u = l / (2 * c), d = 2 * u, p = Math.cos(u), f = Math.sin(u), g = c - 1, m = g % 1 / g, y = 0; g >= y; y++) {
                            var v = y + m * y,
                                x = u + s + d * v,
                                b = Math.cos(x),
                                _ = -Math.sin(x);
                            h.push((p * b + f * _) * i + t, (p * -_ + f * b) * i + e)
                        }
                        return this.dirty = !0, this
                    }, n.Graphics.prototype.drawPath = function(t) {
                        return this.currentPath.points.length || this.graphicsData.pop(), this.currentPath = this.currentPath = {
                            lineWidth: this.lineWidth,
                            lineColor: this.lineColor,
                            lineAlpha: this.lineAlpha,
                            fillColor: this.fillColor,
                            fillAlpha: this.fillAlpha,
                            fill: this.filling,
                            points: [],
                            type: n.Graphics.POLY
                        }, this.graphicsData.push(this.currentPath), this.currentPath.points = this.currentPath.points.concat(t), this.dirty = !0, this
                    }, n.Graphics.prototype.beginFill = function(t, e) {
                        return this.filling = !0, this.fillColor = t || 0, this.fillAlpha = arguments.length < 2 ? 1 : e, this
                    }, n.Graphics.prototype.endFill = function() {
                        return this.filling = !1, this.fillColor = null, this.fillAlpha = 1, this
                    }, n.Graphics.prototype.drawRect = function(t, e, i, s) {
                        return this.currentPath.points.length || this.graphicsData.pop(), this.currentPath = {
                            lineWidth: this.lineWidth,
                            lineColor: this.lineColor,
                            lineAlpha: this.lineAlpha,
                            fillColor: this.fillColor,
                            fillAlpha: this.fillAlpha,
                            fill: this.filling,
                            points: [t, e, i, s],
                            type: n.Graphics.RECT
                        }, this.graphicsData.push(this.currentPath), this.dirty = !0, this
                    }, n.Graphics.prototype.drawRoundedRect = function(t, e, i, s, r) {
                        return this.currentPath.points.length || this.graphicsData.pop(), this.currentPath = {
                            lineWidth: this.lineWidth,
                            lineColor: this.lineColor,
                            lineAlpha: this.lineAlpha,
                            fillColor: this.fillColor,
                            fillAlpha: this.fillAlpha,
                            fill: this.filling,
                            points: [t, e, i, s, r],
                            type: n.Graphics.RREC
                        }, this.graphicsData.push(this.currentPath), this.dirty = !0, this
                    }, n.Graphics.prototype.drawCircle = function(t, e, i) {
                        return this.currentPath.points.length || this.graphicsData.pop(), this.currentPath = {
                            lineWidth: this.lineWidth,
                            lineColor: this.lineColor,
                            lineAlpha: this.lineAlpha,
                            fillColor: this.fillColor,
                            fillAlpha: this.fillAlpha,
                            fill: this.filling,
                            points: [t, e, i, i],
                            type: n.Graphics.CIRC
                        }, this.graphicsData.push(this.currentPath), this.dirty = !0, this
                    }, n.Graphics.prototype.drawEllipse = function(t, e, i, s) {
                        return this.currentPath.points.length || this.graphicsData.pop(), this.currentPath = {
                            lineWidth: this.lineWidth,
                            lineColor: this.lineColor,
                            lineAlpha: this.lineAlpha,
                            fillColor: this.fillColor,
                            fillAlpha: this.fillAlpha,
                            fill: this.filling,
                            points: [t, e, i, s],
                            type: n.Graphics.ELIP
                        }, this.graphicsData.push(this.currentPath), this.dirty = !0, this
                    }, n.Graphics.prototype.clear = function() {
                        return this.lineWidth = 0, this.filling = !1, this.dirty = !0, this.clearDirty = !0, this.graphicsData = [], this.bounds = null, this
                    }, n.Graphics.prototype.generateTexture = function() {
                        var t = this.getBounds(),
                            e = new n.CanvasBuffer(t.width, t.height),
                            i = n.Texture.fromCanvas(e.canvas);
                        return e.context.translate(-t.x, -t.y), n.CanvasGraphics.renderGraphics(this, e.context), i
                    }, n.Graphics.prototype._renderWebGL = function(t) {
                        if (this.visible !== !1 && 0 !== this.alpha && this.isMask !== !0) {
                            if (this._cacheAsBitmap) return this.dirty && (this._generateCachedSprite(), n.updateWebGLTexture(this._cachedSprite.texture.baseTexture, t.gl), this.dirty = !1), this._cachedSprite.alpha = this.alpha, void n.Sprite.prototype._renderWebGL.call(this._cachedSprite, t);
                            if (t.spriteBatch.stop(), t.blendModeManager.setBlendMode(this.blendMode), this._mask && t.maskManager.pushMask(this._mask, t), this._filters && t.filterManager.pushFilter(this._filterBlock), this.blendMode !== t.spriteBatch.currentBlendMode) {
                                t.spriteBatch.currentBlendMode = this.blendMode;
                                var e = n.blendModesWebGL[t.spriteBatch.currentBlendMode];
                                t.spriteBatch.gl.blendFunc(e[0], e[1])
                            }
                            if (n.WebGLGraphics.renderGraphics(this, t), this.children.length) {
                                t.spriteBatch.start();
                                for (var i = 0, s = this.children.length; s > i; i++) this.children[i]._renderWebGL(t);
                                t.spriteBatch.stop()
                            }
                            this._filters && t.filterManager.popFilter(), this._mask && t.maskManager.popMask(this.mask, t), t.drawCount++, t.spriteBatch.start()
                        }
                    }, n.Graphics.prototype._renderCanvas = function(t) {
                        if (this.visible !== !1 && 0 !== this.alpha && this.isMask !== !0) {
                            var e = t.context,
                                i = this.worldTransform;
                            this.blendMode !== t.currentBlendMode && (t.currentBlendMode = this.blendMode, e.globalCompositeOperation = n.blendModesCanvas[t.currentBlendMode]), this._mask && t.maskManager.pushMask(this._mask, t.context), e.setTransform(i.a, i.c, i.b, i.d, i.tx, i.ty), n.CanvasGraphics.renderGraphics(this, e);
                            for (var s = 0, r = this.children.length; r > s; s++) this.children[s]._renderCanvas(t);
                            this._mask && t.maskManager.popMask(t.context)
                        }
                    }, n.Graphics.prototype.getBounds = function(t) {
                        this.bounds || this.updateBounds();
                        var e = this.bounds.x,
                            i = this.bounds.width + this.bounds.x,
                            s = this.bounds.y,
                            n = this.bounds.height + this.bounds.y,
                            r = t || this.worldTransform,
                            o = r.a,
                            a = r.c,
                            h = r.b,
                            l = r.d,
                            c = r.tx,
                            u = r.ty,
                            d = o * i + h * n + c,
                            p = l * n + a * i + u,
                            f = o * e + h * n + c,
                            g = l * n + a * e + u,
                            m = o * e + h * s + c,
                            y = l * s + a * e + u,
                            v = o * i + h * s + c,
                            x = l * s + a * i + u,
                            b = d,
                            _ = p,
                            w = d,
                            P = p;
                        w = w > f ? f : w, w = w > m ? m : w, w = w > v ? v : w, P = P > g ? g : P, P = P > y ? y : P, P = P > x ? x : P, b = f > b ? f : b, b = m > b ? m : b, b = v > b ? v : b, _ = g > _ ? g : _, _ = y > _ ? y : _, _ = x > _ ? x : _;
                        var T = this._bounds;
                        return T.x = w, T.width = b - w, T.y = P, T.height = _ - P, T
                    }, n.Graphics.prototype.updateBounds = function() {
                        for (var t, e, i, s, r, o = 1 / 0, a = -1 / 0, h = 1 / 0, l = -1 / 0, c = 0; c < this.graphicsData.length; c++) {
                            var u = this.graphicsData[c],
                                d = u.type,
                                p = u.lineWidth;
                            if (t = u.points, d === n.Graphics.RECT) e = t[0] - p / 2, i = t[1] - p / 2, s = t[2] + p, r = t[3] + p, o = o > e ? e : o, a = e + s > a ? e + s : a, h = h > i ? e : h, l = i + r > l ? i + r : l;
                            else if (d === n.Graphics.CIRC || d === n.Graphics.ELIP) e = t[0], i = t[1], s = t[2] + p / 2, r = t[3] + p / 2, o = o > e - s ? e - s : o, a = e + s > a ? e + s : a, h = h > i - r ? i - r : h, l = i + r > l ? i + r : l;
                            else
                                for (var f = 0; f < t.length; f += 2) e = t[f], i = t[f + 1], o = o > e - p ? e - p : o, a = e + p > a ? e + p : a, h = h > i - p ? i - p : h, l = i + p > l ? i + p : l
                        }
                        var g = this.boundsPadding;
                        this.bounds = new n.Rectangle(o - g, h - g, a - o + 2 * g, l - h + 2 * g)
                    }, n.Graphics.prototype._generateCachedSprite = function() {
                        var t = this.getLocalBounds();
                        if (this._cachedSprite) this._cachedSprite.buffer.resize(t.width, t.height);
                        else {
                            var e = new n.CanvasBuffer(t.width, t.height),
                                i = n.Texture.fromCanvas(e.canvas);
                            this._cachedSprite = new n.Sprite(i), this._cachedSprite.buffer = e, this._cachedSprite.worldTransform = this.worldTransform
                        }
                        this._cachedSprite.anchor.x = -(t.x / t.width), this._cachedSprite.anchor.y = -(t.y / t.height), this._cachedSprite.buffer.context.translate(-t.x, -t.y), n.CanvasGraphics.renderGraphics(this, this._cachedSprite.buffer.context), this._cachedSprite.alpha = this.alpha
                    }, n.Graphics.prototype.destroyCachedSprite = function() {
                        this._cachedSprite.texture.destroy(!0), this._cachedSprite = null
                    }, n.Graphics.POLY = 0, n.Graphics.RECT = 1, n.Graphics.CIRC = 2, n.Graphics.ELIP = 3, n.Graphics.RREC = 4, n.Strip = function(t) {
                        n.DisplayObjectContainer.call(this), this.texture = t, this.uvs = new n.Float32Array([0, 1, 1, 1, 1, 0, 0, 1]), this.verticies = new n.Float32Array([0, 0, 100, 0, 100, 100, 0, 100]), this.colors = new n.Float32Array([1, 1, 1, 1]), this.indices = new n.Uint16Array([0, 1, 2, 3]), this.dirty = !0
                    }, n.Strip.prototype = Object.create(n.DisplayObjectContainer.prototype), n.Strip.prototype.constructor = n.Strip, n.Strip.prototype._renderWebGL = function(t) {
                        !this.visible || this.alpha <= 0 || (t.spriteBatch.stop(), this._vertexBuffer || this._initWebGL(t), t.shaderManager.setShader(t.shaderManager.stripShader), this._renderStrip(t), t.spriteBatch.start())
                    }, n.Strip.prototype._initWebGL = function(t) {
                        var e = t.gl;
                        this._vertexBuffer = e.createBuffer(), this._indexBuffer = e.createBuffer(), this._uvBuffer = e.createBuffer(), this._colorBuffer = e.createBuffer(), e.bindBuffer(e.ARRAY_BUFFER, this._vertexBuffer), e.bufferData(e.ARRAY_BUFFER, this.verticies, e.DYNAMIC_DRAW), e.bindBuffer(e.ARRAY_BUFFER, this._uvBuffer), e.bufferData(e.ARRAY_BUFFER, this.uvs, e.STATIC_DRAW), e.bindBuffer(e.ARRAY_BUFFER, this._colorBuffer), e.bufferData(e.ARRAY_BUFFER, this.colors, e.STATIC_DRAW), e.bindBuffer(e.ELEMENT_ARRAY_BUFFER, this._indexBuffer), e.bufferData(e.ELEMENT_ARRAY_BUFFER, this.indices, e.STATIC_DRAW)
                    }, n.Strip.prototype._renderStrip = function(t) {
                        var e = t.gl,
                            i = t.projection,
                            s = t.offset,
                            r = t.shaderManager.stripShader;
                        e.blendFunc(e.ONE, e.ONE_MINUS_SRC_ALPHA), e.uniformMatrix3fv(r.translationMatrix, !1, this.worldTransform.toArray(!0)), e.uniform2f(r.projectionVector, i.x, -i.y), e.uniform2f(r.offsetVector, -s.x, -s.y), e.uniform1f(r.alpha, 1), this.dirty ? (this.dirty = !1, e.bindBuffer(e.ARRAY_BUFFER, this._vertexBuffer), e.bufferData(e.ARRAY_BUFFER, this.verticies, e.STATIC_DRAW), e.vertexAttribPointer(r.aVertexPosition, 2, e.FLOAT, !1, 0, 0), e.bindBuffer(e.ARRAY_BUFFER, this._uvBuffer), e.bufferData(e.ARRAY_BUFFER, this.uvs, e.STATIC_DRAW), e.vertexAttribPointer(r.aTextureCoord, 2, e.FLOAT, !1, 0, 0), e.activeTexture(e.TEXTURE0), e.bindTexture(e.TEXTURE_2D, this.texture.baseTexture._glTextures[e.id] || n.createWebGLTexture(this.texture.baseTexture, e)), e.bindBuffer(e.ELEMENT_ARRAY_BUFFER, this._indexBuffer), e.bufferData(e.ELEMENT_ARRAY_BUFFER, this.indices, e.STATIC_DRAW)) : (e.bindBuffer(e.ARRAY_BUFFER, this._vertexBuffer), e.bufferSubData(e.ARRAY_BUFFER, 0, this.verticies), e.vertexAttribPointer(r.aVertexPosition, 2, e.FLOAT, !1, 0, 0), e.bindBuffer(e.ARRAY_BUFFER, this._uvBuffer), e.vertexAttribPointer(r.aTextureCoord, 2, e.FLOAT, !1, 0, 0), e.activeTexture(e.TEXTURE0), e.bindTexture(e.TEXTURE_2D, this.texture.baseTexture._glTextures[e.id] || n.createWebGLTexture(this.texture.baseTexture, e)), e.bindBuffer(e.ELEMENT_ARRAY_BUFFER, this._indexBuffer)), e.drawElements(e.TRIANGLE_STRIP, this.indices.length, e.UNSIGNED_SHORT, 0)
                    }, n.Strip.prototype._renderCanvas = function(t) {
                        var e = t.context,
                            i = this.worldTransform;
                        t.roundPixels ? e.setTransform(i.a, i.c, i.b, i.d, 0 | i.tx, 0 | i.ty) : e.setTransform(i.a, i.c, i.b, i.d, i.tx, i.ty);
                        var s = this,
                            n = s.verticies,
                            r = s.uvs,
                            o = n.length / 2;
                        this.count++;
                        for (var a = 0; o - 2 > a; a++) {
                            var h = 2 * a,
                                l = n[h],
                                c = n[h + 2],
                                u = n[h + 4],
                                d = n[h + 1],
                                p = n[h + 3],
                                f = n[h + 5],
                                g = (l + c + u) / 3,
                                m = (d + p + f) / 3,
                                y = l - g,
                                v = d - m,
                                x = Math.sqrt(y * y + v * v);
                            l = g + y / x * (x + 3), d = m + v / x * (x + 3), y = c - g, v = p - m, x = Math.sqrt(y * y + v * v), c = g + y / x * (x + 3), p = m + v / x * (x + 3), y = u - g, v = f - m, x = Math.sqrt(y * y + v * v), u = g + y / x * (x + 3), f = m + v / x * (x + 3);
                            var b = r[h] * s.texture.width,
                                _ = r[h + 2] * s.texture.width,
                                w = r[h + 4] * s.texture.width,
                                P = r[h + 1] * s.texture.height,
                                T = r[h + 3] * s.texture.height,
                                S = r[h + 5] * s.texture.height;
                            e.save(), e.beginPath(), e.moveTo(l, d), e.lineTo(c, p), e.lineTo(u, f), e.closePath(), e.clip();
                            var C = b * T + P * w + _ * S - T * w - P * _ - b * S,
                                A = l * T + P * u + c * S - T * u - P * c - l * S,
                                E = b * c + l * w + _ * u - c * w - l * _ - b * u,
                                M = b * T * u + P * c * w + l * _ * S - l * T * w - P * _ * u - b * c * S,
                                L = d * T + P * f + p * S - T * f - P * p - d * S,
                                R = b * p + d * w + _ * f - p * w - d * _ - b * f,
                                B = b * T * f + P * p * w + d * _ * S - d * T * w - P * _ * f - b * p * S;
                            e.transform(A / C, L / C, E / C, R / C, M / C, B / C), e.drawImage(s.texture.baseTexture.source, 0, 0), e.restore()
                        }
                    }, n.Strip.prototype.onTextureUpdate = function() {
                        this.updateFrame = !0
                    }, n.Rope = function(t, e) {
                        n.Strip.call(this, t), this.points = e, this.verticies = new n.Float32Array(4 * e.length), this.uvs = new n.Float32Array(4 * e.length), this.colors = new n.Float32Array(2 * e.length), this.indices = new n.Uint16Array(2 * e.length), this.refresh()
                    }, n.Rope.prototype = Object.create(n.Strip.prototype), n.Rope.prototype.constructor = n.Rope, n.Rope.prototype.refresh = function() {
                        var t = this.points;
                        if (!(t.length < 1)) {
                            var e = this.uvs,
                                i = t[0],
                                s = this.indices,
                                n = this.colors;
                            this.count -= .2, e[0] = 0, e[1] = 0, e[2] = 0, e[3] = 1, n[0] = 1, n[1] = 1, s[0] = 0, s[1] = 1;
                            for (var r, o, a, h = t.length, l = 1; h > l; l++) r = t[l], o = 4 * l, a = l / (h - 1), l % 2 ? (e[o] = a, e[o + 1] = 0, e[o + 2] = a, e[o + 3] = 1) : (e[o] = a, e[o + 1] = 0, e[o + 2] = a, e[o + 3] = 1), o = 2 * l, n[o] = 1, n[o + 1] = 1, o = 2 * l, s[o] = o, s[o + 1] = o + 1, i = r
                        }
                    }, n.Rope.prototype.updateTransform = function() {
                        var t = this.points;
                        if (!(t.length < 1)) {
                            var e, i = t[0],
                                s = {
                                    x: 0,
                                    y: 0
                                };
                            this.count -= .2;
                            for (var r, o, a, h, l, c = this.verticies, u = t.length, d = 0; u > d; d++) r = t[d], o = 4 * d, e = d < t.length - 1 ? t[d + 1] : r, s.y = -(e.x - i.x), s.x = e.y - i.y, a = 10 * (1 - d / (u - 1)), a > 1 && (a = 1), h = Math.sqrt(s.x * s.x + s.y * s.y), l = this.texture.height / 2, s.x /= h, s.y /= h, s.x *= l, s.y *= l, c[o] = r.x + s.x, c[o + 1] = r.y + s.y, c[o + 2] = r.x - s.x, c[o + 3] = r.y - s.y, i = r;
                            n.DisplayObjectContainer.prototype.updateTransform.call(this)
                        }
                    }, n.Rope.prototype.setTexture = function(t) {
                        this.texture = t
                    }, n.TilingSprite = function(t, e, i) {
                        n.Sprite.call(this, t), this._width = e || 100, this._height = i || 100, this.tileScale = new n.Point(1, 1), this.tileScaleOffset = new n.Point(1, 1), this.tilePosition = new n.Point(0, 0), this.renderable = !0, this.tint = 16777215, this.blendMode = n.blendModes.NORMAL
                    }, n.TilingSprite.prototype = Object.create(n.Sprite.prototype), n.TilingSprite.prototype.constructor = n.TilingSprite, Object.defineProperty(n.TilingSprite.prototype, "width", {
                        get: function() {
                            return this._width
                        },
                        set: function(t) {
                            this._width = t
                        }
                    }), Object.defineProperty(n.TilingSprite.prototype, "height", {
                        get: function() {
                            return this._height
                        },
                        set: function(t) {
                            this._height = t
                        }
                    }), n.TilingSprite.prototype.setTexture = function(t) {
                        this.texture !== t && (this.texture = t, this.refreshTexture = !0, this.cachedTint = 16777215)
                    }, n.TilingSprite.prototype._renderWebGL = function(t) {
                        if (this.visible !== !1 && 0 !== this.alpha) {
                            var e, i;
                            for (this._mask && (t.spriteBatch.stop(), t.maskManager.pushMask(this.mask, t), t.spriteBatch.start()), this._filters && (t.spriteBatch.flush(), t.filterManager.pushFilter(this._filterBlock)), !this.tilingTexture || this.refreshTexture ? (this.generateTilingTexture(!0), this.tilingTexture && this.tilingTexture.needsUpdate && (n.updateWebGLTexture(this.tilingTexture.baseTexture, t.gl), this.tilingTexture.needsUpdate = !1)) : t.spriteBatch.renderTilingSprite(this), e = 0, i = this.children.length; i > e; e++) this.children[e]._renderWebGL(t);
                            t.spriteBatch.stop(), this._filters && t.filterManager.popFilter(), this._mask && t.maskManager.popMask(t), t.spriteBatch.start()
                        }
                    }, n.TilingSprite.prototype._renderCanvas = function(t) {
                        if (this.visible !== !1 && 0 !== this.alpha) {
                            var e = t.context;
                            this._mask && t.maskManager.pushMask(this._mask, e), e.globalAlpha = this.worldAlpha;
                            var i, s, r = this.worldTransform;
                            if (e.setTransform(r.a, r.c, r.b, r.d, r.tx, r.ty), !this.__tilePattern || this.refreshTexture) {
                                if (this.generateTilingTexture(!1), !this.tilingTexture) return;
                                this.__tilePattern = e.createPattern(this.tilingTexture.baseTexture.source, "repeat")
                            }
                            this.blendMode !== t.currentBlendMode && (t.currentBlendMode = this.blendMode, e.globalCompositeOperation = n.blendModesCanvas[t.currentBlendMode]);
                            var o = this.tilePosition,
                                a = this.tileScale;
                            for (o.x %= this.tilingTexture.baseTexture.width, o.y %= this.tilingTexture.baseTexture.height, e.scale(a.x, a.y), e.translate(o.x, o.y), e.fillStyle = this.__tilePattern, e.fillRect(-o.x + this.anchor.x * -this._width, -o.y + this.anchor.y * -this._height, this._width / a.x, this._height / a.y), e.scale(1 / a.x, 1 / a.y), e.translate(-o.x, -o.y), this._mask && t.maskManager.popMask(t.context), i = 0, s = this.children.length; s > i; i++) this.children[i]._renderCanvas(t)
                        }
                    }, n.TilingSprite.prototype.getBounds = function() {
                        var t = this._width,
                            e = this._height,
                            i = t * (1 - this.anchor.x),
                            s = t * -this.anchor.x,
                            n = e * (1 - this.anchor.y),
                            r = e * -this.anchor.y,
                            o = this.worldTransform,
                            a = o.a,
                            h = o.c,
                            l = o.b,
                            c = o.d,
                            u = o.tx,
                            d = o.ty,
                            p = a * s + l * r + u,
                            f = c * r + h * s + d,
                            g = a * i + l * r + u,
                            m = c * r + h * i + d,
                            y = a * i + l * n + u,
                            v = c * n + h * i + d,
                            x = a * s + l * n + u,
                            b = c * n + h * s + d,
                            _ = -1 / 0,
                            w = -1 / 0,
                            P = 1 / 0,
                            T = 1 / 0;
                        P = P > p ? p : P, P = P > g ? g : P, P = P > y ? y : P, P = P > x ? x : P, T = T > f ? f : T, T = T > m ? m : T, T = T > v ? v : T, T = T > b ? b : T, _ = p > _ ? p : _, _ = g > _ ? g : _, _ = y > _ ? y : _, _ = x > _ ? x : _, w = f > w ? f : w, w = m > w ? m : w, w = v > w ? v : w, w = b > w ? b : w;
                        var S = this._bounds;
                        return S.x = P, S.width = _ - P, S.y = T, S.height = w - T, this._currentBounds = S, S
                    }, n.TilingSprite.prototype.onTextureUpdate = function() {}, n.TilingSprite.prototype.generateTilingTexture = function(t) {
                        if (this.texture.baseTexture.hasLoaded) {
                            var e, i, s = this.texture,
                                r = s.frame,
                                o = r.width !== s.baseTexture.width || r.height !== s.baseTexture.height,
                                a = !1;
                            if (t ? (e = n.getNextPowerOfTwo(r.width), i = n.getNextPowerOfTwo(r.height), (r.width !== e || r.height !== i) && (a = !0)) : o && (e = r.width, i = r.height, a = !0), a) {
                                var h;
                                this.tilingTexture && this.tilingTexture.isTiling ? (h = this.tilingTexture.canvasBuffer, h.resize(e, i), this.tilingTexture.baseTexture.width = e, this.tilingTexture.baseTexture.height = i, this.tilingTexture.needsUpdate = !0) : (h = new n.CanvasBuffer(e, i), this.tilingTexture = n.Texture.fromCanvas(h.canvas), this.tilingTexture.canvasBuffer = h, this.tilingTexture.isTiling = !0), h.context.drawImage(s.baseTexture.source, s.crop.x, s.crop.y, s.crop.width, s.crop.height, 0, 0, e, i), this.tileScaleOffset.x = r.width / e, this.tileScaleOffset.y = r.height / i
                            } else this.tilingTexture && this.tilingTexture.isTiling && this.tilingTexture.destroy(!0), this.tileScaleOffset.x = 1, this.tileScaleOffset.y = 1, this.tilingTexture = s;
                            this.refreshTexture = !1, this.tilingTexture.baseTexture._powerOf2 = !0
                        }
                    }, n.BaseTextureCache = {}, n.texturesToUpdate = [], n.texturesToDestroy = [], n.BaseTextureCacheIdGenerator = 0, n.BaseTexture = function(t, e) {
                        if (n.EventTarget.call(this), this.width = 100, this.height = 100, this.scaleMode = e || n.scaleModes.DEFAULT, this.hasLoaded = !1, this.source = t, this.id = n.BaseTextureCacheIdGenerator++, this.premultipliedAlpha = !0, this._glTextures = [], this._dirty = [], t) {
                            if ((this.source.complete || this.source.getContext) && this.source.width && this.source.height) this.hasLoaded = !0, this.width = this.source.width, this.height = this.source.height, n.texturesToUpdate.push(this);
                            else {
                                var i = this;
                                this.source.onload = function() {
                                    i.hasLoaded = !0, i.width = i.source.width, i.height = i.source.height;
                                    for (var t = 0; t < i._glTextures.length; t++) i._dirty[t] = !0;
                                    i.dispatchEvent({
                                        type: "loaded",
                                        content: i
                                    })
                                }, this.source.onerror = function() {
                                    i.dispatchEvent({
                                        type: "error",
                                        content: i
                                    })
                                }
                            }
                            this.imageUrl = null, this._powerOf2 = !1
                        }
                    }, n.BaseTexture.prototype.constructor = n.BaseTexture, n.BaseTexture.prototype.destroy = function() {
                        this.imageUrl ? (delete n.BaseTextureCache[this.imageUrl], delete n.TextureCache[this.imageUrl], this.imageUrl = null, this.source.src = null) : this.source && this.source._pixiId && delete n.BaseTextureCache[this.source._pixiId], this.source = null, n.texturesToDestroy.push(this)
                    }, n.BaseTexture.prototype.updateSourceImage = function(t) {
                        this.hasLoaded = !1, this.source.src = null, this.source.src = t
                    }, n.BaseTexture.fromImage = function(t, e, i) {
                        var s = n.BaseTextureCache[t];
                        if (void 0 === e && -1 === t.indexOf("data:") && (e = !0), !s) {
                            var r = new Image;
                            e && (r.crossOrigin = ""), r.src = t, s = new n.BaseTexture(r, i), s.imageUrl = t, n.BaseTextureCache[t] = s
                        }
                        return s
                    }, n.BaseTexture.fromCanvas = function(t, e) {
                        t._pixiId || (t._pixiId = "canvas_" + n.TextureCacheIdGenerator++);
                        var i = n.BaseTextureCache[t._pixiId];
                        return i || (i = new n.BaseTexture(t, e), n.BaseTextureCache[t._pixiId] = i), i
                    }, n.TextureCache = {}, n.FrameCache = {}, n.TextureCacheIdGenerator = 0, n.Texture = function(t, e) {
                        if (n.EventTarget.call(this), this.noFrame = !1, e || (this.noFrame = !0, e = new n.Rectangle(0, 0, 1, 1)), t instanceof n.Texture && (t = t.baseTexture), this.baseTexture = t, this.frame = e, this.trim = null, this.valid = !1, this.scope = this, this._uvs = null, this.width = 0, this.height = 0, this.crop = new n.Rectangle(0, 0, 1, 1), t.hasLoaded) this.noFrame && (e = new n.Rectangle(0, 0, t.width, t.height)), this.setFrame(e);
                        else {
                            var i = this;
                            t.addEventListener("loaded", function() {
                                i.onBaseTextureLoaded()
                            })
                        }
                    }, n.Texture.prototype.constructor = n.Texture, n.Texture.prototype.onBaseTextureLoaded = function() {
                        var t = this.baseTexture;
                        t.removeEventListener("loaded", this.onLoaded), this.noFrame && (this.frame = new n.Rectangle(0, 0, t.width, t.height)), this.setFrame(this.frame), this.scope.dispatchEvent({
                            type: "update",
                            content: this
                        })
                    }, n.Texture.prototype.destroy = function(t) {
                        t && this.baseTexture.destroy(), this.valid = !1
                    }, n.Texture.prototype.setFrame = function(t) {
                        if (this.noFrame = !1, this.frame = t, this.width = t.width, this.height = t.height, this.crop.x = t.x, this.crop.y = t.y, this.crop.width = t.width, this.crop.height = t.height, !this.trim && (t.x + t.width > this.baseTexture.width || t.y + t.height > this.baseTexture.height)) throw new Error("Texture Error: frame does not fit inside the base Texture dimensions " + this);
                        this.valid = t && t.width && t.height && this.baseTexture.source && this.baseTexture.hasLoaded, this.trim && (this.width = this.trim.width, this.height = this.trim.height, this.frame.width = this.trim.width, this.frame.height = this.trim.height), this.valid && n.Texture.frameUpdates.push(this)
                    }, n.Texture.prototype._updateWebGLuvs = function() {
                        this._uvs || (this._uvs = new n.TextureUvs);
                        var t = this.crop,
                            e = this.baseTexture.width,
                            i = this.baseTexture.height;
                        this._uvs.x0 = t.x / e, this._uvs.y0 = t.y / i, this._uvs.x1 = (t.x + t.width) / e, this._uvs.y1 = t.y / i, this._uvs.x2 = (t.x + t.width) / e, this._uvs.y2 = (t.y + t.height) / i, this._uvs.x3 = t.x / e, this._uvs.y3 = (t.y + t.height) / i
                    }, n.Texture.fromImage = function(t, e, i) {
                        var s = n.TextureCache[t];
                        return s || (s = new n.Texture(n.BaseTexture.fromImage(t, e, i)), n.TextureCache[t] = s), s
                    }, n.Texture.fromFrame = function(t) {
                        var e = n.TextureCache[t];
                        if (!e) throw new Error('The frameId "' + t + '" does not exist in the texture cache ');
                        return e
                    }, n.Texture.fromCanvas = function(t, e) {
                        var i = n.BaseTexture.fromCanvas(t, e);
                        return new n.Texture(i)
                    }, n.Texture.addTextureToCache = function(t, e) {
                        n.TextureCache[e] = t
                    }, n.Texture.removeTextureFromCache = function(t) {
                        var e = n.TextureCache[t];
                        return delete n.TextureCache[t], delete n.BaseTextureCache[t], e
                    }, n.Texture.frameUpdates = [], n.TextureUvs = function() {
                        this.x0 = 0, this.y0 = 0, this.x1 = 0, this.y1 = 0, this.x2 = 0, this.y2 = 0, this.x3 = 0, this.y3 = 0
                    }, n.RenderTexture = function(t, e, i, s) {
                        if (n.EventTarget.call(this), this.width = t || 100, this.height = e || 100, this.frame = new n.Rectangle(0, 0, this.width, this.height), this.crop = new n.Rectangle(0, 0, this.width, this.height), this.baseTexture = new n.BaseTexture, this.baseTexture.width = this.width, this.baseTexture.height = this.height, this.baseTexture._glTextures = [], this.baseTexture.scaleMode = s || n.scaleModes.DEFAULT, this.baseTexture.hasLoaded = !0, this.renderer = i || n.defaultRenderer, this.renderer.type === n.WEBGL_RENDERER) {
                            var r = this.renderer.gl;
                            this.textureBuffer = new n.FilterTexture(r, this.width, this.height, this.baseTexture.scaleMode), this.baseTexture._glTextures[r.id] = this.textureBuffer.texture, this.render = this.renderWebGL, this.projection = new n.Point(this.width / 2, -this.height / 2)
                        } else this.render = this.renderCanvas, this.textureBuffer = new n.CanvasBuffer(this.width, this.height), this.baseTexture.source = this.textureBuffer.canvas;
                        this.valid = !0, n.Texture.frameUpdates.push(this)
                    }, n.RenderTexture.prototype = Object.create(n.Texture.prototype), n.RenderTexture.prototype.constructor = n.RenderTexture, n.RenderTexture.prototype.resize = function(t, e, i) {
                        (t !== this.width || e !== this.height) && (this.width = this.frame.width = this.crop.width = t, this.height = this.frame.height = this.crop.height = e, i && (this.baseTexture.width = this.width, this.baseTexture.height = this.height), this.renderer.type === n.WEBGL_RENDERER && (this.projection.x = this.width / 2, this.projection.y = -this.height / 2), this.textureBuffer.resize(this.width, this.height))
                    }, n.RenderTexture.prototype.clear = function() {
                        this.renderer.type === n.WEBGL_RENDERER && this.renderer.gl.bindFramebuffer(this.renderer.gl.FRAMEBUFFER, this.textureBuffer.frameBuffer), this.textureBuffer.clear()
                    }, n.RenderTexture.prototype.renderWebGL = function(t, e, i) {
                        var s = this.renderer.gl;
                        s.colorMask(!0, !0, !0, !0), s.viewport(0, 0, this.width, this.height), s.bindFramebuffer(s.FRAMEBUFFER, this.textureBuffer.frameBuffer), i && this.textureBuffer.clear();
                        var r = t.children,
                            o = t.worldTransform;
                        t.worldTransform = n.RenderTexture.tempMatrix, t.worldTransform.d = -1, t.worldTransform.ty = -2 * this.projection.y, e && (t.worldTransform.tx = e.x, t.worldTransform.ty -= e.y);
                        for (var a = 0, h = r.length; h > a; a++) r[a].updateTransform();
                        n.WebGLRenderer.updateTextures(), this.renderer.spriteBatch.dirty = !0, this.renderer.renderDisplayObject(t, this.projection, this.textureBuffer.frameBuffer), t.worldTransform = o, this.renderer.spriteBatch.dirty = !0
                    }, n.RenderTexture.prototype.renderCanvas = function(t, e, i) {
                        var s = t.children,
                            r = t.worldTransform;
                        t.worldTransform = n.RenderTexture.tempMatrix, e ? (t.worldTransform.tx = e.x, t.worldTransform.ty = e.y) : (t.worldTransform.tx = 0, t.worldTransform.ty = 0);
                        for (var o = 0, a = s.length; a > o; o++) s[o].updateTransform();
                        i && this.textureBuffer.clear();
                        var h = this.textureBuffer.context;
                        this.renderer.renderDisplayObject(t, h), h.setTransform(1, 0, 0, 1, 0, 0), t.worldTransform = r
                    }, n.RenderTexture.tempMatrix = new n.Matrix, "undefined" != typeof e ? ("undefined" != typeof t && t.exports && (e = t.exports = n), e.PIXI = n) : "undefined" != typeof i && i.amd ? i("PIXI", function() {
                        return s.PIXI = n
                    }()) : s.PIXI = n
                }).call(this),
                    function() {
                        var s = this,
                            n = n || {
                                VERSION: "2.0.7",
                                GAMES: [],
                                AUTO: 0,
                                CANVAS: 1,
                                WEBGL: 2,
                                HEADLESS: 3,
                                NONE: 0,
                                LEFT: 1,
                                RIGHT: 2,
                                UP: 3,
                                DOWN: 4,
                                SPRITE: 0,
                                BUTTON: 1,
                                IMAGE: 2,
                                GRAPHICS: 3,
                                TEXT: 4,
                                TILESPRITE: 5,
                                BITMAPTEXT: 6,
                                GROUP: 7,
                                RENDERTEXTURE: 8,
                                TILEMAP: 9,
                                TILEMAPLAYER: 10,
                                EMITTER: 11,
                                POLYGON: 12,
                                BITMAPDATA: 13,
                                CANVAS_FILTER: 14,
                                WEBGL_FILTER: 15,
                                ELLIPSE: 16,
                                SPRITEBATCH: 17,
                                RETROFONT: 18,
                                POINTER: 19,
                                blendModes: {
                                    NORMAL: 0,
                                    ADD: 1,
                                    MULTIPLY: 2,
                                    SCREEN: 3,
                                    OVERLAY: 4,
                                    DARKEN: 5,
                                    LIGHTEN: 6,
                                    COLOR_DODGE: 7,
                                    COLOR_BURN: 8,
                                    HARD_LIGHT: 9,
                                    SOFT_LIGHT: 10,
                                    DIFFERENCE: 11,
                                    EXCLUSION: 12,
                                    HUE: 13,
                                    SATURATION: 14,
                                    COLOR: 15,
                                    LUMINOSITY: 16
                                },
                                scaleModes: {
                                    DEFAULT: 0,
                                    LINEAR: 0,
                                    NEAREST: 1
                                }
                            };
                        if (PIXI.InteractionManager = PIXI.InteractionManager || function() {}, PIXI.dontSayHello = !0, n.Utils = {
                                getProperty: function(t, e) {
                                    for (var i = e.split("."), s = i.pop(), n = i.length, r = 1, o = i[0]; n > r && (t = t[o]);) o = i[r], r++;
                                    return t ? t[s] : null
                                },
                                setProperty: function(t, e, i) {
                                    for (var s = e.split("."), n = s.pop(), r = s.length, o = 1, a = s[0]; r > o && (t = t[a]);) a = s[o], o++;
                                    return t && (t[n] = i), t
                                },
                                transposeArray: function(t) {
                                    for (var e = new Array(t[0].length), i = 0; i < t[0].length; i++) {
                                        e[i] = new Array(t.length - 1);
                                        for (var s = t.length - 1; s > -1; s--) e[i][s] = t[s][i]
                                    }
                                    return e
                                },
                                rotateArray: function(t, e) {
                                    if ("string" != typeof e && (e = (e % 360 + 360) % 360), 90 === e || -270 === e || "rotateLeft" === e) t = n.Utils.transposeArray(t), t = t.reverse();
                                    else if (-90 === e || 270 === e || "rotateRight" === e) t = t.reverse(), t = n.Utils.transposeArray(t);
                                    else if (180 === Math.abs(e) || "rotate180" === e) {
                                        for (var i = 0; i < t.length; i++) t[i].reverse();
                                        t = t.reverse()
                                    }
                                    return t
                                },
                                parseDimension: function(t, e) {
                                    var i = 0,
                                        s = 0;
                                    return "string" == typeof t ? "%" === t.substr(-1) ? (i = parseInt(t, 10) / 100, s = 0 === e ? window.innerWidth * i : window.innerHeight * i) : s = parseInt(t, 10) : s = t, s
                                },
                                shuffle: function(t) {
                                    for (var e = t.length - 1; e > 0; e--) {
                                        var i = Math.floor(Math.random() * (e + 1)),
                                            s = t[e];
                                        t[e] = t[i], t[i] = s
                                    }
                                    return t
                                },
                                pad: function(t, e, i, s) {
                                    if ("undefined" == typeof e) var e = 0;
                                    if ("undefined" == typeof i) var i = " ";
                                    if ("undefined" == typeof s) var s = 3;
                                    var n = 0;
                                    if (e + 1 >= t.length) switch (s) {
                                        case 1:
                                            t = new Array(e + 1 - t.length).join(i) + t;
                                            break;
                                        case 3:
                                            var r = Math.ceil((n = e - t.length) / 2),
                                                o = n - r;
                                            t = new Array(o + 1).join(i) + t + new Array(r + 1).join(i);
                                            break;
                                        default:
                                            t += new Array(e + 1 - t.length).join(i)
                                    }
                                    return t
                                },
                                isPlainObject: function(t) {
                                    if ("object" != typeof t || t.nodeType || t === t.window) return !1;
                                    try {
                                        if (t.constructor && !{}.hasOwnProperty.call(t.constructor.prototype, "isPrototypeOf")) return !1
                                    } catch (e) {
                                        return !1
                                    }
                                    return !0
                                },
                                extend: function() {
                                    var t, e, i, s, r, o, a = arguments[0] || {},
                                        h = 1,
                                        l = arguments.length,
                                        c = !1;
                                    for ("boolean" == typeof a && (c = a, a = arguments[1] || {}, h = 2), l === h && (a = this, --h); l > h; h++)
                                        if (null != (t = arguments[h]))
                                            for (e in t) i = a[e], s = t[e], a !== s && (c && s && (n.Utils.isPlainObject(s) || (r = Array.isArray(s))) ? (r ? (r = !1, o = i && Array.isArray(i) ? i : []) : o = i && n.Utils.isPlainObject(i) ? i : {}, a[e] = n.Utils.extend(c, o, s)) : void 0 !== s && (a[e] = s));
                                    return a
                                },
                                mixin: function(t, e) {
                                    if (!t || "object" != typeof t) return e;
                                    for (var i in t) {
                                        var s = t[i];
                                        if (!s.childNodes && !s.cloneNode) {
                                            var r = typeof t[i];
                                            e[i] = t[i] && "object" === r ? typeof e[i] === r ? n.Utils.mixin(t[i], e[i]) : n.Utils.mixin(t[i], new s.constructor) : t[i]
                                        }
                                    }
                                    return e
                                }
                            }, "function" != typeof Function.prototype.bind && (Function.prototype.bind = function() {
                                var t = Array.prototype.slice;
                                return function(e) {
                                    function i() {
                                        var r = n.concat(t.call(arguments));
                                        s.apply(this instanceof i ? this : e, r)
                                    }
                                    var s = this,
                                        n = t.call(arguments, 1);
                                    if ("function" != typeof s) throw new TypeError;
                                    return i.prototype = function r(t) {
                                        return t && (r.prototype = t), this instanceof r ? void 0 : new r
                                    }(s.prototype), i
                                }
                            }()), Array.isArray || (Array.isArray = function(t) {
                                return "[object Array]" == Object.prototype.toString.call(t)
                            }), Array.prototype.forEach || (Array.prototype.forEach = function(t) {
                                "use strict";
                                if (void 0 === this || null === this) throw new TypeError;
                                var e = Object(this),
                                    i = e.length >>> 0;
                                if ("function" != typeof t) throw new TypeError;
                                for (var s = arguments.length >= 2 ? arguments[1] : void 0, n = 0; i > n; n++) n in e && t.call(s, e[n], n, e)
                            }), "function" != typeof window.Uint32Array) {
                            var r = function(t) {
                                var e = new Array;
                                window[t] = function(t) {
                                    if ("number" == typeof t) {
                                        Array.call(this, t), this.length = t;
                                        for (var e = 0; e < this.length; e++) this[e] = 0
                                    } else {
                                        Array.call(this, t.length), this.length = t.length;
                                        for (var e = 0; e < this.length; e++) this[e] = t[e]
                                    }
                                }, window[t].prototype = e, window[t].constructor = window[t]
                            };
                            r("Uint32Array"), r("Int16Array")
                        }
                        window.console || (window.console = {}, window.console.log = window.console.assert = function() {}, window.console.warn = window.console.assert = function() {}), n.Circle = function(t, e, i) {
                            t = t || 0, e = e || 0, i = i || 0, this.x = t, this.y = e, this._diameter = i, this._radius = i > 0 ? .5 * i : 0
                        }, n.Circle.prototype = {
                            circumference: function() {
                                return 2 * Math.PI * this._radius
                            },
                            setTo: function(t, e, i) {
                                return this.x = t, this.y = e, this._diameter = i, this._radius = .5 * i, this
                            },
                            copyFrom: function(t) {
                                return this.setTo(t.x, t.y, t.diameter)
                            },
                            copyTo: function(t) {
                                return t.x = this.x, t.y = this.y, t.diameter = this._diameter, t
                            },
                            distance: function(t, e) {
                                return "undefined" == typeof e && (e = !1), e ? n.Math.distanceRounded(this.x, this.y, t.x, t.y) : n.Math.distance(this.x, this.y, t.x, t.y)
                            },
                            clone: function(t) {
                                return "undefined" == typeof t ? t = new n.Circle(this.x, this.y, this.diameter) : t.setTo(this.x, this.y, this.diameter), t
                            },
                            contains: function(t, e) {
                                return n.Circle.contains(this, t, e)
                            },
                            circumferencePoint: function(t, e, i) {
                                return n.Circle.circumferencePoint(this, t, e, i)
                            },
                            offset: function(t, e) {
                                return this.x += t, this.y += e, this
                            },
                            offsetPoint: function(t) {
                                return this.offset(t.x, t.y)
                            },
                            toString: function() {
                                return "[{Phaser.Circle (x=" + this.x + " y=" + this.y + " diameter=" + this.diameter + " radius=" + this.radius + ")}]"
                            }
                        }, n.Circle.prototype.constructor = n.Circle, Object.defineProperty(n.Circle.prototype, "diameter", {
                            get: function() {
                                return this._diameter
                            },
                            set: function(t) {
                                t > 0 && (this._diameter = t, this._radius = .5 * t)
                            }
                        }), Object.defineProperty(n.Circle.prototype, "radius", {
                            get: function() {
                                return this._radius
                            },
                            set: function(t) {
                                t > 0 && (this._radius = t, this._diameter = 2 * t)
                            }
                        }), Object.defineProperty(n.Circle.prototype, "left", {
                            get: function() {
                                return this.x - this._radius
                            },
                            set: function(t) {
                                t > this.x ? (this._radius = 0, this._diameter = 0) : this.radius = this.x - t
                            }
                        }), Object.defineProperty(n.Circle.prototype, "right", {
                            get: function() {
                                return this.x + this._radius
                            },
                            set: function(t) {
                                t < this.x ? (this._radius = 0, this._diameter = 0) : this.radius = t - this.x
                            }
                        }), Object.defineProperty(n.Circle.prototype, "top", {
                            get: function() {
                                return this.y - this._radius
                            },
                            set: function(t) {
                                t > this.y ? (this._radius = 0, this._diameter = 0) : this.radius = this.y - t
                            }
                        }), Object.defineProperty(n.Circle.prototype, "bottom", {
                            get: function() {
                                return this.y + this._radius
                            },
                            set: function(t) {
                                t < this.y ? (this._radius = 0, this._diameter = 0) : this.radius = t - this.y
                            }
                        }), Object.defineProperty(n.Circle.prototype, "area", {
                            get: function() {
                                return this._radius > 0 ? Math.PI * this._radius * this._radius : 0
                            }
                        }), Object.defineProperty(n.Circle.prototype, "empty", {
                            get: function() {
                                return 0 === this._diameter
                            },
                            set: function(t) {
                                t === !0 && this.setTo(0, 0, 0)
                            }
                        }), n.Circle.contains = function(t, e, i) {
                            if (t.radius > 0 && e >= t.left && e <= t.right && i >= t.top && i <= t.bottom) {
                                var s = (t.x - e) * (t.x - e),
                                    n = (t.y - i) * (t.y - i);
                                return s + n <= t.radius * t.radius
                            }
                            return !1
                        }, n.Circle.equals = function(t, e) {
                            return t.x == e.x && t.y == e.y && t.diameter == e.diameter
                        }, n.Circle.intersects = function(t, e) {
                            return n.Math.distance(t.x, t.y, e.x, e.y) <= t.radius + e.radius
                        }, n.Circle.circumferencePoint = function(t, e, i, s) {
                            return "undefined" == typeof i && (i = !1), "undefined" == typeof s && (s = new n.Point), i === !0 && (e = n.Math.degToRad(e)), s.x = t.x + t.radius * Math.cos(e), s.y = t.y + t.radius * Math.sin(e), s
                        }, n.Circle.intersectsRectangle = function(t, e) {
                            var i = Math.abs(t.x - e.x - e.halfWidth),
                                s = e.halfWidth + t.radius;
                            if (i > s) return !1;
                            var n = Math.abs(t.y - e.y - e.halfHeight),
                                r = e.halfHeight + t.radius;
                            if (n > r) return !1;
                            if (i <= e.halfWidth || n <= e.halfHeight) return !0;
                            var o = i - e.halfWidth,
                                a = n - e.halfHeight,
                                h = o * o,
                                l = a * a,
                                c = t.radius * t.radius;
                            return c >= h + l
                        }, PIXI.Circle = n.Circle, n.Point = function(t, e) {
                            t = t || 0, e = e || 0, this.x = t, this.y = e
                        }, n.Point.prototype = {
                            copyFrom: function(t) {
                                return this.setTo(t.x, t.y)
                            },
                            invert: function() {
                                return this.setTo(this.y, this.x)
                            },
                            setTo: function(t, e) {
                                return this.x = t || 0, this.y = e || (0 !== e ? this.x : 0), this
                            },
                            set: function(t, e) {
                                return this.x = t || 0, this.y = e || (0 !== e ? this.x : 0), this
                            },
                            add: function(t, e) {
                                return this.x += t, this.y += e, this
                            },
                            subtract: function(t, e) {
                                return this.x -= t, this.y -= e, this
                            },
                            multiply: function(t, e) {
                                return this.x *= t, this.y *= e, this
                            },
                            divide: function(t, e) {
                                return this.x /= t, this.y /= e, this
                            },
                            clampX: function(t, e) {
                                return this.x = n.Math.clamp(this.x, t, e), this
                            },
                            clampY: function(t, e) {
                                return this.y = n.Math.clamp(this.y, t, e), this
                            },
                            clamp: function(t, e) {
                                return this.x = n.Math.clamp(this.x, t, e), this.y = n.Math.clamp(this.y, t, e), this
                            },
                            clone: function(t) {
                                return "undefined" == typeof t ? t = new n.Point(this.x, this.y) : t.setTo(this.x, this.y), t
                            },
                            copyTo: function(t) {
                                return t.x = this.x, t.y = this.y, t
                            },
                            distance: function(t, e) {
                                return n.Point.distance(this, t, e)
                            },
                            equals: function(t) {
                                return t.x === this.x && t.y === this.y
                            },
                            angle: function(t, e) {
                                return "undefined" == typeof e && (e = !1), e ? n.Math.radToDeg(Math.atan2(t.y - this.y, t.x - this.x)) : Math.atan2(t.y - this.y, t.x - this.x)
                            },
                            angleSq: function(t) {
                                return this.subtract(t).angle(t.subtract(this))
                            },
                            rotate: function(t, e, i, s, r) {
                                return n.Point.rotate(this, t, e, i, s, r)
                            },
                            getMagnitude: function() {
                                return Math.sqrt(this.x * this.x + this.y * this.y)
                            },
                            getMagnitudeSq: function() {
                                return this.x * this.x + this.y * this.y
                            },
                            setMagnitude: function(t) {
                                return this.normalize().multiply(t, t)
                            },
                            normalize: function() {
                                if (!this.isZero()) {
                                    var t = this.getMagnitude();
                                    this.x /= t, this.y /= t
                                }
                                return this
                            },
                            isZero: function() {
                                return 0 === this.x && 0 === this.y
                            },
                            dot: function(t) {
                                return this.x * t.x + this.y * t.y
                            },
                            cross: function(t) {
                                return this.x * t.y - this.y * t.x
                            },
                            perp: function() {
                                return this.setTo(-this.y, this.x)
                            },
                            rperp: function() {
                                return this.setTo(this.y, -this.x)
                            },
                            normalRightHand: function() {
                                return this.setTo(-1 * this.y, this.x)
                            },
                            toString: function() {
                                return "[{Point (x=" + this.x + " y=" + this.y + ")}]"
                            }
                        }, n.Point.prototype.constructor = n.Point, n.Point.add = function(t, e, i) {
                            return "undefined" == typeof i && (i = new n.Point), i.x = t.x + e.x, i.y = t.y + e.y, i
                        }, n.Point.subtract = function(t, e, i) {
                            return "undefined" == typeof i && (i = new n.Point), i.x = t.x - e.x, i.y = t.y - e.y, i
                        }, n.Point.multiply = function(t, e, i) {
                            return "undefined" == typeof i && (i = new n.Point), i.x = t.x * e.x, i.y = t.y * e.y, i
                        }, n.Point.divide = function(t, e, i) {
                            return "undefined" == typeof i && (i = new n.Point), i.x = t.x / e.x, i.y = t.y / e.y, i
                        }, n.Point.equals = function(t, e) {
                            return t.x === e.x && t.y === e.y
                        }, n.Point.angle = function(t, e) {
                            return Math.atan2(t.y - e.y, t.x - e.x)
                        }, n.Point.angleSq = function(t, e) {
                            return t.subtract(e).angle(e.subtract(t))
                        }, n.Point.negative = function(t, e) {
                            return "undefined" == typeof e && (e = new n.Point), e.setTo(-t.x, -t.y)
                        }, n.Point.multiplyAdd = function(t, e, i, s) {
                            return "undefined" == typeof s && (s = new n.Point), s.setTo(t.x + e.x * i, t.y + e.y * i)
                        }, n.Point.interpolate = function(t, e, i, s) {
                            return "undefined" == typeof s && (s = new n.Point), s.setTo(t.x + (e.x - t.x) * i, t.y + (e.y - t.y) * i)
                        }, n.Point.perp = function(t, e) {
                            return "undefined" == typeof e && (e = new n.Point), e.setTo(-t.y, t.x)
                        }, n.Point.rperp = function(t, e) {
                            return "undefined" == typeof e && (e = new n.Point), e.setTo(t.y, -t.x)
                        }, n.Point.distance = function(t, e, i) {
                            return "undefined" == typeof i && (i = !1), i ? n.Math.distanceRounded(t.x, t.y, e.x, e.y) : n.Math.distance(t.x, t.y, e.x, e.y)
                        }, n.Point.project = function(t, e, i) {
                            "undefined" == typeof i && (i = new n.Point);
                            var s = t.dot(e) / e.getMagnitudeSq();
                            return 0 !== s && i.setTo(s * e.x, s * e.y), i
                        }, n.Point.projectUnit = function(t, e, i) {
                            "undefined" == typeof i && (i = new n.Point);
                            var s = t.dot(e);
                            return 0 !== s && i.setTo(s * e.x, s * e.y), i
                        }, n.Point.normalRightHand = function(t, e) {
                            return "undefined" == typeof e && (e = new n.Point), e.setTo(-1 * t.y, t.x)
                        }, n.Point.normalize = function(t, e) {
                            "undefined" == typeof e && (e = new n.Point);
                            var i = t.getMagnitude();
                            return 0 !== i && e.setTo(t.x / i, t.y / i), e
                        }, n.Point.rotate = function(t, e, i, s, r, o) {
                            return r = r || !1, o = o || null, r && (s = n.Math.degToRad(s)), null === o && (o = Math.sqrt((e - t.x) * (e - t.x) + (i - t.y) * (i - t.y))), t.setTo(e + o * Math.cos(s), i + o * Math.sin(s))
                        }, n.Point.centroid = function(t, e) {
                            if ("undefined" == typeof e && (e = new n.Point), "[object Array]" !== Object.prototype.toString.call(t)) throw new Error("Phaser.Point. Parameter 'points' must be an array");
                            var i = t.length;
                            if (1 > i) throw new Error("Phaser.Point. Parameter 'points' array must not be empty");
                            if (1 === i) return e.copyFrom(t[0]), e;
                            for (var s = 0; i > s; s++) n.Point.add(e, t[s], e);
                            return e.divide(i, i), e
                        }, PIXI.Point = n.Point, n.Rectangle = function(t, e, i, s) {
                            t = t || 0, e = e || 0, i = i || 0, s = s || 0, this.x = t, this.y = e, this.width = i, this.height = s
                        }, n.Rectangle.prototype = {
                            offset: function(t, e) {
                                return this.x += t, this.y += e, this
                            },
                            offsetPoint: function(t) {
                                return this.offset(t.x, t.y)
                            },
                            setTo: function(t, e, i, s) {
                                return this.x = t, this.y = e, this.width = i, this.height = s, this
                            },
                            floor: function() {
                                this.x = Math.floor(this.x), this.y = Math.floor(this.y)
                            },
                            floorAll: function() {
                                this.x = Math.floor(this.x), this.y = Math.floor(this.y), this.width = Math.floor(this.width), this.height = Math.floor(this.height)
                            },
                            copyFrom: function(t) {
                                return this.setTo(t.x, t.y, t.width, t.height)
                            },
                            copyTo: function(t) {
                                return t.x = this.x, t.y = this.y, t.width = this.width, t.height = this.height, t
                            },
                            inflate: function(t, e) {
                                return n.Rectangle.inflate(this, t, e)
                            },
                            size: function(t) {
                                return n.Rectangle.size(this, t)
                            },
                            clone: function(t) {
                                return n.Rectangle.clone(this, t)
                            },
                            contains: function(t, e) {
                                return n.Rectangle.contains(this, t, e)
                            },
                            containsRect: function(t) {
                                return n.Rectangle.containsRect(this, t)
                            },
                            equals: function(t) {
                                return n.Rectangle.equals(this, t)
                            },
                            intersection: function(t, e) {
                                return n.Rectangle.intersection(this, t, e)
                            },
                            intersects: function(t, e) {
                                return n.Rectangle.intersects(this, t, e)
                            },
                            intersectsRaw: function(t, e, i, s, r) {
                                return n.Rectangle.intersectsRaw(this, t, e, i, s, r)
                            },
                            union: function(t, e) {
                                return n.Rectangle.union(this, t, e)
                            },
                            toString: function() {
                                return "[{Rectangle (x=" + this.x + " y=" + this.y + " width=" + this.width + " height=" + this.height + " empty=" + this.empty + ")}]"
                            }
                        }, Object.defineProperty(n.Rectangle.prototype, "halfWidth", {
                            get: function() {
                                return Math.round(this.width / 2)
                            }
                        }), Object.defineProperty(n.Rectangle.prototype, "halfHeight", {
                            get: function() {
                                return Math.round(this.height / 2)
                            }
                        }), Object.defineProperty(n.Rectangle.prototype, "bottom", {
                            get: function() {
                                return this.y + this.height
                            },
                            set: function(t) {
                                this.height = t <= this.y ? 0 : this.y - t
                            }
                        }), Object.defineProperty(n.Rectangle.prototype, "bottomRight", {
                            get: function() {
                                return new n.Point(this.right, this.bottom)
                            },
                            set: function(t) {
                                this.right = t.x, this.bottom = t.y
                            }
                        }), Object.defineProperty(n.Rectangle.prototype, "left", {
                            get: function() {
                                return this.x
                            },
                            set: function(t) {
                                this.width = t >= this.right ? 0 : this.right - t, this.x = t
                            }
                        }), Object.defineProperty(n.Rectangle.prototype, "right", {
                            get: function() {
                                return this.x + this.width
                            },
                            set: function(t) {
                                this.width = t <= this.x ? 0 : t - this.x
                            }
                        }), Object.defineProperty(n.Rectangle.prototype, "volume", {
                            get: function() {
                                return this.width * this.height
                            }
                        }), Object.defineProperty(n.Rectangle.prototype, "perimeter", {
                            get: function() {
                                return 2 * this.width + 2 * this.height
                            }
                        }), Object.defineProperty(n.Rectangle.prototype, "centerX", {
                            get: function() {
                                return this.x + this.halfWidth
                            },
                            set: function(t) {
                                this.x = t - this.halfWidth
                            }
                        }), Object.defineProperty(n.Rectangle.prototype, "centerY", {
                            get: function() {
                                return this.y + this.halfHeight
                            },
                            set: function(t) {
                                this.y = t - this.halfHeight
                            }
                        }), Object.defineProperty(n.Rectangle.prototype, "randomX", {
                            get: function() {
                                return this.x + Math.random() * this.width
                            }
                        }), Object.defineProperty(n.Rectangle.prototype, "randomY", {
                            get: function() {
                                return this.y + Math.random() * this.height
                            }
                        }), Object.defineProperty(n.Rectangle.prototype, "top", {
                            get: function() {
                                return this.y
                            },
                            set: function(t) {
                                t >= this.bottom ? (this.height = 0, this.y = t) : this.height = this.bottom - t
                            }
                        }), Object.defineProperty(n.Rectangle.prototype, "topLeft", {
                            get: function() {
                                return new n.Point(this.x, this.y)
                            },
                            set: function(t) {
                                this.x = t.x, this.y = t.y
                            }
                        }), Object.defineProperty(n.Rectangle.prototype, "empty", {
                            get: function() {
                                return !this.width || !this.height
                            },
                            set: function(t) {
                                t === !0 && this.setTo(0, 0, 0, 0)
                            }
                        }), n.Rectangle.prototype.constructor = n.Rectangle, n.Rectangle.inflate = function(t, e, i) {
                            return t.x -= e, t.width += 2 * e, t.y -= i, t.height += 2 * i, t
                        }, n.Rectangle.inflatePoint = function(t, e) {
                            return n.Rectangle.inflate(t, e.x, e.y)
                        }, n.Rectangle.size = function(t, e) {
                            return "undefined" == typeof e || null === e ? e = new n.Point(t.width, t.height) : e.setTo(t.width, t.height), e
                        }, n.Rectangle.clone = function(t, e) {
                            return "undefined" == typeof e || null === e ? e = new n.Rectangle(t.x, t.y, t.width, t.height) : e.setTo(t.x, t.y, t.width, t.height), e
                        }, n.Rectangle.contains = function(t, e, i) {
                            return t.width <= 0 || t.height <= 0 ? !1 : e >= t.x && e <= t.right && i >= t.y && i <= t.bottom
                        }, n.Rectangle.containsRaw = function(t, e, i, s, n, r) {
                            return n >= t && t + i >= n && r >= e && e + s >= r
                        }, n.Rectangle.containsPoint = function(t, e) {
                            return n.Rectangle.contains(t, e.x, e.y)
                        }, n.Rectangle.containsRect = function(t, e) {
                            return t.volume > e.volume ? !1 : t.x >= e.x && t.y >= e.y && t.right <= e.right && t.bottom <= e.bottom
                        }, n.Rectangle.equals = function(t, e) {
                            return t.x == e.x && t.y == e.y && t.width == e.width && t.height == e.height
                        }, n.Rectangle.intersection = function(t, e, i) {
                            return "undefined" == typeof i && (i = new n.Rectangle), n.Rectangle.intersects(t, e) && (i.x = Math.max(t.x, e.x), i.y = Math.max(t.y, e.y), i.width = Math.min(t.right, e.right) - i.x, i.height = Math.min(t.bottom, e.bottom) - i.y), i
                        }, n.Rectangle.intersects = function(t, e) {
                            return t.width <= 0 || t.height <= 0 || e.width <= 0 || e.height <= 0 ? !1 : !(t.right < e.x || t.bottom < e.y || t.x > e.right || t.y > e.bottom)
                        }, n.Rectangle.intersectsRaw = function(t, e, i, s, n, r) {
                            return "undefined" == typeof r && (r = 0), !(e > t.right + r || i < t.left - r || s > t.bottom + r || n < t.top - r)
                        }, n.Rectangle.union = function(t, e, i) {
                            return "undefined" == typeof i && (i = new n.Rectangle), i.setTo(Math.min(t.x, e.x), Math.min(t.y, e.y), Math.max(t.right, e.right) - Math.min(t.left, e.left), Math.max(t.bottom, e.bottom) - Math.min(t.top, e.top))
                        }, PIXI.Rectangle = n.Rectangle, PIXI.EmptyRectangle = new n.Rectangle(0, 0, 0, 0), n.Line = function(t, e, i, s) {
                            t = t || 0, e = e || 0, i = i || 0, s = s || 0, this.start = new n.Point(t, e), this.end = new n.Point(i, s)
                        }, n.Line.prototype = {
                            setTo: function(t, e, i, s) {
                                return this.start.setTo(t, e), this.end.setTo(i, s), this
                            },
                            fromSprite: function(t, e, i) {
                                return "undefined" == typeof i && (i = !1), i ? this.setTo(t.center.x, t.center.y, e.center.x, e.center.y) : this.setTo(t.x, t.y, e.x, e.y)
                            },
                            intersects: function(t, e, i) {
                                return n.Line.intersectsPoints(this.start, this.end, t.start, t.end, e, i)
                            },
                            pointOnLine: function(t, e) {
                                return (t - this.start.x) * (this.end.y - this.start.y) === (this.end.x - this.start.x) * (e - this.start.y)
                            },
                            pointOnSegment: function(t, e) {
                                var i = Math.min(this.start.x, this.end.x),
                                    s = Math.max(this.start.x, this.end.x),
                                    n = Math.min(this.start.y, this.end.y),
                                    r = Math.max(this.start.y, this.end.y);
                                return this.pointOnLine(t, e) && t >= i && s >= t && e >= n && r >= e
                            },
                            coordinatesOnLine: function(t, e) {
                                "undefined" == typeof t && (t = 1), "undefined" == typeof e && (e = []);
                                var i = Math.round(this.start.x),
                                    s = Math.round(this.start.y),
                                    n = Math.round(this.end.x),
                                    r = Math.round(this.end.y),
                                    o = Math.abs(n - i),
                                    a = Math.abs(r - s),
                                    h = n > i ? 1 : -1,
                                    l = r > s ? 1 : -1,
                                    c = o - a;
                                e.push([i, s]);
                                for (var u = 1; i != n || s != r;) {
                                    var d = c << 1;
                                    d > -a && (c -= a, i += h), o > d && (c += o, s += l), u % t === 0 && e.push([i, s]), u++
                                }
                                return e
                            }
                        }, Object.defineProperty(n.Line.prototype, "length", {
                            get: function() {
                                return Math.sqrt((this.end.x - this.start.x) * (this.end.x - this.start.x) + (this.end.y - this.start.y) * (this.end.y - this.start.y))
                            }
                        }), Object.defineProperty(n.Line.prototype, "angle", {
                            get: function() {
                                return Math.atan2(this.end.y - this.start.y, this.end.x - this.start.x)
                            }
                        }), Object.defineProperty(n.Line.prototype, "slope", {
                            get: function() {
                                return (this.end.y - this.start.y) / (this.end.x - this.start.x)
                            }
                        }), Object.defineProperty(n.Line.prototype, "perpSlope", {
                            get: function() {
                                return -((this.end.x - this.start.x) / (this.end.y - this.start.y))
                            }
                        }), Object.defineProperty(n.Line.prototype, "x", {
                            get: function() {
                                return Math.min(this.start.x, this.end.x)
                            }
                        }), Object.defineProperty(n.Line.prototype, "y", {
                            get: function() {
                                return Math.min(this.start.y, this.end.y)
                            }
                        }), Object.defineProperty(n.Line.prototype, "left", {
                            get: function() {
                                return Math.min(this.start.x, this.end.x)
                            }
                        }), Object.defineProperty(n.Line.prototype, "right", {
                            get: function() {
                                return Math.max(this.start.x, this.end.x)
                            }
                        }), Object.defineProperty(n.Line.prototype, "top", {
                            get: function() {
                                return Math.min(this.start.y, this.end.y)
                            }
                        }), Object.defineProperty(n.Line.prototype, "bottom", {
                            get: function() {
                                return Math.max(this.start.y, this.end.y)
                            }
                        }), Object.defineProperty(n.Line.prototype, "width", {
                            get: function() {
                                return Math.abs(this.start.x - this.end.x)
                            }
                        }), Object.defineProperty(n.Line.prototype, "height", {
                            get: function() {
                                return Math.abs(this.start.y - this.end.y)
                            }
                        }), n.Line.intersectsPoints = function(t, e, i, s, r, o) {
                            "undefined" == typeof r && (r = !0), "undefined" == typeof o && (o = new n.Point);
                            var a = e.y - t.y,
                                h = s.y - i.y,
                                l = t.x - e.x,
                                c = i.x - s.x,
                                u = e.x * t.y - t.x * e.y,
                                d = s.x * i.y - i.x * s.y,
                                p = a * c - h * l;
                            if (0 === p) return null;
                            if (o.x = (l * d - c * u) / p, o.y = (h * u - a * d) / p, r) {
                                var f = (s.y - i.y) * (e.x - t.x) - (s.x - i.x) * (e.y - t.y),
                                    g = ((s.x - i.x) * (t.y - i.y) - (s.y - i.y) * (t.x - i.x)) / f,
                                    m = ((e.x - t.x) * (t.y - i.y) - (e.y - t.y) * (t.x - i.x)) / f;
                                return g >= 0 && 1 >= g && m >= 0 && 1 >= m ? o : null
                            }
                            return o
                        }, n.Line.intersects = function(t, e, i, s) {
                            return n.Line.intersectsPoints(t.start, t.end, e.start, e.end, i, s)
                        }, n.Ellipse = function(t, e, i, s) {
                            this.type = n.ELLIPSE, t = t || 0, e = e || 0, i = i || 0, s = s || 0, this.x = t, this.y = e, this.width = i, this.height = s
                        }, n.Ellipse.prototype = {
                            setTo: function(t, e, i, s) {
                                return this.x = t, this.y = e, this.width = i, this.height = s, this
                            },
                            copyFrom: function(t) {
                                return this.setTo(t.x, t.y, t.width, t.height)
                            },
                            copyTo: function(t) {
                                return t.x = this.x, t.y = this.y, t.width = this.width, t.height = this.height, t
                            },
                            clone: function(t) {
                                return "undefined" == typeof t ? t = new n.Ellipse(this.x, this.y, this.width, this.height) : t.setTo(this.x, this.y, this.width, this.height), t
                            },
                            contains: function(t, e) {
                                return n.Ellipse.contains(this, t, e)
                            },
                            toString: function() {
                                return "[{Phaser.Ellipse (x=" + this.x + " y=" + this.y + " width=" + this.width + " height=" + this.height + ")}]"
                            }
                        }, n.Ellipse.prototype.constructor = n.Ellipse, Object.defineProperty(n.Ellipse.prototype, "left", {
                            get: function() {
                                return this.x
                            },
                            set: function(t) {
                                this.x = t
                            }
                        }), Object.defineProperty(n.Ellipse.prototype, "right", {
                            get: function() {
                                return this.x + this.width
                            },
                            set: function(t) {
                                this.width = t < this.x ? 0 : this.x + t
                            }
                        }), Object.defineProperty(n.Ellipse.prototype, "top", {
                            get: function() {
                                return this.y
                            },
                            set: function(t) {
                                this.y = t
                            }
                        }), Object.defineProperty(n.Ellipse.prototype, "bottom", {
                            get: function() {
                                return this.y + this.height
                            },
                            set: function(t) {
                                this.height = t < this.y ? 0 : this.y + t
                            }
                        }), Object.defineProperty(n.Ellipse.prototype, "empty", {
                            get: function() {
                                return 0 === this.width || 0 === this.height
                            },
                            set: function(t) {
                                t === !0 && this.setTo(0, 0, 0, 0)
                            }
                        }), n.Ellipse.contains = function(t, e, i) {
                            if (t.width <= 0 || t.height <= 0) return !1;
                            var s = (e - t.x) / t.width - .5,
                                n = (i - t.y) / t.height - .5;
                            return s *= s, n *= n, .25 > s + n
                        }, n.Ellipse.prototype.getBounds = function() {
                            return new n.Rectangle(this.x, this.y, this.width, this.height)
                        }, PIXI.Ellipse = n.Ellipse, n.Polygon = function(t) {
                            if (this.type = n.POLYGON, t instanceof Array || (t = Array.prototype.slice.call(arguments)), "number" == typeof t[0]) {
                                for (var e = [], i = 0, s = t.length; s > i; i += 2) e.push(new n.Point(t[i], t[i + 1]));
                                t = e
                            }
                            this._points = t
                        }, n.Polygon.prototype = {
                            clone: function() {
                                for (var t = [], e = 0; e < this.points.length; e++) t.push(this.points[e].clone());
                                return new n.Polygon(t)
                            },
                            contains: function(t, e) {
                                for (var i = !1, s = 0, n = this.points.length - 1; s < this.points.length; n = s++) {
                                    var r = this.points[s].x,
                                        o = this.points[s].y,
                                        a = this.points[n].x,
                                        h = this.points[n].y,
                                        l = o > e != h > e && (a - r) * (e - o) / (h - o) + r > t;
                                    l && (i = !i)
                                }
                                return i
                            }
                        }, n.Polygon.prototype.constructor = n.Polygon, Object.defineProperty(n.Polygon.prototype, "points", {
                            get: function() {
                                return this._points
                            },
                            set: function(t) {
                                if (t instanceof Array || (t = Array.prototype.slice.call(arguments)), "number" == typeof t[0]) {
                                    for (var e = [], i = 0, s = t.length; s > i; i += 2) e.push(new n.Point(t[i], t[i + 1]));
                                    t = e
                                }
                                this._points = t
                            }
                        }), Object.defineProperty(n.Polygon.prototype, "area", {
                            get: function() {
                                var t, e, i, s, n, r = Number.MAX_VALUE,
                                    o = 0;
                                for (n = 0; n < this.points.length; n++) this.points[n].y < r && (r = this.points[n].y);
                                for (n = 0; n < this.points.length; n++) t = this.points[n], e = n === this.points.length - 1 ? this.points[0] : this.points[n + 1], i = (t.y - r + (e.y - r)) / 2, s = t.x - e.x, o += i * s;
                                return o
                            }
                        }), PIXI.Polygon = n.Polygon, n.Camera = function(t, e, i, s, r, o) {
                            this.game = t, this.world = t.world, this.id = 0, this.view = new n.Rectangle(i, s, r, o), this.screenView = new n.Rectangle(i, s, r, o), this.bounds = new n.Rectangle(i, s, r, o), this.deadzone = null, this.visible = !0, this.atLimit = {
                                x: !1,
                                y: !1
                            }, this.target = null, this._edge = 0, this.displayObject = null, this.scale = null
                        }, n.Camera.FOLLOW_LOCKON = 0, n.Camera.FOLLOW_PLATFORMER = 1, n.Camera.FOLLOW_TOPDOWN = 2, n.Camera.FOLLOW_TOPDOWN_TIGHT = 3, n.Camera.prototype = {
                            follow: function(t, e) {
                                "undefined" == typeof e && (e = n.Camera.FOLLOW_LOCKON), this.target = t;
                                var i;
                                switch (e) {
                                    case n.Camera.FOLLOW_PLATFORMER:
                                        var s = this.width / 8,
                                            r = this.height / 3;
                                        this.deadzone = new n.Rectangle((this.width - s) / 2, (this.height - r) / 2 - .25 * r, s, r);
                                        break;
                                    case n.Camera.FOLLOW_TOPDOWN:
                                        i = Math.max(this.width, this.height) / 4, this.deadzone = new n.Rectangle((this.width - i) / 2, (this.height - i) / 2, i, i);
                                        break;
                                    case n.Camera.FOLLOW_TOPDOWN_TIGHT:
                                        i = Math.max(this.width, this.height) / 8, this.deadzone = new n.Rectangle((this.width - i) / 2, (this.height - i) / 2, i, i);
                                        break;
                                    case n.Camera.FOLLOW_LOCKON:
                                        this.deadzone = null;
                                        break;
                                    default:
                                        this.deadzone = null
                                }
                            },
                            unfollow: function() {
                                this.target = null
                            },
                            focusOn: function(t) {
                                this.setPosition(Math.round(t.x - this.view.halfWidth), Math.round(t.y - this.view.halfHeight))
                            },
                            focusOnXY: function(t, e) {
                                this.setPosition(Math.round(t - this.view.halfWidth), Math.round(e - this.view.halfHeight))
                            },
                            update: function() {
                                this.target && this.updateTarget(), this.bounds && this.checkBounds(), this.displayObject.position.x = -this.view.x, this.displayObject.position.y = -this.view.y
                            },
                            updateTarget: function() {
                                this.deadzone ? (this._edge = this.target.x - this.view.x, this._edge < this.deadzone.left ? this.view.x = this.target.x - this.deadzone.left : this._edge > this.deadzone.right && (this.view.x = this.target.x - this.deadzone.right), this._edge = this.target.y - this.view.y, this._edge < this.deadzone.top ? this.view.y = this.target.y - this.deadzone.top : this._edge > this.deadzone.bottom && (this.view.y = this.target.y - this.deadzone.bottom)) : (this.view.x = this.target.x - this.view.halfWidth, this.view.y = this.target.y - this.view.halfHeight)
                            },
                            setBoundsToWorld: function() {
                                this.bounds.setTo(this.game.world.bounds.x, this.game.world.bounds.y, this.game.world.bounds.width, this.game.world.bounds.height)
                            },
                            checkBounds: function() {
                                this.atLimit.x = !1, this.atLimit.y = !1, this.view.x <= this.bounds.x && (this.atLimit.x = !0, this.view.x = this.bounds.x), this.view.right >= this.bounds.right && (this.atLimit.x = !0, this.view.x = this.bounds.right - this.width), this.view.y <= this.bounds.top && (this.atLimit.y = !0, this.view.y = this.bounds.top), this.view.bottom >= this.bounds.bottom && (this.atLimit.y = !0, this.view.y = this.bounds.bottom - this.height), this.view.floor()
                            },
                            setPosition: function(t, e) {
                                this.view.x = t, this.view.y = e, this.bounds && this.checkBounds()
                            },
                            setSize: function(t, e) {
                                this.view.width = t, this.view.height = e
                            },
                            reset: function() {
                                this.target = null, this.view.x = 0, this.view.y = 0
                            }
                        }, n.Camera.prototype.constructor = n.Camera, Object.defineProperty(n.Camera.prototype, "x", {
                            get: function() {
                                return this.view.x
                            },
                            set: function(t) {
                                this.view.x = t, this.bounds && this.checkBounds()
                            }
                        }), Object.defineProperty(n.Camera.prototype, "y", {
                            get: function() {
                                return this.view.y
                            },
                            set: function(t) {
                                this.view.y = t, this.bounds && this.checkBounds()
                            }
                        }), Object.defineProperty(n.Camera.prototype, "width", {
                            get: function() {
                                return this.view.width
                            },
                            set: function(t) {
                                this.view.width = t
                            }
                        }), Object.defineProperty(n.Camera.prototype, "height", {
                            get: function() {
                                return this.view.height
                            },
                            set: function(t) {
                                this.view.height = t
                            }
                        }), n.State = function() {
                            this.game = null, this.add = null, this.make = null, this.camera = null, this.cache = null, this.input = null, this.load = null, this.math = null, this.sound = null, this.scale = null, this.stage = null, this.time = null, this.tweens = null, this.world = null, this.particles = null, this.physics = null, this.rnd = null
                        }, n.State.prototype = {
                            preload: function() {},
                            loadUpdate: function() {},
                            loadRender: function() {},
                            create: function() {},
                            update: function() {},
                            render: function() {},
                            paused: function() {},
                            pauseUpdate: function() {},
                            shutdown: function() {}
                        }, n.State.prototype.constructor = n.State, n.StateManager = function(t, e) {
                            this.game = t, this.states = {}, this._pendingState = null, "undefined" != typeof e && null !== e && (this._pendingState = e), this._clearWorld = !1, this._clearCache = !1, this._created = !1, this._args = [], this.current = "", this.onInitCallback = null, this.onPreloadCallback = null, this.onCreateCallback = null, this.onUpdateCallback = null, this.onRenderCallback = null, this.onPreRenderCallback = null, this.onLoadUpdateCallback = null, this.onLoadRenderCallback = null, this.onPausedCallback = null, this.onResumedCallback = null, this.onPauseUpdateCallback = null, this.onShutDownCallback = null
                        }, n.StateManager.prototype = {
                            boot: function() {
                                this.game.onPause.add(this.pause, this), this.game.onResume.add(this.resume, this), this.game.load.onLoadComplete.add(this.loadComplete, this), null !== this._pendingState && ("string" == typeof this._pendingState ? this.start(this._pendingState, !1, !1) : this.add("default", this._pendingState, !0))
                            },
                            add: function(t, e, i) {
                                "undefined" == typeof i && (i = !1);
                                var s;
                                return e instanceof n.State ? s = e : "object" == typeof e ? (s = e, s.game = this.game) : "function" == typeof e && (s = new e(this.game)), this.states[t] = s, i && (this.game.isBooted ? this.start(t) : this._pendingState = t), s
                            },
                            remove: function(t) {
                                this.current === t && (this.callbackContext = null, this.onInitCallback = null, this.onShutDownCallback = null, this.onPreloadCallback = null, this.onLoadRenderCallback = null, this.onLoadUpdateCallback = null, this.onCreateCallback = null, this.onUpdateCallback = null, this.onRenderCallback = null, this.onPausedCallback = null, this.onResumedCallback = null, this.onPauseUpdateCallback = null), delete this.states[t]
                            },
                            start: function(t, e, i) {
                                "undefined" == typeof e && (e = !0), "undefined" == typeof i && (i = !1), this.checkState(t) && (this._pendingState = t, this._clearWorld = e, this._clearCache = i, arguments.length > 3 && (this._args = Array.prototype.splice.call(arguments, 3)))
                            },
                            restart: function(t, e) {
                                "undefined" == typeof t && (t = !0), "undefined" == typeof e && (e = !1), this._pendingState = this.current, this._clearWorld = t, this._clearCache = e, arguments.length > 2 && (this._args = Array.prototype.splice.call(arguments, 2))
                            },
                            dummy: function() {},
                            preUpdate: function() {
                                this._pendingState && this.game.isBooted && (this.current && (this.onShutDownCallback && this.onShutDownCallback.call(this.callbackContext, this.game), this.game.tweens.removeAll(), this.game.camera.reset(), this.game.input.reset(!0), this.game.physics.clear(), this.game.time.removeAll(), this._clearWorld && (this.game.world.shutdown(), this._clearCache === !0 && this.game.cache.destroy())), this.setCurrentState(this._pendingState), this.onPreloadCallback ? (this.game.load.reset(), this.onPreloadCallback.call(this.callbackContext, this.game), 0 === this.game.load.totalQueuedFiles() && 0 === this.game.load.totalQueuedPacks() ? this.loadComplete() : this.game.load.start()) : this.loadComplete(), this.current === this._pendingState && (this._pendingState = null))
                            },
                            checkState: function(t) {
                                if (this.states[t]) {
                                    var e = !1;
                                    return this.states[t].preload && (e = !0), this.states[t].create && (e = !0), this.states[t].update && (e = !0), this.states[t].render && (e = !0), e === !1 ? (console.warn("Invalid Phaser State object given. Must contain at least a one of the required functions: preload, create, update or render"), !1) : !0
                                }
                                return console.warn("Phaser.StateManager - No state found with the key: " + t), !1
                            },
                            link: function(t) {
                                this.states[t].game = this.game, this.states[t].add = this.game.add, this.states[t].make = this.game.make, this.states[t].camera = this.game.camera, this.states[t].cache = this.game.cache, this.states[t].input = this.game.input, this.states[t].load = this.game.load, this.states[t].math = this.game.math, this.states[t].sound = this.game.sound, this.states[t].scale = this.game.scale, this.states[t].state = this, this.states[t].stage = this.game.stage, this.states[t].time = this.game.time, this.states[t].tweens = this.game.tweens, this.states[t].world = this.game.world, this.states[t].particles = this.game.particles, this.states[t].rnd = this.game.rnd, this.states[t].physics = this.game.physics
                            },
                            setCurrentState: function(t) {
                                this.callbackContext = this.states[t], this.link(t), this.onInitCallback = this.states[t].init || this.dummy, this.onPreloadCallback = this.states[t].preload || null, this.onLoadRenderCallback = this.states[t].loadRender || null, this.onLoadUpdateCallback = this.states[t].loadUpdate || null, this.onCreateCallback = this.states[t].create || null, this.onUpdateCallback = this.states[t].update || null, this.onPreRenderCallback = this.states[t].preRender || null, this.onRenderCallback = this.states[t].render || null, this.onPausedCallback = this.states[t].paused || null, this.onResumedCallback = this.states[t].resumed || null, this.onPauseUpdateCallback = this.states[t].pauseUpdate || null, this.onShutDownCallback = this.states[t].shutdown || this.dummy, this.current = t, this._created = !1, this.onInitCallback.apply(this.callbackContext, this._args), this._args = []
                            },
                            getCurrentState: function() {
                                return this.states[this.current]
                            },
                            loadComplete: function() {
                                this._created === !1 && this.onCreateCallback ? (this._created = !0, this.onCreateCallback.call(this.callbackContext, this.game)) : this._created = !0
                            },
                            pause: function() {
                                this._created && this.onPausedCallback && this.onPausedCallback.call(this.callbackContext, this.game)
                            },
                            resume: function() {
                                this._created && this.onResumedCallback && this.onResumedCallback.call(this.callbackContext, this.game)
                            },
                            update: function() {
                                this._created && this.onUpdateCallback ? this.onUpdateCallback.call(this.callbackContext, this.game) : this.onLoadUpdateCallback && this.onLoadUpdateCallback.call(this.callbackContext, this.game)
                            },
                            pauseUpdate: function() {
                                this._created && this.onPauseUpdateCallback ? this.onPauseUpdateCallback.call(this.callbackContext, this.game) : this.onLoadUpdateCallback && this.onLoadUpdateCallback.call(this.callbackContext, this.game)
                            },
                            preRender: function() {
                                this.onPreRenderCallback && this.onPreRenderCallback.call(this.callbackContext, this.game)
                            },
                            render: function() {
                                this._created && this.onRenderCallback ? (this.game.renderType === n.CANVAS && (this.game.context.save(), this.game.context.setTransform(1, 0, 0, 1, 0, 0)), this.onRenderCallback.call(this.callbackContext, this.game), this.game.renderType === n.CANVAS && this.game.context.restore()) : this.onLoadRenderCallback && this.onLoadRenderCallback.call(this.callbackContext, this.game)
                            },
                            destroy: function() {
                                this.callbackContext = null, this.onInitCallback = null, this.onShutDownCallback = null, this.onPreloadCallback = null, this.onLoadRenderCallback = null, this.onLoadUpdateCallback = null, this.onCreateCallback = null, this.onUpdateCallback = null, this.onRenderCallback = null, this.onPausedCallback = null, this.onResumedCallback = null, this.onPauseUpdateCallback = null, this.game = null, this.states = {}, this._pendingState = null
                            }
                        }, n.StateManager.prototype.constructor = n.StateManager, n.LinkedList = function() {
                            this.next = null, this.prev = null, this.first = null, this.last = null, this.total = 0
                        }, n.LinkedList.prototype = {
                            add: function(t) {
                                return 0 === this.total && null === this.first && null === this.last ? (this.first = t, this.last = t, this.next = t, t.prev = this, this.total++, t) : (this.last.next = t, t.prev = this.last, this.last = t, this.total++, t)
                            },
                            reset: function() {
                                this.first = null, this.last = null, this.next = null, this.prev = null, this.total = 0
                            },
                            remove: function(t) {
                                return 1 === this.total ? (this.reset(), void(t.next = t.prev = null)) : (t === this.first ? this.first = this.first.next : t === this.last && (this.last = this.last.prev), t.prev && (t.prev.next = t.next), t.next && (t.next.prev = t.prev), t.next = t.prev = null, null === this.first && (this.last = null), void this.total--)
                            },
                            callAll: function(t) {
                                if (this.first && this.last) {
                                    var e = this.first;
                                    do e && e[t] && e[t].call(e), e = e.next; while (e != this.last.next)
                                }
                            }
                        }, n.LinkedList.prototype.constructor = n.LinkedList, n.ArrayList = function() {
                            this.total = 0, this.position = 0, this.list = []
                        }, n.ArrayList.prototype = {
                            add: function(t) {
                                return this.exists(t) || (this.list.push(t), this.total++), t
                            },
                            getIndex: function(t) {
                                return this.list.indexOf(t)
                            },
                            exists: function(t) {
                                return this.list.indexOf(t) > -1
                            },
                            reset: function() {
                                this.list.length = 0, this.total = 0
                            },
                            remove: function(t) {
                                var e = this.list.indexOf(t);
                                return e > -1 ? (this.list.splice(e, 1), this.total--, t) : void 0
                            },
                            setAll: function(t, e) {
                                for (var i = this.list.length; i--;) this.list[i] && this.list[i][t] && (this.list[i][t] = e)
                            },
                            callAll: function(t) {
                                for (var e = Array.prototype.splice.call(arguments, 1), i = this.list.length; i--;) this.list[i] && this.list[i][t] && this.list[i][t].apply(this.list[i], e)
                            }
                        }, Object.defineProperty(n.ArrayList.prototype, "first", {
                            get: function() {
                                return this.position = 0, this.total > 0 ? this.list[0] : null
                            }
                        }), Object.defineProperty(n.ArrayList.prototype, "next", {
                            get: function() {
                                return this.position < this.total ? (this.position++, this.list[this.position]) : null
                            }
                        }), n.ArrayList.prototype.constructor = n.ArrayList, n.Signal = function() {
                            this._bindings = [], this._prevParams = null;
                            var t = this;
                            this.dispatch = function() {
                                n.Signal.prototype.dispatch.apply(t, arguments)
                            }
                        }, n.Signal.prototype = {
                            memorize: !1,
                            _shouldPropagate: !0,
                            active: !0,
                            validateListener: function(t, e) {
                                if ("function" != typeof t) throw new Error("Phaser.Signal: listener is a required param of {fn}() and should be a Function.".replace("{fn}", e))
                            },
                            _registerListener: function(t, e, i, s) {
                                var r, o = this._indexOfListener(t, i);
                                if (-1 !== o) {
                                    if (r = this._bindings[o], r.isOnce() !== e) throw new Error("You cannot add" + (e ? "" : "Once") + "() then add" + (e ? "Once" : "") + "() the same listener without removing the relationship first.")
                                } else r = new n.SignalBinding(this, t, e, i, s), this._addBinding(r);
                                return this.memorize && this._prevParams && r.execute(this._prevParams), r
                            },
                            _addBinding: function(t) {
                                var e = this._bindings.length;
                                do e--; while (this._bindings[e] && t._priority <= this._bindings[e]._priority);
                                this._bindings.splice(e + 1, 0, t)
                            },
                            _indexOfListener: function(t, e) {
                                for (var i, s = this._bindings.length; s--;)
                                    if (i = this._bindings[s], i._listener === t && i.context === e) return s;
                                return -1
                            },
                            has: function(t, e) {
                                return -1 !== this._indexOfListener(t, e)
                            },
                            add: function(t, e, i) {
                                return this.validateListener(t, "add"), this._registerListener(t, !1, e, i)
                            },
                            addOnce: function(t, e, i) {
                                return this.validateListener(t, "addOnce"), this._registerListener(t, !0, e, i)
                            },
                            remove: function(t, e) {
                                this.validateListener(t, "remove");
                                var i = this._indexOfListener(t, e);
                                return -1 !== i && (this._bindings[i]._destroy(), this._bindings.splice(i, 1)), t
                            },
                            removeAll: function(t) {
                                "undefined" == typeof t && (t = null);
                                for (var e = this._bindings.length; e--;) t ? this._bindings[e].context === t && (this._bindings[e]._destroy(), this._bindings.splice(e, 1)) : this._bindings[e]._destroy();
                                this._bindings.length = 0
                            },
                            getNumListeners: function() {
                                return this._bindings.length
                            },
                            halt: function() {
                                this._shouldPropagate = !1
                            },
                            dispatch: function() {
                                if (this.active) {
                                    var t, e = Array.prototype.slice.call(arguments),
                                        i = this._bindings.length;
                                    if (this.memorize && (this._prevParams = e), i) {
                                        t = this._bindings.slice(), this._shouldPropagate = !0;
                                        do i--; while (t[i] && this._shouldPropagate && t[i].execute(e) !== !1)
                                    }
                                }
                            },
                            forget: function() {
                                this._prevParams = null
                            },
                            dispose: function() {
                                this.removeAll(), delete this._bindings, delete this._prevParams
                            },
                            toString: function() {
                                return "[Phaser.Signal active:" + this.active + " numListeners:" + this.getNumListeners() + "]"
                            }
                        }, n.Signal.prototype.constructor = n.Signal, n.SignalBinding = function(t, e, i, s, n) {
                            this._listener = e, this._isOnce = i, this.context = s, this._signal = t, this._priority = n || 0
                        }, n.SignalBinding.prototype = {
                            active: !0,
                            params: null,
                            execute: function(t) {
                                var e, i;
                                return this.active && this._listener && (i = this.params ? this.params.concat(t) : t, e = this._listener.apply(this.context, i), this._isOnce && this.detach()), e
                            },
                            detach: function() {
                                return this.isBound() ? this._signal.remove(this._listener, this.context) : null
                            },
                            isBound: function() {
                                return !!this._signal && !!this._listener
                            },
                            isOnce: function() {
                                return this._isOnce
                            },
                            getListener: function() {
                                return this._listener
                            },
                            getSignal: function() {
                                return this._signal
                            },
                            _destroy: function() {
                                delete this._signal, delete this._listener, delete this.context
                            },
                            toString: function() {
                                return "[Phaser.SignalBinding isOnce:" + this._isOnce + ", isBound:" + this.isBound() + ", active:" + this.active + "]"
                            }
                        }, n.SignalBinding.prototype.constructor = n.SignalBinding, n.Filter = function(t, e, i) {
                            this.game = t, this.type = n.WEBGL_FILTER, this.passes = [this], this.shaders = [], this.dirty = !0, this.padding = 0, this.uniforms = {
                                time: {
                                    type: "1f",
                                    value: 0
                                },
                                resolution: {
                                    type: "2f",
                                    value: {
                                        x: 256,
                                        y: 256
                                    }
                                },
                                mouse: {
                                    type: "2f",
                                    value: {
                                        x: 0,
                                        y: 0
                                    }
                                }
                            }, this.fragmentSrc = i || []
                        }, n.Filter.prototype = {
                            init: function() {},
                            setResolution: function(t, e) {
                                this.uniforms.resolution.value.x = t, this.uniforms.resolution.value.y = e
                            },
                            update: function(t) {
                                "undefined" != typeof t && (t.x > 0 && (this.uniforms.mouse.x = t.x.toFixed(2)), t.y > 0 && (this.uniforms.mouse.y = t.y.toFixed(2))), this.uniforms.time.value = this.game.time.totalElapsedSeconds()
                            },
                            destroy: function() {
                                this.game = null
                            }
                        }, n.Filter.prototype.constructor = n.Filter, Object.defineProperty(n.Filter.prototype, "width", {
                            get: function() {
                                return this.uniforms.resolution.value.x
                            },
                            set: function(t) {
                                this.uniforms.resolution.value.x = t
                            }
                        }), Object.defineProperty(n.Filter.prototype, "height", {
                            get: function() {
                                return this.uniforms.resolution.value.y
                            },
                            set: function(t) {
                                this.uniforms.resolution.value.y = t
                            }
                        }), n.Plugin = function(t, e) {
                            "undefined" == typeof e && (e = null), this.game = t, this.parent = e, this.active = !1, this.visible = !1, this.hasPreUpdate = !1, this.hasUpdate = !1, this.hasPostUpdate = !1, this.hasRender = !1, this.hasPostRender = !1
                        }, n.Plugin.prototype = {
                            preUpdate: function() {},
                            update: function() {},
                            render: function() {},
                            postRender: function() {},
                            destroy: function() {
                                this.game = null, this.parent = null, this.active = !1, this.visible = !1
                            }
                        }, n.Plugin.prototype.constructor = n.Plugin, n.PluginManager = function(t) {
                            this.game = t, this.plugins = [], this._len = 0, this._i = 0
                        }, n.PluginManager.prototype = {
                            add: function(t) {
                                var e = Array.prototype.splice.call(arguments, 1),
                                    i = !1;
                                return "function" == typeof t ? t = new t(this.game, this) : (t.game = this.game, t.parent = this), "function" == typeof t.preUpdate && (t.hasPreUpdate = !0, i = !0), "function" == typeof t.update && (t.hasUpdate = !0, i = !0), "function" == typeof t.postUpdate && (t.hasPostUpdate = !0, i = !0), "function" == typeof t.render && (t.hasRender = !0, i = !0), "function" == typeof t.postRender && (t.hasPostRender = !0, i = !0), i ? ((t.hasPreUpdate || t.hasUpdate || t.hasPostUpdate) && (t.active = !0), (t.hasRender || t.hasPostRender) && (t.visible = !0), this._len = this.plugins.push(t), "function" == typeof t.init && t.init.apply(t, e), t) : null
                            },
                            remove: function(t) {
                                for (this._i = this._len; this._i--;)
                                    if (this.plugins[this._i] === t) return t.destroy(), this.plugins.splice(this._i, 1), void this._len--
                            },
                            removeAll: function() {
                                for (this._i = this._len; this._i--;) this.plugins[this._i].destroy();
                                this.plugins.length = 0, this._len = 0
                            },
                            preUpdate: function() {
                                for (this._i = this._len; this._i--;) this.plugins[this._i].active && this.plugins[this._i].hasPreUpdate && this.plugins[this._i].preUpdate()
                            },
                            update: function() {
                                for (this._i = this._len; this._i--;) this.plugins[this._i].active && this.plugins[this._i].hasUpdate && this.plugins[this._i].update()
                            },
                            postUpdate: function() {
                                for (this._i = this._len; this._i--;) this.plugins[this._i].active && this.plugins[this._i].hasPostUpdate && this.plugins[this._i].postUpdate()
                            },
                            render: function() {
                                for (this._i = this._len; this._i--;) this.plugins[this._i].visible && this.plugins[this._i].hasRender && this.plugins[this._i].render()
                            },
                            postRender: function() {
                                for (this._i = this._len; this._i--;) this.plugins[this._i].visible && this.plugins[this._i].hasPostRender && this.plugins[this._i].postRender()
                            },
                            destroy: function() {
                                this.removeAll(), this.game = null
                            }
                        }, n.PluginManager.prototype.constructor = n.PluginManager, n.Stage = function(t, e, i) {
                            this.game = t, this.offset = new n.Point, this.bounds = new n.Rectangle(0, 0, e, i), PIXI.Stage.call(this, 0), this.name = "_stage_root", this.interactive = !1, this.disableVisibilityChange = !1, this.checkOffsetInterval = 2500, this.exists = !0, this.currentRenderOrderID = 0, this._hiddenVar = "hidden", this._nextOffsetCheck = 0, this._backgroundColor = 0, t.config && this.parseConfig(t.config)
                        }, n.Stage.prototype = Object.create(PIXI.Stage.prototype), n.Stage.prototype.constructor = n.Stage, n.Stage.prototype.preUpdate = function() {
                            this.currentRenderOrderID = 0;
                            for (var t = this.children.length, e = 0; t > e; e++) this.children[e].preUpdate()
                        }, n.Stage.prototype.update = function() {
                            for (var t = this.children.length; t--;) this.children[t].update()
                        }, n.Stage.prototype.postUpdate = function() {
                            if (this.game.world.camera.target) {
                                this.game.world.camera.target.postUpdate(), this.game.world.camera.update();
                                for (var t = this.children.length; t--;) this.children[t] !== this.game.world.camera.target && this.children[t].postUpdate()
                            } else {
                                this.game.world.camera.update();
                                for (var t = this.children.length; t--;) this.children[t].postUpdate()
                            }
                            this.checkOffsetInterval !== !1 && this.game.time.now > this._nextOffsetCheck && (n.Canvas.getOffset(this.game.canvas, this.offset), this.bounds.x = this.offset.x, this.bounds.y = this.offset.y, this._nextOffsetCheck = this.game.time.now + this.checkOffsetInterval)
                        }, n.Stage.prototype.parseConfig = function(t) {
                            t.checkOffsetInterval && (this.checkOffsetInterval = t.checkOffsetInterval), t.disableVisibilityChange && (this.disableVisibilityChange = t.disableVisibilityChange), t.fullScreenScaleMode && (this.fullScreenScaleMode = t.fullScreenScaleMode), t.scaleMode && (this.scaleMode = t.scaleMode), t.backgroundColor && (this.backgroundColor = t.backgroundColor)
                        }, n.Stage.prototype.boot = function() {
                            n.Canvas.getOffset(this.game.canvas, this.offset), this.bounds.setTo(this.offset.x, this.offset.y, this.game.width, this.game.height);
                            var t = this;
                            this._onChange = function(e) {
                                return t.visibilityChange(e)
                            }, n.Canvas.setUserSelect(this.game.canvas, "none"), n.Canvas.setTouchAction(this.game.canvas, "none"), this.checkVisibility()
                        }, n.Stage.prototype.checkVisibility = function() {
                            this._hiddenVar = void 0 !== document.webkitHidden ? "webkitvisibilitychange" : void 0 !== document.mozHidden ? "mozvisibilitychange" : void 0 !== document.msHidden ? "msvisibilitychange" : void 0 !== document.hidden ? "visibilitychange" : null, this._hiddenVar && document.addEventListener(this._hiddenVar, this._onChange, !1), window.onpagehide = this._onChange, window.onpageshow = this._onChange, window.onblur = this._onChange, window.onfocus = this._onChange
                        }, n.Stage.prototype.visibilityChange = function(t) {
                            return "pagehide" === t.type || "blur" === t.type || "pageshow" === t.type || "focus" === t.type ? void("pagehide" === t.type || "blur" === t.type ? this.game.focusLoss(t) : ("pageshow" === t.type || "focus" === t.type) && this.game.focusGain(t)) : void(this.disableVisibilityChange || (document.hidden || document.mozHidden || document.msHidden || document.webkitHidden ? this.game.gamePaused(t) : this.game.gameResumed(t)))
                        }, n.Stage.prototype.setBackgroundColor = function(t) {
                            if ("string" == typeof t) {
                                var e = n.Color.hexToColor(t);
                                this._backgroundColor = n.Color.getColor(e.r, e.g, e.b)
                            } else {
                                var e = n.Color.getRGB(t);
                                this._backgroundColor = t
                            }
                            this.backgroundColorSplit = [e.r / 255, e.g / 255, e.b / 255], this.backgroundColorString = n.Color.RGBtoString(e.r, e.g, e.b, 255, "#")
                        }, Object.defineProperty(n.Stage.prototype, "backgroundColor", {
                            get: function() {
                                return this._backgroundColor
                            },
                            set: function(t) {
                                this.game.transparent || this.setBackgroundColor(t)
                            }
                        }), Object.defineProperty(n.Stage.prototype, "smoothed", {
                            get: function() {
                                return !PIXI.scaleModes.LINEAR
                            },
                            set: function(t) {
                                PIXI.scaleModes.LINEAR = t ? 0 : 1
                            }
                        }), n.Group = function(t, e, i, s, r, o) {
                            "undefined" == typeof s && (s = !1), "undefined" == typeof r && (r = !1), "undefined" == typeof o && (o = n.Physics.ARCADE), this.game = t, "undefined" == typeof e && (e = t.world), this.name = i || "group", PIXI.DisplayObjectContainer.call(this), s ? this.game.stage.addChild(this) : e && e.addChild(this), this.z = 0, this.type = n.GROUP, this.alive = !0, this.exists = !0, this.classType = n.Sprite, this.scale = new n.Point(1, 1), this.cursor = null, this.cameraOffset = new n.Point, this.enableBody = r, this.enableBodyDebug = !1, this.physicsBodyType = o, this._sortProperty = "z", this._cache = [0, 0, 0, 0, 1, 0, 1, 0, 0, 0]
                        }, n.Group.prototype = Object.create(PIXI.DisplayObjectContainer.prototype), n.Group.prototype.constructor = n.Group, n.Group.RETURN_NONE = 0, n.Group.RETURN_TOTAL = 1, n.Group.RETURN_CHILD = 2, n.Group.SORT_ASCENDING = -1, n.Group.SORT_DESCENDING = 1, n.Group.prototype.add = function(t, e) {
                            return "undefined" == typeof e && (e = !1), t.parent !== this && (this.enableBody && this.game.physics.enable(t, this.physicsBodyType), this.addChild(t), t.z = this.children.length, !e && t.events && t.events.onAddedToGroup.dispatch(t, this), null === this.cursor && (this.cursor = t)), t
                        }, n.Group.prototype.addAt = function(t, e, i) {
                            return "undefined" == typeof i && (i = !1), t.parent !== this && (this.enableBody && this.game.physics.enable(t, this.physicsBodyType), this.addChildAt(t, e), this.updateZ(), !i && t.events && t.events.onAddedToGroup.dispatch(t, this), null === this.cursor && (this.cursor = t)), t
                        }, n.Group.prototype.getAt = function(t) {
                            return 0 > t || t >= this.children.length ? -1 : this.getChildAt(t)
                        }, n.Group.prototype.create = function(t, e, i, s, n) {
                            "undefined" == typeof n && (n = !0);
                            var r = new this.classType(this.game, t, e, i, s);
                            return this.enableBody && this.game.physics.enable(r, this.physicsBodyType, this.enableBodyDebug), r.exists = n, r.visible = n, r.alive = n, this.addChild(r), r.z = this.children.length, r.events && r.events.onAddedToGroup.dispatch(r, this), null === this.cursor && (this.cursor = r), r
                        }, n.Group.prototype.createMultiple = function(t, e, i, s) {
                            "undefined" == typeof s && (s = !1);
                            for (var n = 0; t > n; n++) this.create(0, 0, e, i, s)
                        }, n.Group.prototype.updateZ = function() {
                            for (var t = this.children.length; t--;) this.children[t].z = t
                        }, n.Group.prototype.resetCursor = function(t) {
                            return "undefined" == typeof t && (t = 0), t > this.children.length - 1 && (t = 0), this.cursor ? (this._cache[8] = t, this.cursor = this.children[this._cache[8]], this.cursor) : void 0
                        }, n.Group.prototype.next = function() {
                            return this.cursor ? (this._cache[8] >= this.children.length - 1 ? this._cache[8] = 0 : this._cache[8]++, this.cursor = this.children[this._cache[8]], this.cursor) : void 0
                        }, n.Group.prototype.previous = function() {
                            return this.cursor ? (0 === this._cache[8] ? this._cache[8] = this.children.length - 1 : this._cache[8]--, this.cursor = this.children[this._cache[8]], this.cursor) : void 0
                        }, n.Group.prototype.swap = function(t, e) {
                            var i = this.swapChildren(t, e);
                            return i && this.updateZ(), i
                        }, n.Group.prototype.bringToTop = function(t) {
                            return t.parent === this && this.getIndex(t) < this.children.length && (this.remove(t, !1, !0), this.add(t, !0)), t
                        }, n.Group.prototype.sendToBack = function(t) {
                            return t.parent === this && this.getIndex(t) > 0 && (this.remove(t, !1, !0), this.addAt(t, 0, !0)), t
                        }, n.Group.prototype.moveUp = function(t) {
                            if (t.parent === this && this.getIndex(t) < this.children.length - 1) {
                                var e = this.getIndex(t),
                                    i = this.getAt(e + 1);
                                i && this.swap(t, i)
                            }
                            return t
                        }, n.Group.prototype.moveDown = function(t) {
                            if (t.parent === this && this.getIndex(t) > 0) {
                                var e = this.getIndex(t),
                                    i = this.getAt(e - 1);
                                i && this.swap(t, i)
                            }
                            return t
                        }, n.Group.prototype.xy = function(t, e, i) {
                            return 0 > t || t > this.children.length ? -1 : (this.getChildAt(t).x = e, void(this.getChildAt(t).y = i))
                        }, n.Group.prototype.reverse = function() {
                            this.children.reverse(), this.updateZ()
                        }, n.Group.prototype.getIndex = function(t) {
                            return this.children.indexOf(t)
                        }, n.Group.prototype.replace = function(t, e) {
                            var i = this.getIndex(t);
                            if (-1 !== i) {
                                void 0 !== e.parent && (e.events.onRemovedFromGroup.dispatch(e, this), e.parent.removeChild(e), e.parent instanceof n.Group && e.parent.updateZ());
                                var s = t;
                                return this.remove(s), this.addAt(e, i), s
                            }
                        }, n.Group.prototype.hasProperty = function(t, e) {
                            var i = e.length;
                            return 1 === i && e[0] in t ? !0 : 2 === i && e[0] in t && e[1] in t[e[0]] ? !0 : 3 === i && e[0] in t && e[1] in t[e[0]] && e[2] in t[e[0]][e[1]] ? !0 : 4 === i && e[0] in t && e[1] in t[e[0]] && e[2] in t[e[0]][e[1]] && e[3] in t[e[0]][e[1]][e[2]] ? !0 : !1
                        }, n.Group.prototype.setProperty = function(t, e, i, s, n) {
                            if ("undefined" == typeof n && (n = !1), s = s || 0, !this.hasProperty(t, e) && (!n || s > 0)) return !1;
                            var r = e.length;
                            return 1 === r ? 0 === s ? t[e[0]] = i : 1 == s ? t[e[0]] += i : 2 == s ? t[e[0]] -= i : 3 == s ? t[e[0]] *= i : 4 == s && (t[e[0]] /= i) : 2 === r ? 0 === s ? t[e[0]][e[1]] = i : 1 == s ? t[e[0]][e[1]] += i : 2 == s ? t[e[0]][e[1]] -= i : 3 == s ? t[e[0]][e[1]] *= i : 4 == s && (t[e[0]][e[1]] /= i) : 3 === r ? 0 === s ? t[e[0]][e[1]][e[2]] = i : 1 == s ? t[e[0]][e[1]][e[2]] += i : 2 == s ? t[e[0]][e[1]][e[2]] -= i : 3 == s ? t[e[0]][e[1]][e[2]] *= i : 4 == s && (t[e[0]][e[1]][e[2]] /= i) : 4 === r && (0 === s ? t[e[0]][e[1]][e[2]][e[3]] = i : 1 == s ? t[e[0]][e[1]][e[2]][e[3]] += i : 2 == s ? t[e[0]][e[1]][e[2]][e[3]] -= i : 3 == s ? t[e[0]][e[1]][e[2]][e[3]] *= i : 4 == s && (t[e[0]][e[1]][e[2]][e[3]] /= i)), !0
                        }, n.Group.prototype.checkProperty = function(t, e, i, s) {
                            return "undefined" == typeof s && (s = !1), !n.Utils.getProperty(t, e) && s ? !1 : n.Utils.getProperty(t, e) !== i ? !1 : !0
                        }, n.Group.prototype.set = function(t, e, i, s, n, r, o) {
                            return "undefined" == typeof o && (o = !1), e = e.split("."), "undefined" == typeof s && (s = !1), "undefined" == typeof n && (n = !1), (s === !1 || s && t.alive) && (n === !1 || n && t.visible) ? this.setProperty(t, e, i, r, o) : void 0
                        }, n.Group.prototype.setAll = function(t, e, i, s, n, r) {
                            "undefined" == typeof i && (i = !1), "undefined" == typeof s && (s = !1), "undefined" == typeof r && (r = !1), t = t.split("."), n = n || 0;
                            for (var o = 0, a = this.children.length; a > o; o++)(!i || i && this.children[o].alive) && (!s || s && this.children[o].visible) && this.setProperty(this.children[o], t, e, n, r)
                        }, n.Group.prototype.setAllChildren = function(t, e, i, s, r, o) {
                            "undefined" == typeof i && (i = !1), "undefined" == typeof s && (s = !1), "undefined" == typeof o && (o = !1), r = r || 0;
                            for (var a = 0, h = this.children.length; h > a; a++)(!i || i && this.children[a].alive) && (!s || s && this.children[a].visible) && (this.children[a] instanceof n.Group ? this.children[a].setAllChildren(t, e, i, s, r, o) : this.setProperty(this.children[a], t.split("."), e, r, o))
                        }, n.Group.prototype.checkAll = function(t, e, i, s, n) {
                            "undefined" == typeof i && (i = !1), "undefined" == typeof s && (s = !1), "undefined" == typeof n && (n = !1);
                            for (var r = 0, o = this.children.length; o > r; r++)
                                if ((!i || i && this.children[r].alive) && (!s || s && this.children[r].visible) && !this.checkProperty(this.children[r], t, e, n)) return !1;
                            return !0
                        }, n.Group.prototype.addAll = function(t, e, i, s) {
                            this.setAll(t, e, i, s, 1)
                        }, n.Group.prototype.subAll = function(t, e, i, s) {
                            this.setAll(t, e, i, s, 2)
                        }, n.Group.prototype.multiplyAll = function(t, e, i, s) {
                            this.setAll(t, e, i, s, 3)
                        }, n.Group.prototype.divideAll = function(t, e, i, s) {
                            this.setAll(t, e, i, s, 4)
                        }, n.Group.prototype.callAllExists = function(t, e) {
                            for (var i = Array.prototype.splice.call(arguments, 2), s = 0, n = this.children.length; n > s; s++) this.children[s].exists === e && this.children[s][t] && this.children[s][t].apply(this.children[s], i)
                        }, n.Group.prototype.callbackFromArray = function(t, e, i) {
                            if (1 == i) {
                                if (t[e[0]]) return t[e[0]]
                            } else if (2 == i) {
                                if (t[e[0]][e[1]]) return t[e[0]][e[1]]
                            } else if (3 == i) {
                                if (t[e[0]][e[1]][e[2]]) return t[e[0]][e[1]][e[2]]
                            } else if (4 == i) {
                                if (t[e[0]][e[1]][e[2]][e[3]]) return t[e[0]][e[1]][e[2]][e[3]]
                            } else if (t[e]) return t[e];
                            return !1
                        }, n.Group.prototype.callAll = function(t, e) {
                            if ("undefined" != typeof t) {
                                t = t.split(".");
                                var i = t.length;
                                if ("undefined" == typeof e || null === e || "" === e) e = null;
                                else if ("string" == typeof e) {
                                    e = e.split(".");
                                    var s = e.length
                                }
                                for (var n = Array.prototype.splice.call(arguments, 2), r = null, o = null, a = 0, h = this.children.length; h > a; a++) r = this.callbackFromArray(this.children[a], t, i), e && r ? (o = this.callbackFromArray(this.children[a], e, s), r && r.apply(o, n)) : r && r.apply(this.children[a], n)
                            }
                        }, n.Group.prototype.preUpdate = function() {
                            if (!this.exists || !this.parent.exists) return this.renderOrderID = -1, !1;
                            for (var t = this.children.length; t--;) this.children[t].preUpdate();
                            return !0
                        }, n.Group.prototype.update = function() {
                            for (var t = this.children.length; t--;) this.children[t].update()
                        }, n.Group.prototype.postUpdate = function() {
                            1 === this._cache[7] && (this.x = this.game.camera.view.x + this.cameraOffset.x, this.y = this.game.camera.view.y + this.cameraOffset.y);
                            for (var t = this.children.length; t--;) this.children[t].postUpdate()
                        }, n.Group.prototype.forEach = function(t, e, i) {
                            "undefined" == typeof i && (i = !1);
                            var s = Array.prototype.splice.call(arguments, 3);
                            s.unshift(null);
                            for (var n = 0, r = this.children.length; r > n; n++)(!i || i && this.children[n].exists) && (s[0] = this.children[n], t.apply(e, s))
                        }, n.Group.prototype.forEachExists = function(t, e) {
                            var i = Array.prototype.splice.call(arguments, 2);
                            i.unshift(null), this.iterate("exists", !0, n.Group.RETURN_TOTAL, t, e, i)
                        }, n.Group.prototype.forEachAlive = function(t, e) {
                            var i = Array.prototype.splice.call(arguments, 2);
                            i.unshift(null), this.iterate("alive", !0, n.Group.RETURN_TOTAL, t, e, i)
                        }, n.Group.prototype.forEachDead = function(t, e) {
                            var i = Array.prototype.splice.call(arguments, 2);
                            i.unshift(null), this.iterate("alive", !1, n.Group.RETURN_TOTAL, t, e, i)
                        }, n.Group.prototype.sort = function(t, e) {
                            this.children.length < 2 || ("undefined" == typeof t && (t = "z"), "undefined" == typeof e && (e = n.Group.SORT_ASCENDING), this._sortProperty = t, this.children.sort(e === n.Group.SORT_ASCENDING ? this.ascendingSortHandler.bind(this) : this.descendingSortHandler.bind(this)), this.updateZ())
                        }, n.Group.prototype.customSort = function(t, e) {
                            this.children.length < 2 || (this.children.sort(t.bind(e)), this.updateZ())
                        }, n.Group.prototype.ascendingSortHandler = function(t, e) {
                            return t[this._sortProperty] < e[this._sortProperty] ? -1 : t[this._sortProperty] > e[this._sortProperty] ? 1 : t.z < e.z ? -1 : 1
                        }, n.Group.prototype.descendingSortHandler = function(t, e) {
                            return t[this._sortProperty] < e[this._sortProperty] ? 1 : t[this._sortProperty] > e[this._sortProperty] ? -1 : 0
                        }, n.Group.prototype.iterate = function(t, e, i, s, r, o) {
                            if (i === n.Group.RETURN_TOTAL && 0 === this.children.length) return 0;
                            "undefined" == typeof s && (s = !1);
                            for (var a = 0, h = 0, l = this.children.length; l > h; h++)
                                if (this.children[h][t] === e && (a++, s && (o[0] = this.children[h], s.apply(r, o)), i === n.Group.RETURN_CHILD)) return this.children[h];
                            return i === n.Group.RETURN_TOTAL ? a : i === n.Group.RETURN_CHILD ? null : void 0
                        }, n.Group.prototype.getFirstExists = function(t) {
                            return "boolean" != typeof t && (t = !0), this.iterate("exists", t, n.Group.RETURN_CHILD)
                        }, n.Group.prototype.getFirstAlive = function() {
                            return this.iterate("alive", !0, n.Group.RETURN_CHILD)
                        }, n.Group.prototype.getFirstDead = function() {
                            return this.iterate("alive", !1, n.Group.RETURN_CHILD)
                        }, n.Group.prototype.getTop = function() {
                            return this.children.length > 0 ? this.children[this.children.length - 1] : void 0
                        }, n.Group.prototype.getBottom = function() {
                            return this.children.length > 0 ? this.children[0] : void 0
                        }, n.Group.prototype.countLiving = function() {
                            return this.iterate("alive", !0, n.Group.RETURN_TOTAL)
                        }, n.Group.prototype.countDead = function() {
                            return this.iterate("alive", !1, n.Group.RETURN_TOTAL)
                        }, n.Group.prototype.getRandom = function(t, e) {
                            return 0 === this.children.length ? null : (t = t || 0, e = e || this.children.length, this.game.math.getRandom(this.children, t, e))
                        }, n.Group.prototype.remove = function(t, e, i) {
                            if ("undefined" == typeof e && (e = !1), "undefined" == typeof i && (i = !1), 0 === this.children.length || -1 === this.children.indexOf(t)) return !1;
                            i || !t.events || t.destroyPhase || t.events.onRemovedFromGroup.dispatch(t, this);
                            var s = this.removeChild(t);
                            return this.updateZ(), this.cursor === t && this.next(), e && s && s.destroy(!0), !0
                        }, n.Group.prototype.removeAll = function(t, e) {
                            if ("undefined" == typeof t && (t = !1), "undefined" == typeof e && (e = !1), 0 !== this.children.length) {
                                do {
                                    !e && this.children[0].events && this.children[0].events.onRemovedFromGroup.dispatch(this.children[0], this);
                                    var i = this.removeChild(this.children[0]);
                                    t && i && i.destroy(!0)
                                } while (this.children.length > 0);
                                this.cursor = null
                            }
                        }, n.Group.prototype.removeBetween = function(t, e, i, s) {
                            if ("undefined" == typeof e && (e = this.children.length), "undefined" == typeof i && (i = !1), "undefined" == typeof s && (s = !1), 0 !== this.children.length) {
                                if (t > e || 0 > t || e > this.children.length) return !1;
                                for (var n = e; n >= t;) {
                                    !s && this.children[n].events && this.children[n].events.onRemovedFromGroup.dispatch(this.children[n], this);
                                    var r = this.removeChild(this.children[n]);
                                    i && r && r.destroy(!0), this.cursor === this.children[n] && (this.cursor = null), n--
                                }
                                this.updateZ()
                            }
                        }, n.Group.prototype.destroy = function(t, e) {
                            null !== this.game && ("undefined" == typeof t && (t = !0), "undefined" == typeof e && (e = !1), this.removeAll(t), this.cursor = null, this.filters = null, e || (this.parent && this.parent.removeChild(this), this.game = null, this.exists = !1))
                        }, Object.defineProperty(n.Group.prototype, "total", {
                            get: function() {
                                return this.iterate("exists", !0, n.Group.RETURN_TOTAL)
                            }
                        }), Object.defineProperty(n.Group.prototype, "length", {
                            get: function() {
                                return this.children.length
                            }
                        }), Object.defineProperty(n.Group.prototype, "angle", {
                            get: function() {
                                return n.Math.radToDeg(this.rotation)
                            },
                            set: function(t) {
                                this.rotation = n.Math.degToRad(t)
                            }
                        }), Object.defineProperty(n.Group.prototype, "fixedToCamera", {
                            get: function() {
                                return !!this._cache[7]
                            },
                            set: function(t) {
                                t ? (this._cache[7] = 1, this.cameraOffset.set(this.x, this.y)) : this._cache[7] = 0
                            }
                        }), n.World = function(t) {
                            n.Group.call(this, t, null, "__world", !1), this.bounds = new n.Rectangle(0, 0, t.width, t.height), this.camera = null
                        }, n.World.prototype = Object.create(n.Group.prototype), n.World.prototype.constructor = n.World, n.World.prototype.boot = function() {
                            this.camera = new n.Camera(this.game, 0, 0, 0, this.game.width, this.game.height), this.camera.displayObject = this, this.camera.scale = this.scale, this.game.camera = this.camera, this.game.stage.addChild(this)
                        }, n.World.prototype.setBounds = function(t, e, i, s) {
                            i < this.game.width && (i = this.game.width), s < this.game.height && (s = this.game.height), this.bounds.setTo(t, e, i, s), this.camera.bounds && this.camera.bounds.setTo(t, e, i, s), this.game.physics.setBoundsToWorld()
                        }, n.World.prototype.shutdown = function() {
                            this.destroy(!0, !0)
                        }, n.World.prototype.wrap = function(t, e, i, s, n) {
                            "undefined" == typeof e && (e = 0), "undefined" == typeof i && (i = !1), "undefined" == typeof s && (s = !0), "undefined" == typeof n && (n = !0), i ? (t.getBounds(), s && (t.x + t._currentBounds.width < this.bounds.x ? t.x = this.bounds.right : t.x > this.bounds.right && (t.x = this.bounds.left)), n && (t.y + t._currentBounds.height < this.bounds.top ? t.y = this.bounds.bottom : t.y > this.bounds.bottom && (t.y = this.bounds.top))) : (s && t.x + e < this.bounds.x ? t.x = this.bounds.right + e : s && t.x - e > this.bounds.right && (t.x = this.bounds.left - e), n && t.y + e < this.bounds.top ? t.y = this.bounds.bottom + e : n && t.y - e > this.bounds.bottom && (t.y = this.bounds.top - e))
                        }, Object.defineProperty(n.World.prototype, "width", {
                            get: function() {
                                return this.bounds.width
                            },
                            set: function(t) {
                                this.bounds.width = t
                            }
                        }), Object.defineProperty(n.World.prototype, "height", {
                            get: function() {
                                return this.bounds.height
                            },
                            set: function(t) {
                                this.bounds.height = t
                            }
                        }), Object.defineProperty(n.World.prototype, "centerX", {
                            get: function() {
                                return this.bounds.halfWidth
                            }
                        }), Object.defineProperty(n.World.prototype, "centerY", {
                            get: function() {
                                return this.bounds.halfHeight
                            }
                        }), Object.defineProperty(n.World.prototype, "randomX", {
                            get: function() {
                                return this.bounds.x < 0 ? this.game.rnd.integerInRange(this.bounds.x, this.bounds.width - Math.abs(this.bounds.x)) : this.game.rnd.integerInRange(this.bounds.x, this.bounds.width)
                            }
                        }), Object.defineProperty(n.World.prototype, "randomY", {
                            get: function() {
                                return this.bounds.y < 0 ? this.game.rnd.integerInRange(this.bounds.y, this.bounds.height - Math.abs(this.bounds.y)) : this.game.rnd.integerInRange(this.bounds.y, this.bounds.height)
                            }
                        }), n.ScaleManager = function(t, e, i) {
                            this.game = t, this.width = e, this.height = i, this.minWidth = null, this.maxWidth = null, this.minHeight = null, this.maxHeight = null, this.forceLandscape = !1, this.forcePortrait = !1, this.incorrectOrientation = !1, this.pageAlignHorizontally = !1, this.pageAlignVertically = !1, this.maxIterations = 5, this.orientationSprite = null, this.enterLandscape = new n.Signal, this.enterPortrait = new n.Signal, this.enterIncorrectOrientation = new n.Signal, this.leaveIncorrectOrientation = new n.Signal, this.hasResized = new n.Signal, this.fullScreenTarget = this.game.canvas, this.enterFullScreen = new n.Signal, this.leaveFullScreen = new n.Signal, this.orientation = 0, window.orientation ? this.orientation = window.orientation : window.outerWidth > window.outerHeight && (this.orientation = 90), this.scaleFactor = new n.Point(1, 1), this.scaleFactorInversed = new n.Point(1, 1), this.margin = new n.Point(0, 0), this.bounds = new n.Rectangle(0, 0, e, i), this.aspectRatio = 0, this.sourceAspectRatio = e / i, this.event = null, this.scaleMode = n.ScaleManager.NO_SCALE, this.fullScreenScaleMode = n.ScaleManager.NO_SCALE, this._startHeight = 0, this._width = 0, this._height = 0, this._check = null;
                            var s = this;
                            window.addEventListener("orientationchange", function(t) {
                                return s.checkOrientation(t)
                            }, !1), window.addEventListener("resize", function(t) {
                                return s.checkResize(t)
                            }, !1), this.game.device.cocoonJS || (document.addEventListener("webkitfullscreenchange", function(t) {
                                return s.fullScreenChange(t)
                            }, !1), document.addEventListener("mozfullscreenchange", function(t) {
                                return s.fullScreenChange(t)
                            }, !1), document.addEventListener("fullscreenchange", function(t) {
                                return s.fullScreenChange(t)
                            }, !1))
                        }, n.ScaleManager.EXACT_FIT = 0, n.ScaleManager.NO_SCALE = 1, n.ScaleManager.SHOW_ALL = 2, n.ScaleManager.prototype = {
                            startFullScreen: function(t) {
                                !this.isFullScreen && this.game.device.fullscreen && ("undefined" != typeof t && this.game.renderType === n.CANVAS && (this.game.stage.smoothed = t), this._width = this.width, this._height = this.height, this.game.device.fullscreenKeyboard ? this.fullScreenTarget[this.game.device.requestFullscreen](Element.ALLOW_KEYBOARD_INPUT) : this.fullScreenTarget[this.game.device.requestFullscreen]())
                            },
                            stopFullScreen: function() {
                                document[this.game.device.cancelFullscreen]()
                            },
                            fullScreenChange: function(t) {
                                this.event = t, this.isFullScreen ? (this.fullScreenScaleMode === n.ScaleManager.EXACT_FIT ? (this.fullScreenTarget.style.width = "100%", this.fullScreenTarget.style.height = "100%", this.width = window.outerWidth, this.height = window.outerHeight, this.game.input.scale.setTo(this.game.width / this.width, this.game.height / this.height), this.aspectRatio = this.width / this.height, this.scaleFactor.x = this.game.width / this.width, this.scaleFactor.y = this.game.height / this.height, this.checkResize()) : this.fullScreenScaleMode === n.ScaleManager.SHOW_ALL && (this.setShowAll(), this.refresh()), this.enterFullScreen.dispatch(this.width, this.height)) : (this.fullScreenTarget.style.width = this.game.width + "px", this.fullScreenTarget.style.height = this.game.height + "px", this.width = this._width, this.height = this._height, this.game.input.scale.setTo(this.game.width / this.width, this.game.height / this.height), this.aspectRatio = this.width / this.height, this.scaleFactor.x = this.game.width / this.width, this.scaleFactor.y = this.game.height / this.height, this.leaveFullScreen.dispatch(this.width, this.height))
                            },
                            forceOrientation: function(t, e, i) {
                                "undefined" == typeof e && (e = !1), this.forceLandscape = t, this.forcePortrait = e, "undefined" != typeof i && ((null === i || this.game.cache.checkImageKey(i) === !1) && (i = "__default"), this.orientationSprite = new n.Image(this.game, this.game.width / 2, this.game.height / 2, i), this.orientationSprite.anchor.set(.5), this.checkOrientationState(), this.incorrectOrientation ? (this.orientationSprite.visible = !0, this.game.world.visible = !1) : (this.orientationSprite.visible = !1, this.game.world.visible = !0), this.game.stage.addChild(this.orientationSprite))
                            },
                            checkOrientationState: function() {
                                this.incorrectOrientation ? (this.forceLandscape && window.innerWidth > window.innerHeight || this.forcePortrait && window.innerHeight > window.innerWidth) && (this.incorrectOrientation = !1, this.leaveIncorrectOrientation.dispatch(), this.orientationSprite && (this.orientationSprite.visible = !1, this.game.world.visible = !0), this.scaleMode !== n.ScaleManager.NO_SCALE && this.refresh()) : (this.forceLandscape && window.innerWidth < window.innerHeight || this.forcePortrait && window.innerHeight < window.innerWidth) && (this.incorrectOrientation = !0, this.enterIncorrectOrientation.dispatch(), this.orientationSprite && this.orientationSprite.visible === !1 && (this.orientationSprite.visible = !0, this.game.world.visible = !1), this.scaleMode !== n.ScaleManager.NO_SCALE && this.refresh())
                            },
                            checkOrientation: function(t) {
                                this.event = t, this.orientation = window.orientation, this.isLandscape ? this.enterLandscape.dispatch(this.orientation, !0, !1) : this.enterPortrait.dispatch(this.orientation, !1, !0), this.scaleMode !== n.ScaleManager.NO_SCALE && this.refresh()
                            },
                            checkResize: function(t) {
                                this.event = t, this.orientation = window.outerWidth > window.outerHeight ? 90 : 0, this.isLandscape ? this.enterLandscape.dispatch(this.orientation, !0, !1) : this.enterPortrait.dispatch(this.orientation, !1, !0), this.scaleMode !== n.ScaleManager.NO_SCALE && this.refresh(), this.checkOrientationState()
                            },
                            refresh: function() {
                                if (this.game.device.iPad || this.game.device.webApp || this.game.device.desktop || (this.game.device.android && !this.game.device.chrome ? window.scrollTo(0, 1) : window.scrollTo(0, 0)), null === this._check && this.maxIterations > 0) {
                                    this._iterations = this.maxIterations;
                                    var t = this;
                                    this._check = window.setInterval(function() {
                                        return t.setScreenSize()
                                    }, 10), this.setScreenSize()
                                }
                            },
                            setScreenSize: function(t) {
                                "undefined" == typeof t && (t = !1), this.game.device.iPad || this.game.device.webApp || this.game.device.desktop || (this.game.device.android && !this.game.device.chrome ? window.scrollTo(0, 1) : window.scrollTo(0, 0)), this._iterations--, (t || window.innerHeight > this._startHeight || this._iterations < 0) && (document.documentElement.style.minHeight = window.innerHeight + "px", this.incorrectOrientation ? this.setMaximum() : this.isFullScreen ? this.fullScreenScaleMode === n.ScaleManager.EXACT_FIT ? this.setExactFit() : this.fullScreenScaleMode === n.ScaleManager.SHOW_ALL && this.setShowAll() : this.scaleMode === n.ScaleManager.EXACT_FIT ? this.setExactFit() : this.scaleMode === n.ScaleManager.SHOW_ALL && this.setShowAll(), this.setSize(), clearInterval(this._check), this._check = null)
                            },
                            setSize: function() {
                                this.incorrectOrientation || (this.maxWidth && this.width > this.maxWidth && (this.width = this.maxWidth), this.maxHeight && this.height > this.maxHeight && (this.height = this.maxHeight), this.minWidth && this.width < this.minWidth && (this.width = this.minWidth), this.minHeight && this.height < this.minHeight && (this.height = this.minHeight)), this.game.canvas.style.width = this.width + "px", this.game.canvas.style.height = this.height + "px", this.game.input.scale.setTo(this.game.width / this.width, this.game.height / this.height), this.pageAlignHorizontally && (this.width < window.innerWidth && !this.incorrectOrientation ? (this.margin.x = Math.round((window.innerWidth - this.width) / 2), this.game.canvas.style.marginLeft = this.margin.x + "px") : (this.margin.x = 0, this.game.canvas.style.marginLeft = "0px")), this.pageAlignVertically && (this.height < window.innerHeight && !this.incorrectOrientation ? (this.margin.y = Math.round((window.innerHeight - this.height) / 2), this.game.canvas.style.marginTop = this.margin.y + "px") : (this.margin.y = 0, this.game.canvas.style.marginTop = "0px")), n.Canvas.getOffset(this.game.canvas, this.game.stage.offset), this.bounds.setTo(this.game.stage.offset.x, this.game.stage.offset.y, this.width, this.height), this.aspectRatio = this.width / this.height, this.scaleFactor.x = this.game.width / this.width, this.scaleFactor.y = this.game.height / this.height, this.scaleFactorInversed.x = this.width / this.game.width, this.scaleFactorInversed.y = this.height / this.game.height, this.hasResized.dispatch(this.width, this.height), this.checkOrientationState()
                            },
                            setMaximum: function() {
                                this.width = window.innerWidth, this.height = window.innerHeight
                            },
                            setShowAll: function() {
                                var t = Math.min(window.innerHeight / this.game.height, window.innerWidth / this.game.width);
                                this.width = Math.round(this.game.width * t), this.height = Math.round(this.game.height * t)
                            },
                            setExactFit: function() {
                                var t = window.innerWidth,
                                    e = window.innerHeight;
                                this.width = this.maxWidth && t > this.maxWidth ? this.maxWidth : t, this.height = this.maxHeight && e > this.maxHeight ? this.maxHeight : e
                            }
                        }, n.ScaleManager.prototype.constructor = n.ScaleManager, Object.defineProperty(n.ScaleManager.prototype, "isFullScreen", {
                            get: function() {
                                return document.fullscreenElement || document.mozFullScreenElement || document.webkitFullscreenElement
                            }
                        }), Object.defineProperty(n.ScaleManager.prototype, "isPortrait", {
                            get: function() {
                                return 0 === this.orientation || 180 === this.orientation
                            }
                        }), Object.defineProperty(n.ScaleManager.prototype, "isLandscape", {
                            get: function() {
                                return 90 === this.orientation || -90 === this.orientation
                            }
                        }), n.Game = function(t, e, i, s, r, o, a, h) {
                            this.id = n.GAMES.push(this) - 1, this.config = null, this.physicsConfig = h, this.parent = "", this.width = 800, this.height = 600, this.transparent = !1, this.antialias = !0, this.preserveDrawingBuffer = !1, this.renderer = null, this.renderType = n.AUTO, this.state = null, this.isBooted = !1, this.isRunning = !1, this.raf = null, this.add = null, this.make = null, this.cache = null, this.input = null, this.load = null, this.math = null, this.net = null, this.scale = null, this.sound = null, this.stage = null, this.time = null, this.tweens = null, this.world = null, this.physics = null, this.rnd = null, this.device = null, this.camera = null, this.canvas = null, this.context = null, this.debug = null, this.particles = null, this.stepping = !1, this.pendingStep = !1, this.stepCount = 0, this.onPause = null, this.onResume = null, this.onBlur = null, this.onFocus = null, this._paused = !1, this._codePaused = !1, 1 === arguments.length && "object" == typeof arguments[0] ? this.parseConfig(arguments[0]) : (this.config = {
                                enableDebug: !0
                            }, "undefined" != typeof t && (this.width = t), "undefined" != typeof e && (this.height = e), "undefined" != typeof i && (this.renderer = i, this.renderType = i), "undefined" != typeof s && (this.parent = s), "undefined" != typeof o && (this.transparent = o), "undefined" != typeof a && (this.antialias = a), this.rnd = new n.RandomDataGenerator([(Date.now() * Math.random()).toString()]), this.state = new n.StateManager(this, r));
                            var l = this;
                            return this._onBoot = function() {
                                return l.boot()
                            }, "complete" === document.readyState || "interactive" === document.readyState ? window.setTimeout(this._onBoot, 0) : (document.addEventListener("DOMContentLoaded", this._onBoot, !1), window.addEventListener("load", this._onBoot, !1)), this
                        }, n.Game.prototype = {
                            parseConfig: function(t) {
                                this.config = t, t.width && (this.width = n.Utils.parseDimension(t.width, 0)), t.height && (this.height = n.Utils.parseDimension(t.height, 1)), t.renderer && (this.renderer = t.renderer, this.renderType = t.renderer), t.parent && (this.parent = t.parent), t.transparent && (this.transparent = t.transparent), t.antialias && (this.antialias = t.antialias), t.preserveDrawingBuffer && (this.preserveDrawingBuffer = t.preserveDrawingBuffer), t.physicsConfig && (this.physicsConfig = t.physicsConfig);
                                var e = [(Date.now() * Math.random()).toString()];
                                t.seed && (e = t.seed), this.rnd = new n.RandomDataGenerator(e);
                                var i = null;
                                t.state && (i = t.state), this.state = new n.StateManager(this, i)
                            },
                            boot: function() {
                                this.isBooted || (document.body ? (document.removeEventListener("DOMContentLoaded", this._onBoot), window.removeEventListener("load", this._onBoot), this.onPause = new n.Signal, this.onResume = new n.Signal, this.onBlur = new n.Signal, this.onFocus = new n.Signal, this.isBooted = !0, this.device = new n.Device(this), this.math = n.Math, this.stage = new n.Stage(this, this.width, this.height), this.setUpRenderer(), this.scale = new n.ScaleManager(this, this.width, this.height), this.device.checkFullScreenSupport(), this.world = new n.World(this), this.add = new n.GameObjectFactory(this), this.make = new n.GameObjectCreator(this), this.cache = new n.Cache(this), this.load = new n.Loader(this), this.time = new n.Time(this), this.tweens = new n.TweenManager(this), this.input = new n.Input(this), this.sound = new n.SoundManager(this), this.physics = new n.Physics(this, this.physicsConfig), this.particles = new n.Particles(this), this.plugins = new n.PluginManager(this), this.net = new n.Net(this), this.time.boot(), this.stage.boot(), this.world.boot(), this.input.boot(), this.sound.boot(), this.state.boot(), this.config.enableDebug && (this.debug = new n.Utils.Debug(this), this.debug.boot()), this.showDebugHeader(), this.isRunning = !0, this.raf = this.config && this.config.forceSetTimeOut ? new n.RequestAnimationFrame(this, this.config.forceSetTimeOut) : new n.RequestAnimationFrame(this, !1), this.raf.start()) : window.setTimeout(this._onBoot, 20))
                            },
                            showDebugHeader: function() {
                                var t = n.VERSION,
                                    e = "Canvas",
                                    i = "HTML Audio",
                                    s = 1;
                                if (this.renderType === n.WEBGL ? (e = "WebGL", s++) : this.renderType == n.HEADLESS && (e = "Headless"), this.device.webAudio && (i = "WebAudio", s++), this.device.chrome) {
                                    for (var r = ["%c %c %c Phaser v" + t + " | Pixi.js " + PIXI.VERSION + " | " + e + " | " + i + "  %c %c  http://phaser.io  %c %c ♥%c♥%c♥ ", "background: #0cf300", "background: #00bc17", "color: #ffffff; background: #00711f;", "background: #00bc17", "background: #0cf300", "background: #00bc17"], o = 0; 3 > o; o++) r.push(s > o ? "color: #ff2424; background: #fff" : "color: #959595; background: #fff");
                                    console.log.apply(console, r)
                                } else window.console && console.log("Phaser v" + t + " | Pixi.js " + PIXI.VERSION + " | " + e + " | " + i + " | http://phaser.io")
                            },
                            setUpRenderer: function() {
                                if (this.device.trident && (this.renderType = n.CANVAS), this.canvas = this.config.canvasID ? n.Canvas.create(this.width, this.height, this.config.canvasID) : n.Canvas.create(this.width, this.height), this.config.canvasStyle ? this.canvas.style = this.config.canvasStyle : this.canvas.style["-webkit-full-screen"] = "width: 100%; height: 100%", this.device.cocoonJS && (this.canvas.screencanvas = !0), this.renderType === n.HEADLESS || this.renderType === n.CANVAS || this.renderType === n.AUTO && this.device.webGL === !1) {
                                    if (!this.device.canvas) throw new Error("Phaser.Game - cannot create Canvas or WebGL context, aborting.");
                                    this.renderType === n.AUTO && (this.renderType = n.CANVAS), this.renderer = new PIXI.CanvasRenderer(this.width, this.height, this.canvas, this.transparent), this.context = this.renderer.context
                                } else this.renderType = n.WEBGL, this.renderer = new PIXI.WebGLRenderer(this.width, this.height, this.canvas, this.transparent, this.antialias, this.preserveDrawingBuffer), this.context = null;
                                this.renderType !== n.HEADLESS && (this.stage.smoothed = this.antialias, n.Canvas.addToDOM(this.canvas, this.parent, !1), n.Canvas.setTouchAction(this.canvas))
                            },
                            update: function(t) {
                                this.time.update(t), this._paused || this.pendingStep ? (this.state.pauseUpdate(), this.config.enableDebug && this.debug.preUpdate()) : (this.stepping && (this.pendingStep = !0), this.config.enableDebug && this.debug.preUpdate(), this.physics.preUpdate(), this.state.preUpdate(), this.plugins.preUpdate(), this.stage.preUpdate(), this.state.update(), this.stage.update(), this.tweens.update(), this.sound.update(), this.input.update(), this.physics.update(), this.particles.update(), this.plugins.update(), this.stage.postUpdate(), this.plugins.postUpdate()), this.renderType != n.HEADLESS && (this.state.preRender(), this.renderer.render(this.stage), this.plugins.render(), this.state.render(), this.plugins.postRender(), this.device.cocoonJS && this.renderType === n.CANVAS && 1 === this.stage.currentRenderOrderID && this.context.fillRect(0, 0, 0, 0))
                            },
                            enableStep: function() {
                                this.stepping = !0, this.pendingStep = !1, this.stepCount = 0
                            },
                            disableStep: function() {
                                this.stepping = !1, this.pendingStep = !1
                            },
                            step: function() {
                                this.pendingStep = !1, this.stepCount++
                            },
                            destroy: function() {
                                this.raf.stop(), this.input.destroy(), this.state.destroy(), this.physics.destroy(), this.state = null, this.cache = null, this.input = null, this.load = null, this.sound = null, this.stage = null, this.time = null, this.world = null, this.isBooted = !1
                            },
                            gamePaused: function(t) {
                                this._paused || (this._paused = !0, this.time.gamePaused(), this.sound.setMute(), this.onPause.dispatch(t))
                            },
                            gameResumed: function(t) {
                                this._paused && !this._codePaused && (this._paused = !1, this.time.gameResumed(), this.input.reset(), this.sound.unsetMute(), this.onResume.dispatch(t))
                            },
                            focusLoss: function(t) {
                                this.onBlur.dispatch(t), this.stage.disableVisibilityChange || this.gamePaused(t)
                            },
                            focusGain: function(t) {
                                this.onFocus.dispatch(t), this.stage.disableVisibilityChange || this.gameResumed(t)
                            }
                        }, n.Game.prototype.constructor = n.Game, Object.defineProperty(n.Game.prototype, "paused", {
                            get: function() {
                                return this._paused
                            },
                            set: function(t) {
                                t === !0 ? (this._paused === !1 && (this._paused = !0, this.sound.setMute(), this.time.gamePaused(), this.onPause.dispatch(this)), this._codePaused = !0) : (this._paused && (this._paused = !1, this.input.reset(), this.sound.unsetMute(), this.time.gameResumed(), this.onResume.dispatch(this)), this._codePaused = !1)
                            }
                        }), n.Input = function(t) {
                            this.game = t, this.hitCanvas = null, this.hitContext = null, this.moveCallbacks = [], this.moveCallback = null, this.moveCallbackContext = this, this.pollRate = 0, this.disabled = !1, this.multiInputOverride = n.Input.MOUSE_TOUCH_COMBINE, this.position = null, this.speed = null, this.circle = null, this.scale = null, this.maxPointers = 10, this.currentPointers = 0, this.tapRate = 200, this.doubleTapRate = 300, this.holdRate = 2e3, this.justPressedRate = 200, this.justReleasedRate = 200, this.recordPointerHistory = !1, this.recordRate = 100, this.recordLimit = 100, this.pointer1 = null, this.pointer2 = null, this.pointer3 = null, this.pointer4 = null, this.pointer5 = null, this.pointer6 = null, this.pointer7 = null, this.pointer8 = null, this.pointer9 = null, this.pointer10 = null, this.activePointer = null, this.mousePointer = null, this.mouse = null, this.keyboard = null, this.touch = null, this.mspointer = null, this.gamepad = null, this.resetLocked = !1, this.onDown = null, this.onUp = null, this.onTap = null, this.onHold = null, this.minPriorityID = 0, this.interactiveItems = new n.ArrayList, this._localPoint = new n.Point, this._pollCounter = 0, this._oldPosition = null, this._x = 0, this._y = 0
                        }, n.Input.MOUSE_OVERRIDES_TOUCH = 0, n.Input.TOUCH_OVERRIDES_MOUSE = 1, n.Input.MOUSE_TOUCH_COMBINE = 2, n.Input.prototype = {
                            boot: function() {
                                this.mousePointer = new n.Pointer(this.game, 0), this.pointer1 = new n.Pointer(this.game, 1), this.pointer2 = new n.Pointer(this.game, 2), this.mouse = new n.Mouse(this.game), this.keyboard = new n.Keyboard(this.game), this.touch = new n.Touch(this.game), this.mspointer = new n.MSPointer(this.game), this.gamepad = new n.Gamepad(this.game), this.onDown = new n.Signal, this.onUp = new n.Signal, this.onTap = new n.Signal, this.onHold = new n.Signal, this.scale = new n.Point(1, 1), this.speed = new n.Point, this.position = new n.Point, this._oldPosition = new n.Point, this.circle = new n.Circle(0, 0, 44), this.activePointer = this.mousePointer, this.currentPointers = 0, this.hitCanvas = document.createElement("canvas"), this.hitCanvas.width = 1, this.hitCanvas.height = 1, this.hitContext = this.hitCanvas.getContext("2d"), this.mouse.start(), this.keyboard.start(), this.touch.start(), this.mspointer.start(), this.mousePointer.active = !0
                            },
                            destroy: function() {
                                this.mouse.stop(), this.keyboard.stop(), this.touch.stop(), this.mspointer.stop(), this.gamepad.stop(), this.moveCallbacks = [], this.moveCallback = null
                            },
                            setMoveCallback: function(t, e) {
                                this.moveCallback = t, this.moveCallbackContext = e
                            },
                            addMoveCallback: function(t, e) {
                                return this.moveCallbacks.push({
                                    callback: t,
                                    context: e
                                }) - 1
                            },
                            deleteMoveCallback: function(t) {
                                this.moveCallbacks[t] && this.moveCallbacks.splice(t, 1)
                            },
                            addPointer: function() {
                                for (var t = 0, e = 10; e > 0; e--) null === this["pointer" + e] && (t = e);
                                return 0 === t ? (console.warn("You can only have 10 Pointer objects"), null) : (this["pointer" + t] = new n.Pointer(this.game, t), this["pointer" + t])
                            },
                            update: function() {
                                return this.keyboard.update(), this.pollRate > 0 && this._pollCounter < this.pollRate ? void this._pollCounter++ : (this.speed.x = this.position.x - this._oldPosition.x, this.speed.y = this.position.y - this._oldPosition.y, this._oldPosition.copyFrom(this.position), this.mousePointer.update(), this.gamepad.active && this.gamepad.update(), this.pointer1.update(), this.pointer2.update(), this.pointer3 && this.pointer3.update(), this.pointer4 && this.pointer4.update(), this.pointer5 && this.pointer5.update(), this.pointer6 && this.pointer6.update(), this.pointer7 && this.pointer7.update(), this.pointer8 && this.pointer8.update(), this.pointer9 && this.pointer9.update(), this.pointer10 && this.pointer10.update(), void(this._pollCounter = 0))
                            },
                            reset: function(t) {
                                if (this.game.isBooted && !this.resetLocked) {
                                    "undefined" == typeof t && (t = !1), this.keyboard.reset(t), this.mousePointer.reset(), this.gamepad.reset();
                                    for (var e = 1; 10 >= e; e++) this["pointer" + e] && this["pointer" + e].reset();
                                    this.currentPointers = 0, "none" !== this.game.canvas.style.cursor && (this.game.canvas.style.cursor = "inherit"), t && (this.onDown.dispose(), this.onUp.dispose(), this.onTap.dispose(), this.onHold.dispose(), this.onDown = new n.Signal, this.onUp = new n.Signal, this.onTap = new n.Signal, this.onHold = new n.Signal, this.moveCallbacks = []), this._pollCounter = 0
                                }
                            },
                            resetSpeed: function(t, e) {
                                this._oldPosition.setTo(t, e), this.speed.setTo(0, 0)
                            },
                            startPointer: function(t) {
                                if (this.maxPointers < 10 && this.totalActivePointers == this.maxPointers) return null;
                                if (this.pointer1.active === !1) return this.pointer1.start(t);
                                if (this.pointer2.active === !1) return this.pointer2.start(t);
                                for (var e = 3; 10 >= e; e++)
                                    if (this["pointer" + e] && this["pointer" + e].active === !1) return this["pointer" + e].start(t);
                                return null
                            },
                            updatePointer: function(t) {
                                if (this.pointer1.active && this.pointer1.identifier == t.identifier) return this.pointer1.move(t);
                                if (this.pointer2.active && this.pointer2.identifier == t.identifier) return this.pointer2.move(t);
                                for (var e = 3; 10 >= e; e++)
                                    if (this["pointer" + e] && this["pointer" + e].active && this["pointer" + e].identifier == t.identifier) return this["pointer" + e].move(t);
                                return null
                            },
                            stopPointer: function(t) {
                                if (this.pointer1.active && this.pointer1.identifier == t.identifier) return this.pointer1.stop(t);
                                if (this.pointer2.active && this.pointer2.identifier == t.identifier) return this.pointer2.stop(t);
                                for (var e = 3; 10 >= e; e++)
                                    if (this["pointer" + e] && this["pointer" + e].active && this["pointer" + e].identifier == t.identifier) return this["pointer" + e].stop(t);
                                return null
                            },
                            getPointer: function(t) {
                                if (t = t || !1, this.pointer1.active == t) return this.pointer1;
                                if (this.pointer2.active == t) return this.pointer2;
                                for (var e = 3; 10 >= e; e++)
                                    if (this["pointer" + e] && this["pointer" + e].active == t) return this["pointer" + e];
                                return null
                            },
                            getPointerFromIdentifier: function(t) {
                                if (this.pointer1.identifier === t) return this.pointer1;
                                if (this.pointer2.identifier === t) return this.pointer2;
                                for (var e = 3; 10 >= e; e++)
                                    if (this["pointer" + e] && this["pointer" + e].identifier === t) return this["pointer" + e];
                                return null
                            },
                            getPointerFromId: function(t) {
                                if (this.pointer1.pointerId === t) return this.pointer1;
                                if (this.pointer2.pointerId === t) return this.pointer2;
                                for (var e = 3; 10 >= e; e++)
                                    if (this["pointer" + e] && this["pointer" + e].pointerId === t) return this["pointer" + e];
                                return null
                            },
                            getLocalPosition: function(t, e, i) {
                                "undefined" == typeof i && (i = new n.Point);
                                var s = t.worldTransform,
                                    r = 1 / (s.a * s.d + s.b * -s.c);
                                return i.setTo(s.d * r * e.x + -s.b * r * e.y + (s.ty * s.b - s.tx * s.d) * r, s.a * r * e.y + -s.c * r * e.x + (-s.ty * s.a + s.tx * s.c) * r)
                            },
                            hitTest: function(t, e, i) {
                                if (!t.worldVisible) return !1;
                                if (this.getLocalPosition(t, e, this._localPoint), i.copyFrom(this._localPoint), t.hitArea && t.hitArea.contains) return t.hitArea.contains(this._localPoint.x, this._localPoint.y) ? !0 : !1;
                                if (t instanceof n.TileSprite) {
                                    var s = t.width,
                                        r = t.height,
                                        o = -s * t.anchor.x;
                                    if (this._localPoint.x > o && this._localPoint.x < o + s) {
                                        var a = -r * t.anchor.y;
                                        if (this._localPoint.y > a && this._localPoint.y < a + r) return !0
                                    }
                                } else if (t instanceof PIXI.Sprite) {
                                    var s = t.texture.frame.width,
                                        r = t.texture.frame.height,
                                        o = -s * t.anchor.x;
                                    if (this._localPoint.x > o && this._localPoint.x < o + s) {
                                        var a = -r * t.anchor.y;
                                        if (this._localPoint.y > a && this._localPoint.y < a + r) return !0
                                    }
                                }
                                for (var h = 0, l = t.children.length; l > h; h++)
                                    if (this.hitTest(t.children[h], e, i)) return !0;
                                return !1
                            }
                        }, n.Input.prototype.constructor = n.Input, Object.defineProperty(n.Input.prototype, "x", {
                            get: function() {
                                return this._x
                            },
                            set: function(t) {
                                this._x = Math.floor(t)
                            }
                        }), Object.defineProperty(n.Input.prototype, "y", {
                            get: function() {
                                return this._y
                            },
                            set: function(t) {
                                this._y = Math.floor(t)
                            }
                        }), Object.defineProperty(n.Input.prototype, "pollLocked", {
                            get: function() {
                                return this.pollRate > 0 && this._pollCounter < this.pollRate
                            }
                        }), Object.defineProperty(n.Input.prototype, "totalInactivePointers", {
                            get: function() {
                                return 10 - this.currentPointers
                            }
                        }), Object.defineProperty(n.Input.prototype, "totalActivePointers", {
                            get: function() {
                                this.currentPointers = 0;
                                for (var t = 1; 10 >= t; t++) this["pointer" + t] && this["pointer" + t].active && this.currentPointers++;
                                return this.currentPointers
                            }
                        }), Object.defineProperty(n.Input.prototype, "worldX", {
                            get: function() {
                                return this.game.camera.view.x + this.x
                            }
                        }), Object.defineProperty(n.Input.prototype, "worldY", {
                            get: function() {
                                return this.game.camera.view.y + this.y
                            }
                        }), n.Key = function(t, e) {
                            this.game = t, this.enabled = !0, this.event = null, this.isDown = !1, this.isUp = !0, this.altKey = !1, this.ctrlKey = !1, this.shiftKey = !1, this.timeDown = 0, this.duration = 0, this.timeUp = -2500, this.repeats = 0, this.keyCode = e, this.onDown = new n.Signal, this.onHoldCallback = null, this.onHoldContext = null, this.onUp = new n.Signal
                        }, n.Key.prototype = {
                            update: function() {
                                this.enabled && this.isDown && (this.duration = this.game.time.now - this.timeDown, this.repeats++, this.onHoldCallback && this.onHoldCallback.call(this.onHoldContext, this))
                            },
                            processKeyDown: function(t) {
                                this.enabled && (this.event = t, this.isDown || (this.altKey = t.altKey, this.ctrlKey = t.ctrlKey, this.shiftKey = t.shiftKey, this.isDown = !0, this.isUp = !1, this.timeDown = this.game.time.now, this.duration = 0, this.repeats = 0, this.onDown.dispatch(this)))
                            },
                            processKeyUp: function(t) {
                                this.enabled && (this.event = t, this.isUp || (this.isDown = !1, this.isUp = !0, this.timeUp = this.game.time.now, this.duration = this.game.time.now - this.timeDown, this.onUp.dispatch(this)))
                            },
                            reset: function(t) {
                                "undefined" == typeof t && (t = !0), this.isDown = !1, this.isUp = !0, this.timeUp = this.game.time.now, this.duration = 0, this.enabled = !0, t && (this.onDown.removeAll(), this.onUp.removeAll(), this.onHoldCallback = null, this.onHoldContext = null)
                            },
                            justPressed: function(t) {
                                return "undefined" == typeof t && (t = 50), this.isDown && this.duration < t
                            },
                            justReleased: function(t) {
                                return "undefined" == typeof t && (t = 50), !this.isDown && this.game.time.now - this.timeUp < t
                            }
                        }, n.Key.prototype.constructor = n.Key, n.Keyboard = function(t) {
                            this.game = t, this.disabled = !1, this.event = null, this.pressEvent = null, this.callbackContext = this, this.onDownCallback = null, this.onPressCallback = null, this.onUpCallback = null, this._keys = [], this._capture = [], this._onKeyDown = null, this._onKeyPress = null, this._onKeyUp = null, this._i = 0, this._k = 0
                        }, n.Keyboard.prototype = {
                            addCallbacks: function(t, e, i, s) {
                                this.callbackContext = t, "undefined" != typeof e && (this.onDownCallback = e), "undefined" != typeof i && (this.onUpCallback = i), "undefined" != typeof s && (this.onPressCallback = s)
                            },
                            addKey: function(t) {
                                return this._keys[t] || (this._keys[t] = new n.Key(this.game, t), this.addKeyCapture(t)), this._keys[t]
                            },
                            removeKey: function(t) {
                                this._keys[t] && (this._keys[t] = null, this.removeKeyCapture(t))
                            },
                            createCursorKeys: function() {
                                return {
                                    up: this.addKey(n.Keyboard.UP),
                                    down: this.addKey(n.Keyboard.DOWN),
                                    left: this.addKey(n.Keyboard.LEFT),
                                    right: this.addKey(n.Keyboard.RIGHT)
                                }
                            },
                            start: function() {
                                if (!this.game.device.cocoonJS && null === this._onKeyDown) {
                                    var t = this;
                                    this._onKeyDown = function(e) {
                                        return t.processKeyDown(e)
                                    }, this._onKeyUp = function(e) {
                                        return t.processKeyUp(e)
                                    }, this._onKeyPress = function(e) {
                                        return t.processKeyPress(e)
                                    }, window.addEventListener("keydown", this._onKeyDown, !1), window.addEventListener("keyup", this._onKeyUp, !1), window.addEventListener("keypress", this._onKeyPress, !1)
                                }
                            },
                            stop: function() {
                                window.removeEventListener("keydown", this._onKeyDown), window.removeEventListener("keyup", this._onKeyUp), window.removeEventListener("keypress", this._onKeyPress), this._onKeyDown = null, this._onKeyUp = null, this._onKeyPress = null
                            },
                            destroy: function() {
                                this.stop(), this.clearCaptures(), this._keys.length = 0, this._i = 0
                            },
                            addKeyCapture: function(t) {
                                if ("object" == typeof t)
                                    for (var e in t) this._capture[t[e]] = !0;
                                else this._capture[t] = !0
                            },
                            removeKeyCapture: function(t) {
                                delete this._capture[t]
                            },
                            clearCaptures: function() {
                                this._capture = {}
                            },
                            update: function() {
                                for (this._i = this._keys.length; this._i--;) this._keys[this._i] && this._keys[this._i].update()
                            },
                            processKeyDown: function(t) {
                                this.event = t, this.game.input.disabled || this.disabled || (this._capture[t.keyCode] && t.preventDefault(), this._keys[t.keyCode] || (this._keys[t.keyCode] = new n.Key(this.game, t.keyCode)), this._keys[t.keyCode].processKeyDown(t), this._k = t.keyCode, this.onDownCallback && this.onDownCallback.call(this.callbackContext, t))
                            },
                            processKeyPress: function(t) {
                                this.pressEvent = t, this.game.input.disabled || this.disabled || this.onPressCallback && this.onPressCallback.call(this.callbackContext, String.fromCharCode(t.charCode), t)
                            },
                            processKeyUp: function(t) {
                                this.event = t, this.game.input.disabled || this.disabled || (this._capture[t.keyCode] && t.preventDefault(), this._keys[t.keyCode] || (this._keys[t.keyCode] = new n.Key(this.game, t.keyCode)), this._keys[t.keyCode].processKeyUp(t), this.onUpCallback && this.onUpCallback.call(this.callbackContext, t))
                            },
                            reset: function(t) {
                                "undefined" == typeof t && (t = !0), this.event = null;
                                for (var e = this._keys.length; e--;) this._keys[e] && this._keys[e].reset(t)
                            },
                            justPressed: function(t, e) {
                                return "undefined" == typeof e && (e = 50), this._keys[t] ? this._keys[t].justPressed(e) : !1
                            },
                            justReleased: function(t, e) {
                                return "undefined" == typeof e && (e = 50), this._keys[t] ? this._keys[t].justReleased(e) : !1
                            },
                            isDown: function(t) {
                                return this._keys[t] ? this._keys[t].isDown : !1
                            }
                        }, Object.defineProperty(n.Keyboard.prototype, "lastChar", {
                            get: function() {
                                return 32 === this.event.charCode ? "" : String.fromCharCode(this.pressEvent.charCode)
                            }
                        }), Object.defineProperty(n.Keyboard.prototype, "lastKey", {
                            get: function() {
                                return this._keys[this._k]
                            }
                        }), n.Keyboard.prototype.constructor = n.Keyboard, n.Keyboard.A = "A".charCodeAt(0), n.Keyboard.B = "B".charCodeAt(0), n.Keyboard.C = "C".charCodeAt(0), n.Keyboard.D = "D".charCodeAt(0), n.Keyboard.E = "E".charCodeAt(0), n.Keyboard.F = "F".charCodeAt(0), n.Keyboard.G = "G".charCodeAt(0), n.Keyboard.H = "H".charCodeAt(0), n.Keyboard.I = "I".charCodeAt(0), n.Keyboard.J = "J".charCodeAt(0), n.Keyboard.K = "K".charCodeAt(0), n.Keyboard.L = "L".charCodeAt(0), n.Keyboard.M = "M".charCodeAt(0), n.Keyboard.N = "N".charCodeAt(0), n.Keyboard.O = "O".charCodeAt(0), n.Keyboard.P = "P".charCodeAt(0), n.Keyboard.Q = "Q".charCodeAt(0), n.Keyboard.R = "R".charCodeAt(0), n.Keyboard.S = "S".charCodeAt(0), n.Keyboard.T = "T".charCodeAt(0), n.Keyboard.U = "U".charCodeAt(0), n.Keyboard.V = "V".charCodeAt(0), n.Keyboard.W = "W".charCodeAt(0), n.Keyboard.X = "X".charCodeAt(0), n.Keyboard.Y = "Y".charCodeAt(0), n.Keyboard.Z = "Z".charCodeAt(0), n.Keyboard.ZERO = "0".charCodeAt(0), n.Keyboard.ONE = "1".charCodeAt(0), n.Keyboard.TWO = "2".charCodeAt(0), n.Keyboard.THREE = "3".charCodeAt(0), n.Keyboard.FOUR = "4".charCodeAt(0), n.Keyboard.FIVE = "5".charCodeAt(0), n.Keyboard.SIX = "6".charCodeAt(0), n.Keyboard.SEVEN = "7".charCodeAt(0), n.Keyboard.EIGHT = "8".charCodeAt(0), n.Keyboard.NINE = "9".charCodeAt(0), n.Keyboard.NUMPAD_0 = 96, n.Keyboard.NUMPAD_1 = 97, n.Keyboard.NUMPAD_2 = 98, n.Keyboard.NUMPAD_3 = 99, n.Keyboard.NUMPAD_4 = 100, n.Keyboard.NUMPAD_5 = 101, n.Keyboard.NUMPAD_6 = 102, n.Keyboard.NUMPAD_7 = 103, n.Keyboard.NUMPAD_8 = 104, n.Keyboard.NUMPAD_9 = 105, n.Keyboard.NUMPAD_MULTIPLY = 106, n.Keyboard.NUMPAD_ADD = 107, n.Keyboard.NUMPAD_ENTER = 108, n.Keyboard.NUMPAD_SUBTRACT = 109, n.Keyboard.NUMPAD_DECIMAL = 110, n.Keyboard.NUMPAD_DIVIDE = 111, n.Keyboard.F1 = 112, n.Keyboard.F2 = 113, n.Keyboard.F3 = 114, n.Keyboard.F4 = 115, n.Keyboard.F5 = 116, n.Keyboard.F6 = 117, n.Keyboard.F7 = 118, n.Keyboard.F8 = 119, n.Keyboard.F9 = 120, n.Keyboard.F10 = 121, n.Keyboard.F11 = 122, n.Keyboard.F12 = 123, n.Keyboard.F13 = 124, n.Keyboard.F14 = 125, n.Keyboard.F15 = 126, n.Keyboard.COLON = 186, n.Keyboard.EQUALS = 187, n.Keyboard.UNDERSCORE = 189, n.Keyboard.QUESTION_MARK = 191, n.Keyboard.TILDE = 192, n.Keyboard.OPEN_BRACKET = 219, n.Keyboard.BACKWARD_SLASH = 220, n.Keyboard.CLOSED_BRACKET = 221, n.Keyboard.QUOTES = 222, n.Keyboard.BACKSPACE = 8, n.Keyboard.TAB = 9, n.Keyboard.CLEAR = 12, n.Keyboard.ENTER = 13, n.Keyboard.SHIFT = 16, n.Keyboard.CONTROL = 17, n.Keyboard.ALT = 18, n.Keyboard.CAPS_LOCK = 20, n.Keyboard.ESC = 27, n.Keyboard.SPACEBAR = 32, n.Keyboard.PAGE_UP = 33, n.Keyboard.PAGE_DOWN = 34, n.Keyboard.END = 35, n.Keyboard.HOME = 36, n.Keyboard.LEFT = 37, n.Keyboard.UP = 38, n.Keyboard.RIGHT = 39, n.Keyboard.DOWN = 40, n.Keyboard.INSERT = 45, n.Keyboard.DELETE = 46, n.Keyboard.HELP = 47, n.Keyboard.NUM_LOCK = 144, n.Mouse = function(t) {
                            this.game = t, this.callbackContext = this.game, this.mouseDownCallback = null, this.mouseMoveCallback = null, this.mouseUpCallback = null, this.mouseOutCallback = null, this.mouseOverCallback = null, this.mouseWheelCallback = null, this.capture = !1, this.button = -1, this.wheelDelta = 0, this.disabled = !1, this.locked = !1, this.stopOnGameOut = !1, this.pointerLock = new n.Signal, this.event = null, this._onMouseDown = null, this._onMouseMove = null, this._onMouseUp = null, this._onMouseOut = null, this._onMouseOver = null, this._onMouseWheel = null
                        }, n.Mouse.NO_BUTTON = -1, n.Mouse.LEFT_BUTTON = 0, n.Mouse.MIDDLE_BUTTON = 1, n.Mouse.RIGHT_BUTTON = 2, n.Mouse.WHEEL_UP = 1, n.Mouse.WHEEL_DOWN = -1, n.Mouse.prototype = {
                            start: function() {
                                if ((!this.game.device.android || this.game.device.chrome !== !1) && null === this._onMouseDown) {
                                    var t = this;
                                    this._onMouseDown = function(e) {
                                        return t.onMouseDown(e)
                                    }, this._onMouseMove = function(e) {
                                        return t.onMouseMove(e)
                                    }, this._onMouseUp = function(e) {
                                        return t.onMouseUp(e)
                                    }, this._onMouseOut = function(e) {
                                        return t.onMouseOut(e)
                                    }, this._onMouseOver = function(e) {
                                        return t.onMouseOver(e)
                                    }, this._onMouseWheel = function(e) {
                                        return t.onMouseWheel(e)
                                    }, this.game.canvas.addEventListener("mousedown", this._onMouseDown, !0), this.game.canvas.addEventListener("mousemove", this._onMouseMove, !0), this.game.canvas.addEventListener("mouseup", this._onMouseUp, !0), this.game.canvas.addEventListener("mousewheel", this._onMouseWheel, !0), this.game.canvas.addEventListener("DOMMouseScroll", this._onMouseWheel, !0), this.game.device.cocoonJS || (this.game.canvas.addEventListener("mouseover", this._onMouseOver, !0), this.game.canvas.addEventListener("mouseout", this._onMouseOut, !0))
                                }
                            },
                            onMouseDown: function(t) {
                                this.event = t, this.capture && t.preventDefault(), this.button = t.button, this.mouseDownCallback && this.mouseDownCallback.call(this.callbackContext, t), this.game.input.disabled || this.disabled || (t.identifier = 0, this.game.input.mousePointer.start(t))
                            },
                            onMouseMove: function(t) {
                                this.event = t, this.capture && t.preventDefault(), this.mouseMoveCallback && this.mouseMoveCallback.call(this.callbackContext, t), this.game.input.disabled || this.disabled || (t.identifier = 0, this.game.input.mousePointer.move(t))
                            },
                            onMouseUp: function(t) {
                                this.event = t, this.capture && t.preventDefault(), this.button = n.Mouse.NO_BUTTON, this.mouseUpCallback && this.mouseUpCallback.call(this.callbackContext, t), this.game.input.disabled || this.disabled || (t.identifier = 0, this.game.input.mousePointer.stop(t))
                            },
                            onMouseOut: function(t) {
                                this.event = t, this.capture && t.preventDefault(), this.mouseOutCallback && this.mouseOutCallback.call(this.callbackContext, t), this.game.input.disabled || this.disabled || (this.game.input.mousePointer.withinGame = !1, this.stopOnGameOut && (t.identifier = 0, this.game.input.mousePointer.stop(t)))
                            },
                            onMouseWheel: function(t) {
                                this.event = t, this.capture && t.preventDefault(), this.wheelDelta = Math.max(-1, Math.min(1, t.wheelDelta || -t.detail)), this.mouseWheelCallback && this.mouseWheelCallback.call(this.callbackContext, t)
                            },
                            onMouseOver: function(t) {
                                this.event = t, this.capture && t.preventDefault(), this.mouseOverCallback && this.mouseOverCallback.call(this.callbackContext, t), this.game.input.disabled || this.disabled || (this.game.input.mousePointer.withinGame = !0)
                            },
                            requestPointerLock: function() {
                                if (this.game.device.pointerLock) {
                                    var t = this.game.canvas;
                                    t.requestPointerLock = t.requestPointerLock || t.mozRequestPointerLock || t.webkitRequestPointerLock, t.requestPointerLock();
                                    var e = this;
                                    this._pointerLockChange = function(t) {
                                        return e.pointerLockChange(t)
                                    }, document.addEventListener("pointerlockchange", this._pointerLockChange, !0), document.addEventListener("mozpointerlockchange", this._pointerLockChange, !0), document.addEventListener("webkitpointerlockchange", this._pointerLockChange, !0)
                                }
                            },
                            pointerLockChange: function(t) {
                                var e = this.game.canvas;
                                document.pointerLockElement === e || document.mozPointerLockElement === e || document.webkitPointerLockElement === e ? (this.locked = !0, this.pointerLock.dispatch(!0, t)) : (this.locked = !1, this.pointerLock.dispatch(!1, t))
                            },
                            releasePointerLock: function() {
                                document.exitPointerLock = document.exitPointerLock || document.mozExitPointerLock || document.webkitExitPointerLock, document.exitPointerLock(), document.removeEventListener("pointerlockchange", this._pointerLockChange, !0), document.removeEventListener("mozpointerlockchange", this._pointerLockChange, !0), document.removeEventListener("webkitpointerlockchange", this._pointerLockChange, !0)
                            },
                            stop: function() {
                                this.game.canvas.removeEventListener("mousedown", this._onMouseDown, !0), this.game.canvas.removeEventListener("mousemove", this._onMouseMove, !0), this.game.canvas.removeEventListener("mouseup", this._onMouseUp, !0), this.game.canvas.removeEventListener("mouseover", this._onMouseOver, !0), this.game.canvas.removeEventListener("mouseout", this._onMouseOut, !0), this.game.canvas.removeEventListener("mousewheel", this._onMouseWheel, !0), this.game.canvas.removeEventListener("DOMMouseScroll", this._onMouseWheel, !0)
                            }
                        }, n.Mouse.prototype.constructor = n.Mouse, n.MSPointer = function(t) {
                            this.game = t, this.callbackContext = this.game, this.disabled = !1, this._onMSPointerDown = null, this._onMSPointerMove = null, this._onMSPointerUp = null
                        }, n.MSPointer.prototype = {
                            start: function() {
                                if (null === this._onMSPointerDown) {
                                    var t = this;
                                    this.game.device.mspointer === !0 && (this._onMSPointerDown = function(e) {
                                        return t.onPointerDown(e)
                                    }, this._onMSPointerMove = function(e) {
                                        return t.onPointerMove(e)
                                    }, this._onMSPointerUp = function(e) {
                                        return t.onPointerUp(e)
                                    }, this.game.renderer.view.addEventListener("MSPointerDown", this._onMSPointerDown, !1), this.game.renderer.view.addEventListener("MSPointerMove", this._onMSPointerMove, !1), this.game.renderer.view.addEventListener("MSPointerUp", this._onMSPointerUp, !1), this.game.renderer.view.addEventListener("pointerDown", this._onMSPointerDown, !1), this.game.renderer.view.addEventListener("pointerMove", this._onMSPointerMove, !1), this.game.renderer.view.addEventListener("pointerUp", this._onMSPointerUp, !1), this.game.renderer.view.style["-ms-content-zooming"] = "none", this.game.renderer.view.style["-ms-touch-action"] = "none")
                                }
                            },
                            onPointerDown: function(t) {
                                this.game.input.disabled || this.disabled || (t.preventDefault(), t.identifier = t.pointerId, this.game.input.startPointer(t))
                            },
                            onPointerMove: function(t) {
                                this.game.input.disabled || this.disabled || (t.preventDefault(), t.identifier = t.pointerId, this.game.input.updatePointer(t))
                            },
                            onPointerUp: function(t) {
                                this.game.input.disabled || this.disabled || (t.preventDefault(), t.identifier = t.pointerId, this.game.input.stopPointer(t))
                            },
                            stop: function() {
                                this.game.canvas.removeEventListener("MSPointerDown", this._onMSPointerDown), this.game.canvas.removeEventListener("MSPointerMove", this._onMSPointerMove), this.game.canvas.removeEventListener("MSPointerUp", this._onMSPointerUp), this.game.canvas.removeEventListener("pointerDown", this._onMSPointerDown), this.game.canvas.removeEventListener("pointerMove", this._onMSPointerMove), this.game.canvas.removeEventListener("pointerUp", this._onMSPointerUp)
                            }
                        }, n.MSPointer.prototype.constructor = n.MSPointer, n.Pointer = function(t, e) {
                            this.game = t, this.id = e, this.type = n.POINTER, this.exists = !0, this.identifier = 0, this.pointerId = null, this.target = null, this.button = null, this._holdSent = !1, this._history = [], this._nextDrop = 0, this._stateReset = !1, this.withinGame = !1, this.clientX = -1, this.clientY = -1, this.pageX = -1, this.pageY = -1, this.screenX = -1, this.screenY = -1, this.rawMovementX = 0, this.rawMovementY = 0, this.movementX = 0, this.movementY = 0, this.x = -1, this.y = -1, this.isMouse = !1, this.isDown = !1, this.isUp = !0, this.timeDown = 0, this.timeUp = 0, this.previousTapTime = 0, this.totalTouches = 0, this.msSinceLastClick = Number.MAX_VALUE, this.targetObject = null, this.active = !1, this.position = new n.Point, this.positionDown = new n.Point, this.positionUp = new n.Point, this.circle = new n.Circle(0, 0, 44), 0 === e && (this.isMouse = !0)
                        }, n.Pointer.prototype = {
                            start: function(t) {
                                return t.pointerId && (this.pointerId = t.pointerId), this.identifier = t.identifier, this.target = t.target, "undefined" != typeof t.button && (this.button = t.button), this._history = [], this.active = !0, this.withinGame = !0, this.isDown = !0, this.isUp = !1, this.msSinceLastClick = this.game.time.now - this.timeDown, this.timeDown = this.game.time.now, this._holdSent = !1, this.move(t, !0), this.positionDown.setTo(this.x, this.y), (this.game.input.multiInputOverride === n.Input.MOUSE_OVERRIDES_TOUCH || this.game.input.multiInputOverride === n.Input.MOUSE_TOUCH_COMBINE || this.game.input.multiInputOverride === n.Input.TOUCH_OVERRIDES_MOUSE && 0 === this.game.input.currentPointers) && (this.game.input.x = this.x, this.game.input.y = this.y, this.game.input.position.setTo(this.x, this.y), this.game.input.onDown.dispatch(this, t), this.game.input.resetSpeed(this.x, this.y)), this._stateReset = !1, this.totalTouches++, this.isMouse || this.game.input.currentPointers++, null !== this.targetObject && this.targetObject._touchedHandler(this), this
                            },
                            update: function() {
                                this.active && (this._holdSent === !1 && this.duration >= this.game.input.holdRate && ((this.game.input.multiInputOverride == n.Input.MOUSE_OVERRIDES_TOUCH || this.game.input.multiInputOverride == n.Input.MOUSE_TOUCH_COMBINE || this.game.input.multiInputOverride == n.Input.TOUCH_OVERRIDES_MOUSE && 0 === this.game.input.currentPointers) && this.game.input.onHold.dispatch(this), this._holdSent = !0), this.game.input.recordPointerHistory && this.game.time.now >= this._nextDrop && (this._nextDrop = this.game.time.now + this.game.input.recordRate, this._history.push({
                                    x: this.position.x,
                                    y: this.position.y
                                }), this._history.length > this.game.input.recordLimit && this._history.shift()))
                            },
                            move: function(t, e) {
                                if (!this.game.input.pollLocked) {
                                    if ("undefined" == typeof e && (e = !1), "undefined" != typeof t.button && (this.button = t.button), this.clientX = t.clientX, this.clientY = t.clientY, this.pageX = t.pageX, this.pageY = t.pageY, this.screenX = t.screenX, this.screenY = t.screenY, this.isMouse && this.game.input.mouse.locked && !e && (this.rawMovementX = t.movementX || t.mozMovementX || t.webkitMovementX || 0, this.rawMovementY = t.movementY || t.mozMovementY || t.webkitMovementY || 0, this.movementX += this.rawMovementX, this.movementY += this.rawMovementY), this.x = (this.pageX - this.game.stage.offset.x) * this.game.input.scale.x, this.y = (this.pageY - this.game.stage.offset.y) * this.game.input.scale.y, this.position.setTo(this.x, this.y), this.circle.x = this.x, this.circle.y = this.y, (this.game.input.multiInputOverride === n.Input.MOUSE_OVERRIDES_TOUCH || this.game.input.multiInputOverride === n.Input.MOUSE_TOUCH_COMBINE || this.game.input.multiInputOverride === n.Input.TOUCH_OVERRIDES_MOUSE && 0 === this.game.input.currentPointers) && (this.game.input.activePointer = this, this.game.input.x = this.x, this.game.input.y = this.y, this.game.input.position.setTo(this.game.input.x, this.game.input.y), this.game.input.circle.x = this.game.input.x, this.game.input.circle.y = this.game.input.y), this.withinGame = this.game.scale.bounds.contains(this.pageX, this.pageY), this.game.paused) return this;
                                    this.game.input.moveCallback && this.game.input.moveCallback.call(this.game.input.moveCallbackContext, this, this.x, this.y);
                                    for (var i = this.game.input.moveCallbacks.length; i--;) this.game.input.moveCallbacks[i].callback.call(this.game.input.moveCallbacks[i].context, this, this.x, this.y);
                                    return null !== this.targetObject && this.targetObject.isDragged === !0 ? (this.targetObject.update(this) === !1 && (this.targetObject = null), this) : (this.game.input.interactiveItems.total > 0 && this.processInteractiveObjects(e), this)
                                }
                            },
                            processInteractiveObjects: function(t) {
                                this.game.input.interactiveItems.setAll("checked", !1), this._highestRenderOrderID = Number.MAX_SAFE_INTEGER, this._highestRenderObject = null, this._highestInputPriorityID = -1;
                                var e = this.game.input.interactiveItems.first;
                                do e && e.validForInput(this._highestInputPriorityID, this._highestRenderOrderID, !1) && (e.checked = !0, (t && e.checkPointerDown(this, !0) || !t && e.checkPointerOver(this, !0)) && (this._highestRenderOrderID = e.sprite._cache[3], this._highestInputPriorityID = e.priorityID, this._highestRenderObject = e)), e = this.game.input.interactiveItems.next; while (null !== e);
                                var e = this.game.input.interactiveItems.first;
                                do e && !e.checked && e.validForInput(this._highestInputPriorityID, this._highestRenderOrderID, !0) && (t && e.checkPointerDown(this, !1) || !t && e.checkPointerOver(this, !1)) && (this._highestRenderOrderID = e.sprite._cache[3], this._highestInputPriorityID = e.priorityID, this._highestRenderObject = e), e = this.game.input.interactiveItems.next; while (null !== e);
                                null === this._highestRenderObject ? this.targetObject && (this.targetObject._pointerOutHandler(this), this.targetObject = null) : null === this.targetObject ? (this.targetObject = this._highestRenderObject, this._highestRenderObject._pointerOverHandler(this)) : this.targetObject === this._highestRenderObject ? this._highestRenderObject.update(this) === !1 && (this.targetObject = null) : (this.targetObject._pointerOutHandler(this), this.targetObject = this._highestRenderObject, this.targetObject._pointerOverHandler(this))
                            },
                            leave: function(t) {
                                this.withinGame = !1, this.move(t, !1)
                            },
                            stop: function(t) {
                                return this._stateReset ? void t.preventDefault() : (this.timeUp = this.game.time.now, (this.game.input.multiInputOverride === n.Input.MOUSE_OVERRIDES_TOUCH || this.game.input.multiInputOverride === n.Input.MOUSE_TOUCH_COMBINE || this.game.input.multiInputOverride === n.Input.TOUCH_OVERRIDES_MOUSE && 0 === this.game.input.currentPointers) && (this.game.input.onUp.dispatch(this, t), this.duration >= 0 && this.duration <= this.game.input.tapRate && (this.timeUp - this.previousTapTime < this.game.input.doubleTapRate ? this.game.input.onTap.dispatch(this, !0) : this.game.input.onTap.dispatch(this, !1), this.previousTapTime = this.timeUp)), this.id > 0 && (this.active = !1), this.withinGame = !1, this.isDown = !1, this.isUp = !0, this.pointerId = null, this.identifier = null, this.positionUp.setTo(this.x, this.y), this.isMouse === !1 && this.game.input.currentPointers--, this.game.input.interactiveItems.callAll("_releasedHandler", this), this.targetObject = null, this)
                            },
                            justPressed: function(t) {
                                return t = t || this.game.input.justPressedRate, this.isDown === !0 && this.timeDown + t > this.game.time.now
                            },
                            justReleased: function(t) {
                                return t = t || this.game.input.justReleasedRate, this.isUp === !0 && this.timeUp + t > this.game.time.now
                            },
                            reset: function() {
                                this.isMouse === !1 && (this.active = !1), this.pointerId = null, this.identifier = null, this.isDown = !1, this.isUp = !0, this.totalTouches = 0, this._holdSent = !1, this._history.length = 0, this._stateReset = !0, this.targetObject && this.targetObject._releasedHandler(this), this.targetObject = null
                            },
                            resetMovement: function() {
                                this.movementX = 0, this.movementY = 0
                            }
                        }, n.Pointer.prototype.constructor = n.Pointer, Object.defineProperty(n.Pointer.prototype, "duration", {
                            get: function() {
                                return this.isUp ? -1 : this.game.time.now - this.timeDown
                            }
                        }), Object.defineProperty(n.Pointer.prototype, "worldX", {
                            get: function() {
                                return this.game.world.camera.x + this.x
                            }
                        }), Object.defineProperty(n.Pointer.prototype, "worldY", {
                            get: function() {
                                return this.game.world.camera.y + this.y
                            }
                        }), n.Touch = function(t) {
                            this.game = t, this.disabled = !1, this.callbackContext = this.game, this.touchStartCallback = null, this.touchMoveCallback = null, this.touchEndCallback = null, this.touchEnterCallback = null, this.touchLeaveCallback = null, this.touchCancelCallback = null, this.preventDefault = !0, this.event = null, this._onTouchStart = null, this._onTouchMove = null, this._onTouchEnd = null, this._onTouchEnter = null, this._onTouchLeave = null, this._onTouchCancel = null, this._onTouchMove = null
                        }, n.Touch.prototype = {
                            start: function() {
                                if (null === this._onTouchStart) {
                                    var t = this;
                                    this.game.device.touch && (this._onTouchStart = function(e) {
                                        return t.onTouchStart(e)
                                    }, this._onTouchMove = function(e) {
                                        return t.onTouchMove(e)
                                    }, this._onTouchEnd = function(e) {
                                        return t.onTouchEnd(e)
                                    }, this._onTouchEnter = function(e) {
                                        return t.onTouchEnter(e)
                                    }, this._onTouchLeave = function(e) {
                                        return t.onTouchLeave(e)
                                    }, this._onTouchCancel = function(e) {
                                        return t.onTouchCancel(e)
                                    }, this.game.canvas.addEventListener("touchstart", this._onTouchStart, !1), this.game.canvas.addEventListener("touchmove", this._onTouchMove, !1), this.game.canvas.addEventListener("touchend", this._onTouchEnd, !1), this.game.canvas.addEventListener("touchcancel", this._onTouchCancel, !1), this.game.device.cocoonJS || (this.game.canvas.addEventListener("touchenter", this._onTouchEnter, !1), this.game.canvas.addEventListener("touchleave", this._onTouchLeave, !1)))
                                }
                            },
                            consumeDocumentTouches: function() {
                                this._documentTouchMove = function(t) {
                                    t.preventDefault()
                                }, document.addEventListener("touchmove", this._documentTouchMove, !1)
                            },
                            onTouchStart: function(t) {
                                if (this.event = t, this.touchStartCallback && this.touchStartCallback.call(this.callbackContext, t), !this.game.input.disabled && !this.disabled) {
                                    this.preventDefault && t.preventDefault();
                                    for (var e = 0; e < t.changedTouches.length; e++) this.game.input.startPointer(t.changedTouches[e])
                                }
                            },
                            onTouchCancel: function(t) {
                                if (this.event = t, this.touchCancelCallback && this.touchCancelCallback.call(this.callbackContext, t), !this.game.input.disabled && !this.disabled) {
                                    this.preventDefault && t.preventDefault();
                                    for (var e = 0; e < t.changedTouches.length; e++) this.game.input.stopPointer(t.changedTouches[e])
                                }
                            },
                            onTouchEnter: function(t) {
                                this.event = t, this.touchEnterCallback && this.touchEnterCallback.call(this.callbackContext, t), this.game.input.disabled || this.disabled || this.preventDefault && t.preventDefault()
                            },
                            onTouchLeave: function(t) {
                                this.event = t, this.touchLeaveCallback && this.touchLeaveCallback.call(this.callbackContext, t), this.preventDefault && t.preventDefault()
                            },
                            onTouchMove: function(t) {
                                this.event = t, this.touchMoveCallback && this.touchMoveCallback.call(this.callbackContext, t), this.preventDefault && t.preventDefault();
                                for (var e = 0; e < t.changedTouches.length; e++) this.game.input.updatePointer(t.changedTouches[e])
                            },
                            onTouchEnd: function(t) {
                                this.event = t, this.touchEndCallback && this.touchEndCallback.call(this.callbackContext, t), this.preventDefault && t.preventDefault();
                                for (var e = 0; e < t.changedTouches.length; e++) this.game.input.stopPointer(t.changedTouches[e])
                            },
                            stop: function() {
                                this.game.device.touch && (this.game.canvas.removeEventListener("touchstart", this._onTouchStart), this.game.canvas.removeEventListener("touchmove", this._onTouchMove), this.game.canvas.removeEventListener("touchend", this._onTouchEnd), this.game.canvas.removeEventListener("touchenter", this._onTouchEnter), this.game.canvas.removeEventListener("touchleave", this._onTouchLeave), this.game.canvas.removeEventListener("touchcancel", this._onTouchCancel))
                            }
                        }, n.Touch.prototype.constructor = n.Touch, n.Gamepad = function(t) {
                            this.game = t, this._gamepads = [new n.SinglePad(t, this), new n.SinglePad(t, this), new n.SinglePad(t, this), new n.SinglePad(t, this)], this._gamepadIndexMap = {}, this._rawPads = [], this._active = !1, this.disabled = !1, this._gamepadSupportAvailable = !!navigator.webkitGetGamepads || !!navigator.webkitGamepads || -1 != navigator.userAgent.indexOf("Firefox/") || !!navigator.getGamepads, this._prevRawGamepadTypes = [], this._prevTimestamps = [], this.callbackContext = this, this.onConnectCallback = null, this.onDisconnectCallback = null, this.onDownCallback = null, this.onUpCallback = null, this.onAxisCallback = null, this.onFloatCallback = null, this._ongamepadconnected = null, this._gamepaddisconnected = null
                        }, n.Gamepad.prototype = {
                            addCallbacks: function(t, e) {
                                "undefined" != typeof e && (this.onConnectCallback = "function" == typeof e.onConnect ? e.onConnect : this.onConnectCallback, this.onDisconnectCallback = "function" == typeof e.onDisconnect ? e.onDisconnect : this.onDisconnectCallback, this.onDownCallback = "function" == typeof e.onDown ? e.onDown : this.onDownCallback, this.onUpCallback = "function" == typeof e.onUp ? e.onUp : this.onUpCallback, this.onAxisCallback = "function" == typeof e.onAxis ? e.onAxis : this.onAxisCallback, this.onFloatCallback = "function" == typeof e.onFloat ? e.onFloat : this.onFloatCallback)
                            },
                            start: function() {
                                if (!this._active) {
                                    this._active = !0;
                                    var t = this;
                                    this._ongamepadconnected = function(e) {
                                        var i = e.gamepad;
                                        t._rawPads.push(i), t._gamepads[i.index].connect(i)
                                    }, window.addEventListener("gamepadconnected", this._ongamepadconnected, !1), this._ongamepaddisconnected = function(e) {
                                        var i = e.gamepad;
                                        for (var s in t._rawPads) t._rawPads[s].index === i.index && t._rawPads.splice(s, 1);
                                        t._gamepads[i.index].disconnect()
                                    }, window.addEventListener("gamepaddisconnected", this._ongamepaddisconnected, !1)
                                }
                            },
                            update: function() {
                                this._pollGamepads(), this.pad1.pollStatus(), this.pad2.pollStatus(), this.pad3.pollStatus(), this.pad4.pollStatus()
                            },
                            _pollGamepads: function() {
                                if (navigator.getGamepads) var t = navigator.getGamepads();
                                else if (navigator.webkitGetGamepads) var t = navigator.webkitGetGamepads();
                                else if (navigator.webkitGamepads) var t = navigator.webkitGamepads();
                                if (t) {
                                    this._rawPads = [];
                                    for (var e = !1, i = 0; i < t.length && (typeof t[i] !== this._prevRawGamepadTypes[i] && (e = !0, this._prevRawGamepadTypes[i] = typeof t[i]), t[i] && this._rawPads.push(t[i]), 3 !== i); i++);
                                    if (e) {
                                        for (var s, n = {
                                                rawIndices: {},
                                                padIndices: {}
                                            }, r = 0; r < this._gamepads.length; r++)
                                            if (s = this._gamepads[r], s.connected)
                                                for (var o = 0; o < this._rawPads.length; o++) this._rawPads[o].index === s.index && (n.rawIndices[s.index] = !0, n.padIndices[r] = !0);
                                        for (var a = 0; a < this._gamepads.length; a++)
                                            if (s = this._gamepads[a], !n.padIndices[a]) {
                                                this._rawPads.length < 1 && s.disconnect();
                                                for (var h = 0; h < this._rawPads.length && !n.padIndices[a]; h++) {
                                                    var l = this._rawPads[h];
                                                    if (l) {
                                                        if (n.rawIndices[l.index]) {
                                                            s.disconnect();
                                                            continue
                                                        }
                                                        s.connect(l), n.rawIndices[l.index] = !0, n.padIndices[a] = !0
                                                    } else s.disconnect()
                                                }
                                            }
                                    }
                                }
                            },
                            setDeadZones: function(t) {
                                for (var e = 0; e < this._gamepads.length; e++) this._gamepads[e].deadZone = t
                            },
                            stop: function() {
                                this._active = !1, window.removeEventListener("gamepadconnected", this._ongamepadconnected), window.removeEventListener("gamepaddisconnected", this._ongamepaddisconnected)
                            },
                            reset: function() {
                                this.update();
                                for (var t = 0; t < this._gamepads.length; t++) this._gamepads[t].reset()
                            },
                            justPressed: function(t, e) {
                                for (var i = 0; i < this._gamepads.length; i++)
                                    if (this._gamepads[i].justPressed(t, e) === !0) return !0;
                                return !1
                            },
                            justReleased: function(t, e) {
                                for (var i = 0; i < this._gamepads.length; i++)
                                    if (this._gamepads[i].justReleased(t, e) === !0) return !0;
                                return !1
                            },
                            isDown: function(t) {
                                for (var e = 0; e < this._gamepads.length; e++)
                                    if (this._gamepads[e].isDown(t) === !0) return !0;
                                return !1
                            }
                        }, n.Gamepad.prototype.constructor = n.Gamepad, Object.defineProperty(n.Gamepad.prototype, "active", {
                            get: function() {
                                return this._active
                            }
                        }), Object.defineProperty(n.Gamepad.prototype, "supported", {
                            get: function() {
                                return this._gamepadSupportAvailable
                            }
                        }), Object.defineProperty(n.Gamepad.prototype, "padsConnected", {
                            get: function() {
                                return this._rawPads.length
                            }
                        }), Object.defineProperty(n.Gamepad.prototype, "pad1", {
                            get: function() {
                                return this._gamepads[0]
                            }
                        }), Object.defineProperty(n.Gamepad.prototype, "pad2", {
                            get: function() {
                                return this._gamepads[1]
                            }
                        }), Object.defineProperty(n.Gamepad.prototype, "pad3", {
                            get: function() {
                                return this._gamepads[2]
                            }
                        }), Object.defineProperty(n.Gamepad.prototype, "pad4", {
                            get: function() {
                                return this._gamepads[3]
                            }
                        }), n.Gamepad.BUTTON_0 = 0, n.Gamepad.BUTTON_1 = 1, n.Gamepad.BUTTON_2 = 2, n.Gamepad.BUTTON_3 = 3, n.Gamepad.BUTTON_4 = 4, n.Gamepad.BUTTON_5 = 5, n.Gamepad.BUTTON_6 = 6, n.Gamepad.BUTTON_7 = 7, n.Gamepad.BUTTON_8 = 8, n.Gamepad.BUTTON_9 = 9, n.Gamepad.BUTTON_10 = 10, n.Gamepad.BUTTON_11 = 11, n.Gamepad.BUTTON_12 = 12, n.Gamepad.BUTTON_13 = 13, n.Gamepad.BUTTON_14 = 14, n.Gamepad.BUTTON_15 = 15, n.Gamepad.AXIS_0 = 0, n.Gamepad.AXIS_1 = 1, n.Gamepad.AXIS_2 = 2, n.Gamepad.AXIS_3 = 3, n.Gamepad.AXIS_4 = 4, n.Gamepad.AXIS_5 = 5, n.Gamepad.AXIS_6 = 6, n.Gamepad.AXIS_7 = 7, n.Gamepad.AXIS_8 = 8, n.Gamepad.AXIS_9 = 9, n.Gamepad.XBOX360_A = 0, n.Gamepad.XBOX360_B = 1, n.Gamepad.XBOX360_X = 2, n.Gamepad.XBOX360_Y = 3, n.Gamepad.XBOX360_LEFT_BUMPER = 4, n.Gamepad.XBOX360_RIGHT_BUMPER = 5, n.Gamepad.XBOX360_LEFT_TRIGGER = 6, n.Gamepad.XBOX360_RIGHT_TRIGGER = 7, n.Gamepad.XBOX360_BACK = 8, n.Gamepad.XBOX360_START = 9, n.Gamepad.XBOX360_STICK_LEFT_BUTTON = 10, n.Gamepad.XBOX360_STICK_RIGHT_BUTTON = 11, n.Gamepad.XBOX360_DPAD_LEFT = 14, n.Gamepad.XBOX360_DPAD_RIGHT = 15, n.Gamepad.XBOX360_DPAD_UP = 12, n.Gamepad.XBOX360_DPAD_DOWN = 13, n.Gamepad.XBOX360_STICK_LEFT_X = 0, n.Gamepad.XBOX360_STICK_LEFT_Y = 1, n.Gamepad.XBOX360_STICK_RIGHT_X = 2, n.Gamepad.XBOX360_STICK_RIGHT_Y = 3, n.Gamepad.PS3XC_X = 0, n.Gamepad.PS3XC_CIRCLE = 1, n.Gamepad.PS3XC_SQUARE = 2, n.Gamepad.PS3XC_TRIANGLE = 3, n.Gamepad.PS3XC_L1 = 4, n.Gamepad.PS3XC_R1 = 5, n.Gamepad.PS3XC_L2 = 6, n.Gamepad.PS3XC_R2 = 7, n.Gamepad.PS3XC_SELECT = 8, n.Gamepad.PS3XC_START = 9, n.Gamepad.PS3XC_STICK_LEFT_BUTTON = 10, n.Gamepad.PS3XC_STICK_RIGHT_BUTTON = 11, n.Gamepad.PS3XC_DPAD_UP = 12, n.Gamepad.PS3XC_DPAD_DOWN = 13, n.Gamepad.PS3XC_DPAD_LEFT = 14, n.Gamepad.PS3XC_DPAD_RIGHT = 15, n.Gamepad.PS3XC_STICK_LEFT_X = 0, n.Gamepad.PS3XC_STICK_LEFT_Y = 1, n.Gamepad.PS3XC_STICK_RIGHT_X = 2, n.Gamepad.PS3XC_STICK_RIGHT_Y = 3, n.SinglePad = function(t, e) {
                            this.game = t, this.index = null, this.connected = !1, this.callbackContext = this, this.onConnectCallback = null, this.onDisconnectCallback = null, this.onDownCallback = null, this.onUpCallback = null, this.onAxisCallback = null, this.onFloatCallback = null, this.deadZone = .26, this._padParent = e, this._rawPad = null, this._prevTimestamp = null, this._buttons = [], this._buttonsLen = 0, this._axes = [], this._axesLen = 0
                        }, n.SinglePad.prototype = {
                            addCallbacks: function(t, e) {
                                "undefined" != typeof e && (this.onConnectCallback = "function" == typeof e.onConnect ? e.onConnect : this.onConnectCallback, this.onDisconnectCallback = "function" == typeof e.onDisconnect ? e.onDisconnect : this.onDisconnectCallback, this.onDownCallback = "function" == typeof e.onDown ? e.onDown : this.onDownCallback, this.onUpCallback = "function" == typeof e.onUp ? e.onUp : this.onUpCallback, this.onAxisCallback = "function" == typeof e.onAxis ? e.onAxis : this.onAxisCallback, this.onFloatCallback = "function" == typeof e.onFloat ? e.onFloat : this.onFloatCallback)
                            },
                            addButton: function(t) {
                                return this.getButton(t)
                            },
                            getButton: function(t) {
                                return this._buttons[t] ? this._buttons[t] : null
                            },
                            pollStatus: function() {
                                if (!(!this.connected || this.game.input.disabled || this.game.input.gamepad.disabled || this._rawPad.timestamp && this._rawPad.timestamp === this._prevTimestamp)) {
                                    for (var t = 0; t < this._buttonsLen; t++) {
                                        var e = isNaN(this._rawPad.buttons[t]) ? this._rawPad.buttons[t].value : this._rawPad.buttons[t];
                                        e !== this._buttons[t].value && (1 === e ? this.processButtonDown(t, e) : 0 === e ? this.processButtonUp(t, e) : this.processButtonFloat(t, e))
                                    }
                                    for (var i = 0; i < this._axesLen; i++) {
                                        var s = this._rawPad.axes[i];
                                        this.processAxisChange(s > 0 && s > this.deadZone || 0 > s && s < -this.deadZone ? {
                                            axis: i,
                                            value: s
                                        } : {
                                            axis: i,
                                            value: 0
                                        })
                                    }
                                    this._prevTimestamp = this._rawPad.timestamp
                                }
                            },
                            connect: function(t) {
                                var e = !this.connected;
                                this.connected = !0, this.index = t.index, this._rawPad = t, this._buttons = [], this._buttonsLen = t.buttons.length, this._axes = t.axes, this._axesLen = t.axes.length;
                                for (var i in t.buttons) i = parseInt(i, 10), this._buttons[i] = new n.GamepadButton(this, i);
                                e && this._padParent.onConnectCallback && this._padParent.onConnectCallback.call(this._padParent.callbackContext, this.index), e && this.onConnectCallback && this.onConnectCallback.call(this.callbackContext)
                            },
                            disconnect: function() {
                                var t = this.connected,
                                    e = this.index;
                                this.connected = !1, this.index = null, this._rawPad = void 0;
                                for (var i = 0; i < this._buttonsLen; i++) this._buttons[i].destroy();
                                this._buttons = [], this._buttonsLen = 0, this._axes = [], this._axesLen = 0, t && this._padParent.onDisconnectCallback && this._padParent.onDisconnectCallback.call(this._padParent.callbackContext, e), t && this.onDisconnectCallback && this.onDisconnectCallback.call(this.callbackContext)
                            },
                            processAxisChange: function(t) {
                                this._axes[t.axis] !== t.value && (this._axes[t.axis] = t.value, this._padParent.onAxisCallback && this._padParent.onAxisCallback.call(this._padParent.callbackContext, t, this.index), this.onAxisCallback && this.onAxisCallback.call(this.callbackContext, t))
                            },
                            processButtonDown: function(t, e) {
                                this._padParent.onDownCallback && this._padParent.onDownCallback.call(this._padParent.callbackContext, t, e, this.index), this.onDownCallback && this.onDownCallback.call(this.callbackContext, t, e), this._buttons[t] && this._buttons[t].processButtonDown(e)
                            },
                            processButtonUp: function(t, e) {
                                this._padParent.onUpCallback && this._padParent.onUpCallback.call(this._padParent.callbackContext, t, e, this.index), this.onUpCallback && this.onUpCallback.call(this.callbackContext, t, e), this._buttons[t] && this._buttons[t].processButtonUp(e)
                            },
                            processButtonFloat: function(t, e) {
                                this._padParent.onFloatCallback && this._padParent.onFloatCallback.call(this._padParent.callbackContext, t, e, this.index), this.onFloatCallback && this.onFloatCallback.call(this.callbackContext, t, e), this._buttons[t] && this._buttons[t].processButtonFloat(e)
                            },
                            axis: function(t) {
                                return this._axes[t] ? this._axes[t] : !1
                            },
                            isDown: function(t) {
                                return this._buttons[t] ? this._buttons[t].isDown : !1
                            },
                            isUp: function(t) {
                                return this._buttons[t] ? this._buttons[t].isUp : !1
                            },
                            justReleased: function(t, e) {
                                return this._buttons[t] ? this._buttons[t].justReleased(e) : void 0
                            },
                            justPressed: function(t, e) {
                                return this._buttons[t] ? this._buttons[t].justPressed(e) : void 0
                            },
                            buttonValue: function(t) {
                                return this._buttons[t] ? this._buttons[t].value : null
                            },
                            reset: function() {
                                for (var t = 0; t < this._axes.length; t++) this._axes[t] = 0
                            }
                        }, n.SinglePad.prototype.constructor = n.SinglePad, n.GamepadButton = function(t, e) {
                            this.pad = t, this.game = t.game, this.isDown = !1, this.isUp = !0, this.timeDown = 0, this.duration = 0, this.timeUp = 0, this.repeats = 0, this.value = 0, this.buttonCode = e, this.onDown = new n.Signal, this.onUp = new n.Signal, this.onFloat = new n.Signal
                        }, n.GamepadButton.prototype = {
                            processButtonDown: function(t) {
                                this.isDown ? (this.duration = this.game.time.now - this.timeDown, this.repeats++) : (this.isDown = !0, this.isUp = !1, this.timeDown = this.game.time.now, this.duration = 0, this.repeats = 0, this.value = t, this.onDown.dispatch(this, t))
                            },
                            processButtonUp: function(t) {
                                this.isDown && (this.isDown = !1, this.isUp = !0, this.timeUp = this.game.time.now, this.value = t, this.onUp.dispatch(this, t))
                            },
                            processButtonFloat: function(t) {
                                this.value = t, this.onFloat.dispatch(this, t)
                            },
                            justPressed: function(t) {
                                return "undefined" == typeof t && (t = 250), this.isDown && this.duration < t
                            },
                            justReleased: function(t) {
                                return "undefined" == typeof t && (t = 250), this.isDown === !1 && this.game.time.now - this.timeUp < t
                            },
                            reset: function() {
                                this.isDown = !1, this.isUp = !0, this.timeDown = this.game.time.now, this.duration = 0, this.repeats = 0
                            },
                            destroy: function() {
                                this.onDown.dispose(), this.onUp.dispose(), this.onFloat.dispose(), this.pad = null, this.game = null
                            }
                        }, n.GamepadButton.prototype.constructor = n.GamepadButton, n.InputHandler = function(t) {
                            this.sprite = t, this.game = t.game, this.enabled = !1, this.checked = !1, this.priorityID = 0, this.useHandCursor = !1, this._setHandCursor = !1, this.isDragged = !1, this.allowHorizontalDrag = !0, this.allowVerticalDrag = !0, this.bringToTop = !1, this.snapOffset = null, this.snapOnDrag = !1, this.snapOnRelease = !1, this.snapX = 0, this.snapY = 0, this.snapOffsetX = 0, this.snapOffsetY = 0, this.pixelPerfectOver = !1, this.pixelPerfectClick = !1, this.pixelPerfectAlpha = 255, this.draggable = !1, this.boundsRect = null, this.boundsSprite = null, this.consumePointerEvent = !1, this._dragPhase = !1, this._wasEnabled = !1, this._tempPoint = new n.Point, this._pointerData = [], this._pointerData.push({
                                id: 0,
                                x: 0,
                                y: 0,
                                isDown: !1,
                                isUp: !1,
                                isOver: !1,
                                isOut: !1,
                                timeOver: 0,
                                timeOut: 0,
                                timeDown: 0,
                                timeUp: 0,
                                downDuration: 0,
                                isDragged: !1
                            })
                        }, n.InputHandler.prototype = {
                            start: function(t, e) {
                                if (t = t || 0, "undefined" == typeof e && (e = !1), this.enabled === !1) {
                                    this.game.input.interactiveItems.add(this), this.useHandCursor = e, this.priorityID = t;
                                    for (var i = 0; 10 > i; i++) this._pointerData[i] = {
                                        id: i,
                                        x: 0,
                                        y: 0,
                                        isDown: !1,
                                        isUp: !1,
                                        isOver: !1,
                                        isOut: !1,
                                        timeOver: 0,
                                        timeOut: 0,
                                        timeDown: 0,
                                        timeUp: 0,
                                        downDuration: 0,
                                        isDragged: !1
                                    };
                                    this.snapOffset = new n.Point, this.enabled = !0, this._wasEnabled = !0, this.sprite.events && null === this.sprite.events.onInputOver && (this.sprite.events.onInputOver = new n.Signal, this.sprite.events.onInputOut = new n.Signal, this.sprite.events.onInputDown = new n.Signal, this.sprite.events.onInputUp = new n.Signal, this.sprite.events.onDragStart = new n.Signal, this.sprite.events.onDragStop = new n.Signal)
                                }
                                return this.sprite.events.onAddedToGroup.add(this.addedToGroup, this), this.sprite.events.onRemovedFromGroup.add(this.removedFromGroup, this), this.flagged = !1, this.sprite
                            },
                            addedToGroup: function() {
                                this._dragPhase || this._wasEnabled && !this.enabled && this.start()
                            },
                            removedFromGroup: function() {
                                this._dragPhase || (this.enabled ? (this._wasEnabled = !0, this.stop()) : this._wasEnabled = !1)
                            },
                            reset: function() {
                                this.enabled = !1, this.flagged = !1;
                                for (var t = 0; 10 > t; t++) this._pointerData[t] = {
                                    id: t,
                                    x: 0,
                                    y: 0,
                                    isDown: !1,
                                    isUp: !1,
                                    isOver: !1,
                                    isOut: !1,
                                    timeOver: 0,
                                    timeOut: 0,
                                    timeDown: 0,
                                    timeUp: 0,
                                    downDuration: 0,
                                    isDragged: !1
                                }
                            },
                            stop: function() {
                                this.enabled !== !1 && (this.enabled = !1, this.game.input.interactiveItems.remove(this))
                            },
                            destroy: function() {
                                this.sprite && (this._setHandCursor && (this.game.canvas.style.cursor = "default", this._setHandCursor = !1), this.enabled = !1, this.game.input.interactiveItems.remove(this), this._pointerData.length = 0, this.boundsRect = null, this.boundsSprite = null, this.sprite = null)
                            },
                            validForInput: function(t, e, i) {
                                return "undefined" == typeof i && (i = !0), 0 === this.sprite.scale.x || 0 === this.sprite.scale.y || this.priorityID < this.game.input.minPriorityID ? !1 : (i || !this.pixelPerfectClick && !this.pixelPerfectOver) && (this.priorityID > t || this.priorityID === t && this.sprite._cache[3] < e) ? !0 : !1
                            },
                            isPixelPerfect: function() {
                                return this.pixelPerfectClick || this.pixelPerfectOver
                            },
                            pointerX: function(t) {
                                return t = t || 0, this._pointerData[t].x
                            },
                            pointerY: function(t) {
                                return t = t || 0, this._pointerData[t].y
                            },
                            pointerDown: function(t) {
                                return t = t || 0, this._pointerData[t].isDown
                            },
                            pointerUp: function(t) {
                                return t = t || 0, this._pointerData[t].isUp
                            },
                            pointerTimeDown: function(t) {
                                return t = t || 0, this._pointerData[t].timeDown
                            },
                            pointerTimeUp: function(t) {
                                return t = t || 0, this._pointerData[t].timeUp
                            },
                            pointerOver: function(t) {
                                if (this.enabled) {
                                    if ("undefined" != typeof t) return this._pointerData[t].isOver;
                                    for (var e = 0; 10 > e; e++)
                                        if (this._pointerData[e].isOver) return !0
                                }
                                return !1
                            },
                            pointerOut: function(t) {
                                if (this.enabled) {
                                    if ("undefined" != typeof t) return this._pointerData[t].isOut;
                                    for (var e = 0; 10 > e; e++)
                                        if (this._pointerData[e].isOut) return !0
                                }
                                return !1
                            },
                            pointerTimeOver: function(t) {
                                return t = t || 0, this._pointerData[t].timeOver
                            },
                            pointerTimeOut: function(t) {
                                return t = t || 0, this._pointerData[t].timeOut
                            },
                            pointerDragged: function(t) {
                                return t = t || 0, this._pointerData[t].isDragged
                            },
                            checkPointerDown: function(t, e) {
                                return t.isDown && this.enabled && this.sprite && this.sprite.parent && this.sprite.visible && this.sprite.parent.visible && this.game.input.hitTest(this.sprite, t, this._tempPoint) ? ("undefined" == typeof e && (e = !1), !e && this.pixelPerfectClick ? this.checkPixel(this._tempPoint.x, this._tempPoint.y) : !0) : !1
                            },
                            checkPointerOver: function(t, e) {
                                return this.enabled && this.sprite && this.sprite.parent && this.sprite.visible && this.sprite.parent.visible && this.game.input.hitTest(this.sprite, t, this._tempPoint) ? ("undefined" == typeof e && (e = !1), !e && this.pixelPerfectOver ? this.checkPixel(this._tempPoint.x, this._tempPoint.y) : !0) : !1
                            },
                            checkPixel: function(t, e, i) {
                                if (this.sprite.texture.baseTexture.source) {
                                    if (this.game.input.hitContext.clearRect(0, 0, 1, 1), null === t && null === e) {
                                        this.game.input.getLocalPosition(this.sprite, i, this._tempPoint);
                                        var t = this._tempPoint.x,
                                            e = this._tempPoint.y
                                    }
                                    0 !== this.sprite.anchor.x && (t -= -this.sprite.texture.frame.width * this.sprite.anchor.x), 0 !== this.sprite.anchor.y && (e -= -this.sprite.texture.frame.height * this.sprite.anchor.y), t += this.sprite.texture.frame.x, e += this.sprite.texture.frame.y, this.game.input.hitContext.drawImage(this.sprite.texture.baseTexture.source, t, e, 1, 1, 0, 0, 1, 1);
                                    var s = this.game.input.hitContext.getImageData(0, 0, 1, 1);
                                    if (s.data[3] >= this.pixelPerfectAlpha) return !0
                                }
                                return !1
                            },
                            update: function(t) {
                                return null !== this.sprite && void 0 !== this.sprite.parent ? this.enabled && this.sprite.visible && this.sprite.parent.visible ? this.draggable && this._draggedPointerID == t.id ? this.updateDrag(t) : this._pointerData[t.id].isOver === !0 ? this.checkPointerOver(t) ? (this._pointerData[t.id].x = t.x - this.sprite.x, this._pointerData[t.id].y = t.y - this.sprite.y, !0) : (this._pointerOutHandler(t), !1) : void 0 : (this._pointerOutHandler(t), !1) : void 0
                            },
                            _pointerOverHandler: function(t) {
                                null !== this.sprite && this._pointerData[t.id].isOver === !1 && (this._pointerData[t.id].isOver = !0, this._pointerData[t.id].isOut = !1, this._pointerData[t.id].timeOver = this.game.time.now, this._pointerData[t.id].x = t.x - this.sprite.x, this._pointerData[t.id].y = t.y - this.sprite.y, this.useHandCursor && this._pointerData[t.id].isDragged === !1 && (this.game.canvas.style.cursor = "pointer", this._setHandCursor = !0), this.sprite && this.sprite.events && this.sprite.events.onInputOver.dispatch(this.sprite, t))
                            },
                            _pointerOutHandler: function(t) {
                                null !== this.sprite && (this._pointerData[t.id].isOver = !1, this._pointerData[t.id].isOut = !0, this._pointerData[t.id].timeOut = this.game.time.now, this.useHandCursor && this._pointerData[t.id].isDragged === !1 && (this.game.canvas.style.cursor = "default", this._setHandCursor = !1), this.sprite && this.sprite.events && this.sprite.events.onInputOut.dispatch(this.sprite, t))
                            },
                            _touchedHandler: function(t) {
                                if (null !== this.sprite) {
                                    if (this._pointerData[t.id].isDown === !1 && this._pointerData[t.id].isOver === !0) {
                                        if (this.pixelPerfectClick && !this.checkPixel(null, null, t)) return;
                                        this._pointerData[t.id].isDown = !0, this._pointerData[t.id].isUp = !1, this._pointerData[t.id].timeDown = this.game.time.now, this.sprite && this.sprite.events && this.sprite.events.onInputDown.dispatch(this.sprite, t), this.draggable && this.isDragged === !1 && this.startDrag(t), this.bringToTop && this.sprite.bringToTop()
                                    }
                                    return this.consumePointerEvent
                                }
                            },
                            _releasedHandler: function(t) {
                                null !== this.sprite && this._pointerData[t.id].isDown && t.isUp && (this._pointerData[t.id].isDown = !1, this._pointerData[t.id].isUp = !0, this._pointerData[t.id].timeUp = this.game.time.now, this._pointerData[t.id].downDuration = this._pointerData[t.id].timeUp - this._pointerData[t.id].timeDown, this.checkPointerOver(t) ? this.sprite && this.sprite.events && this.sprite.events.onInputUp.dispatch(this.sprite, t, !0) : (this.sprite && this.sprite.events && this.sprite.events.onInputUp.dispatch(this.sprite, t, !1), this.useHandCursor && (this.game.canvas.style.cursor = "default", this._setHandCursor = !1)), this.draggable && this.isDragged && this._draggedPointerID === t.id && this.stopDrag(t))
                            },
                            updateDrag: function(t) {
                                return t.isUp ? (this.stopDrag(t), !1) : (this.sprite.fixedToCamera ? (this.allowHorizontalDrag && (this.sprite.cameraOffset.x = t.x + this._dragPoint.x + this.dragOffset.x), this.allowVerticalDrag && (this.sprite.cameraOffset.y = t.y + this._dragPoint.y + this.dragOffset.y), this.boundsRect && this.checkBoundsRect(), this.boundsSprite && this.checkBoundsSprite(), this.snapOnDrag && (this.sprite.cameraOffset.x = Math.round((this.sprite.cameraOffset.x - this.snapOffsetX % this.snapX) / this.snapX) * this.snapX + this.snapOffsetX % this.snapX, this.sprite.cameraOffset.y = Math.round((this.sprite.cameraOffset.y - this.snapOffsetY % this.snapY) / this.snapY) * this.snapY + this.snapOffsetY % this.snapY)) : (this.allowHorizontalDrag && (this.sprite.x = t.x + this._dragPoint.x + this.dragOffset.x), this.allowVerticalDrag && (this.sprite.y = t.y + this._dragPoint.y + this.dragOffset.y), this.boundsRect && this.checkBoundsRect(), this.boundsSprite && this.checkBoundsSprite(), this.snapOnDrag && (this.sprite.x = Math.round((this.sprite.x - this.snapOffsetX % this.snapX) / this.snapX) * this.snapX + this.snapOffsetX % this.snapX, this.sprite.y = Math.round((this.sprite.y - this.snapOffsetY % this.snapY) / this.snapY) * this.snapY + this.snapOffsetY % this.snapY)), !0)
                            },
                            justOver: function(t, e) {
                                return t = t || 0, e = e || 500, this._pointerData[t].isOver && this.overDuration(t) < e
                            },
                            justOut: function(t, e) {
                                return t = t || 0, e = e || 500, this._pointerData[t].isOut && this.game.time.now - this._pointerData[t].timeOut < e
                            },
                            justPressed: function(t, e) {
                                return t = t || 0, e = e || 500, this._pointerData[t].isDown && this.downDuration(t) < e
                            },
                            justReleased: function(t, e) {
                                return t = t || 0, e = e || 500, this._pointerData[t].isUp && this.game.time.now - this._pointerData[t].timeUp < e
                            },
                            overDuration: function(t) {
                                return t = t || 0, this._pointerData[t].isOver ? this.game.time.now - this._pointerData[t].timeOver : -1
                            },
                            downDuration: function(t) {
                                return t = t || 0, this._pointerData[t].isDown ? this.game.time.now - this._pointerData[t].timeDown : -1
                            },
                            enableDrag: function(t, e, i, s, r, o) {
                                "undefined" == typeof t && (t = !1), "undefined" == typeof e && (e = !1), "undefined" == typeof i && (i = !1), "undefined" == typeof s && (s = 255), "undefined" == typeof r && (r = null), "undefined" == typeof o && (o = null), this._dragPoint = new n.Point, this.draggable = !0, this.bringToTop = e, this.dragOffset = new n.Point, this.dragFromCenter = t, this.pixelPerfectClick = i, this.pixelPerfectAlpha = s, r && (this.boundsRect = r), o && (this.boundsSprite = o)
                            },
                            disableDrag: function() {
                                if (this._pointerData)
                                    for (var t = 0; 10 > t; t++) this._pointerData[t].isDragged = !1;
                                this.draggable = !1, this.isDragged = !1, this._draggedPointerID = -1
                            },
                            startDrag: function(t) {
                                if (this.isDragged = !0, this._draggedPointerID = t.id, this._pointerData[t.id].isDragged = !0, this.sprite.fixedToCamera) this.dragFromCenter ? (this.sprite.centerOn(t.x, t.y), this._dragPoint.setTo(this.sprite.cameraOffset.x - t.x, this.sprite.cameraOffset.y - t.y)) : this._dragPoint.setTo(this.sprite.cameraOffset.x - t.x, this.sprite.cameraOffset.y - t.y);
                                else if (this.dragFromCenter) {
                                    var e = this.sprite.getBounds();
                                    this.sprite.x = t.x + (this.sprite.x - e.centerX), this.sprite.y = t.y + (this.sprite.y - e.centerY), this._dragPoint.setTo(this.sprite.x - t.x, this.sprite.y - t.y)
                                } else this._dragPoint.setTo(this.sprite.x - t.x, this.sprite.y - t.y);
                                this.updateDrag(t), this.bringToTop && (this._dragPhase = !0, this.sprite.bringToTop()), this.sprite.events.onDragStart.dispatch(this.sprite, t)
                            },
                            stopDrag: function(t) {
                                this.isDragged = !1, this._draggedPointerID = -1, this._pointerData[t.id].isDragged = !1, this._dragPhase = !1, this.snapOnRelease && (this.sprite.fixedToCamera ? (this.sprite.cameraOffset.x = Math.round((this.sprite.cameraOffset.x - this.snapOffsetX % this.snapX) / this.snapX) * this.snapX + this.snapOffsetX % this.snapX, this.sprite.cameraOffset.y = Math.round((this.sprite.cameraOffset.y - this.snapOffsetY % this.snapY) / this.snapY) * this.snapY + this.snapOffsetY % this.snapY) : (this.sprite.x = Math.round((this.sprite.x - this.snapOffsetX % this.snapX) / this.snapX) * this.snapX + this.snapOffsetX % this.snapX, this.sprite.y = Math.round((this.sprite.y - this.snapOffsetY % this.snapY) / this.snapY) * this.snapY + this.snapOffsetY % this.snapY)), this.sprite.events.onDragStop.dispatch(this.sprite, t), this.checkPointerOver(t) === !1 && this._pointerOutHandler(t)
                            },
                            setDragLock: function(t, e) {
                                "undefined" == typeof t && (t = !0), "undefined" == typeof e && (e = !0), this.allowHorizontalDrag = t, this.allowVerticalDrag = e
                            },
                            enableSnap: function(t, e, i, s, n, r) {
                                "undefined" == typeof i && (i = !0), "undefined" == typeof s && (s = !1), "undefined" == typeof n && (n = 0), "undefined" == typeof r && (r = 0), this.snapX = t, this.snapY = e, this.snapOffsetX = n, this.snapOffsetY = r, this.snapOnDrag = i, this.snapOnRelease = s
                            },
                            disableSnap: function() {
                                this.snapOnDrag = !1, this.snapOnRelease = !1
                            },
                            checkBoundsRect: function() {
                                this.sprite.fixedToCamera ? (this.sprite.cameraOffset.x < this.boundsRect.left ? this.sprite.cameraOffset.x = this.boundsRect.cameraOffset.x : this.sprite.cameraOffset.x + this.sprite.width > this.boundsRect.right && (this.sprite.cameraOffset.x = this.boundsRect.right - this.sprite.width), this.sprite.cameraOffset.y < this.boundsRect.top ? this.sprite.cameraOffset.y = this.boundsRect.top : this.sprite.cameraOffset.y + this.sprite.height > this.boundsRect.bottom && (this.sprite.cameraOffset.y = this.boundsRect.bottom - this.sprite.height)) : (this.sprite.x < this.boundsRect.left ? this.sprite.x = this.boundsRect.x : this.sprite.x + this.sprite.width > this.boundsRect.right && (this.sprite.x = this.boundsRect.right - this.sprite.width), this.sprite.y < this.boundsRect.top ? this.sprite.y = this.boundsRect.top : this.sprite.y + this.sprite.height > this.boundsRect.bottom && (this.sprite.y = this.boundsRect.bottom - this.sprite.height))
                            },
                            checkBoundsSprite: function() {
                                this.sprite.fixedToCamera && this.boundsSprite.fixedToCamera ? (this.sprite.cameraOffset.x < this.boundsSprite.camerOffset.x ? this.sprite.cameraOffset.x = this.boundsSprite.camerOffset.x : this.sprite.cameraOffset.x + this.sprite.width > this.boundsSprite.camerOffset.x + this.boundsSprite.width && (this.sprite.cameraOffset.x = this.boundsSprite.camerOffset.x + this.boundsSprite.width - this.sprite.width), this.sprite.cameraOffset.y < this.boundsSprite.camerOffset.y ? this.sprite.cameraOffset.y = this.boundsSprite.camerOffset.y : this.sprite.cameraOffset.y + this.sprite.height > this.boundsSprite.camerOffset.y + this.boundsSprite.height && (this.sprite.cameraOffset.y = this.boundsSprite.camerOffset.y + this.boundsSprite.height - this.sprite.height)) : (this.sprite.x < this.boundsSprite.x ? this.sprite.x = this.boundsSprite.x : this.sprite.x + this.sprite.width > this.boundsSprite.x + this.boundsSprite.width && (this.sprite.x = this.boundsSprite.x + this.boundsSprite.width - this.sprite.width), this.sprite.y < this.boundsSprite.y ? this.sprite.y = this.boundsSprite.y : this.sprite.y + this.sprite.height > this.boundsSprite.y + this.boundsSprite.height && (this.sprite.y = this.boundsSprite.y + this.boundsSprite.height - this.sprite.height))
                            }
                        }, n.InputHandler.prototype.constructor = n.InputHandler, n.Events = function(t) {
                            this.parent = t, this.onAddedToGroup = new n.Signal, this.onRemovedFromGroup = new n.Signal, this.onKilled = new n.Signal, this.onRevived = new n.Signal, this.onOutOfBounds = new n.Signal, this.onEnterBounds = new n.Signal, this.onInputOver = null, this.onInputOut = null, this.onInputDown = null, this.onInputUp = null, this.onDragStart = null, this.onDragStop = null, this.onAnimationStart = null, this.onAnimationComplete = null, this.onAnimationLoop = null
                        }, n.Events.prototype = {
                            destroy: function() {
                                this.parent = null, this.onAddedToGroup.dispose(), this.onRemovedFromGroup.dispose(), this.onKilled.dispose(), this.onRevived.dispose(), this.onOutOfBounds.dispose(), this.onInputOver && (this.onInputOver.dispose(), this.onInputOut.dispose(), this.onInputDown.dispose(), this.onInputUp.dispose(), this.onDragStart.dispose(), this.onDragStop.dispose()), this.onAnimationStart && (this.onAnimationStart.dispose(), this.onAnimationComplete.dispose(), this.onAnimationLoop.dispose())
                            }
                        }, n.Events.prototype.constructor = n.Events, n.GameObjectFactory = function(t) {
                            this.game = t, this.world = this.game.world
                        }, n.GameObjectFactory.prototype = {
                            existing: function(t) {
                                return this.world.add(t)
                            },
                            image: function(t, e, i, s, r) {
                                return "undefined" == typeof r && (r = this.world), r.add(new n.Image(this.game, t, e, i, s))
                            },
                            sprite: function(t, e, i, s, n) {
                                return "undefined" == typeof n && (n = this.world), n.create(t, e, i, s)
                            },
                            tween: function(t) {
                                return this.game.tweens.create(t)
                            },
                            group: function(t, e, i, s, r) {
                                return new n.Group(this.game, t, e, i, s, r)
                            },
                            physicsGroup: function(t, e, i, s) {
                                return new n.Group(this.game, e, i, s, !0, t)
                            },
                            spriteBatch: function(t, e, i) {
                                return "undefined" == typeof t && (t = null), "undefined" == typeof e && (e = "group"), "undefined" == typeof i && (i = !1), new n.SpriteBatch(this.game, t, e, i)
                            },
                            audio: function(t, e, i, s) {
                                return this.game.sound.add(t, e, i, s)
                            },
                            sound: function(t, e, i, s) {
                                return this.game.sound.add(t, e, i, s)
                            },
                            tileSprite: function(t, e, i, s, r, o, a) {
                                return "undefined" == typeof a && (a = this.world), a.add(new n.TileSprite(this.game, t, e, i, s, r, o))
                            },
                            text: function(t, e, i, s, r) {
                                return "undefined" == typeof r && (r = this.world), r.add(new n.Text(this.game, t, e, i, s))
                            },
                            button: function(t, e, i, s, r, o, a, h, l, c) {
                                return "undefined" == typeof c && (c = this.world), c.add(new n.Button(this.game, t, e, i, s, r, o, a, h, l))
                            },
                            graphics: function(t, e, i) {
                                return "undefined" == typeof i && (i = this.world), i.add(new n.Graphics(this.game, t, e))
                            },
                            emitter: function(t, e, i) {
                                return this.game.particles.add(new n.Particles.Arcade.Emitter(this.game, t, e, i))
                            },
                            retroFont: function(t, e, i, s, r, o, a, h, l) {
                                return new n.RetroFont(this.game, t, e, i, s, r, o, a, h, l)
                            },
                            bitmapText: function(t, e, i, s, r, o) {
                                return "undefined" == typeof o && (o = this.world), o.add(new n.BitmapText(this.game, t, e, i, s, r))
                            },
                            tilemap: function(t, e, i, s, r) {
                                return new n.Tilemap(this.game, t, e, i, s, r)
                            },
                            renderTexture: function(t, e, i, s) {
                                ("undefined" == typeof i || "" === i) && (i = this.game.rnd.uuid()), "undefined" == typeof s && (s = !1);
                                var r = new n.RenderTexture(this.game, t, e, i);
                                return s && this.game.cache.addRenderTexture(i, r), r
                            },
                            bitmapData: function(t, e, i, s) {
                                "undefined" == typeof s && (s = !1), ("undefined" == typeof i || "" === i) && (i = this.game.rnd.uuid());
                                var r = new n.BitmapData(this.game, i, t, e);
                                return s && this.game.cache.addBitmapData(i, r), r
                            },
                            filter: function(t) {
                                var e = Array.prototype.splice.call(arguments, 1),
                                    t = new n.Filter[t](this.game);
                                return t.init.apply(t, e), t
                            },
                            plugin: function(t) {
                                return this.game.plugins.add(t)
                            }
                        }, n.GameObjectFactory.prototype.constructor = n.GameObjectFactory, n.GameObjectCreator = function(t) {
                            this.game = t, this.world = this.game.world
                        }, n.GameObjectCreator.prototype = {
                            image: function(t, e, i, s) {
                                return new n.Image(this.game, t, e, i, s)
                            },
                            sprite: function(t, e, i, s) {
                                return new n.Sprite(this.game, t, e, i, s)
                            },
                            tween: function(t) {
                                return new n.Tween(t, this.game)
                            },
                            group: function(t, e, i, s, r) {
                                return new n.Group(this.game, null, e, i, s, r)
                            },
                            spriteBatch: function(t, e, i) {
                                return "undefined" == typeof e && (e = "group"), "undefined" == typeof i && (i = !1), new n.SpriteBatch(this.game, t, e, i)
                            },
                            audio: function(t, e, i, s) {
                                return this.game.sound.add(t, e, i, s)
                            },
                            sound: function(t, e, i, s) {
                                return this.game.sound.add(t, e, i, s)
                            },
                            tileSprite: function(t, e, i, s, r, o) {
                                return new n.TileSprite(this.game, t, e, i, s, r, o)
                            },
                            text: function(t, e, i, s) {
                                return new n.Text(this.game, t, e, i, s)
                            },
                            button: function(t, e, i, s, r, o, a, h, l) {
                                return new n.Button(this.game, t, e, i, s, r, o, a, h, l)
                            },
                            graphics: function(t, e) {
                                return new n.Graphics(this.game, t, e)
                            },
                            emitter: function(t, e, i) {
                                return new n.Particles.Arcade.Emitter(this.game, t, e, i)
                            },
                            retroFont: function(t, e, i, s, r, o, a, h, l) {
                                return new n.RetroFont(this.game, t, e, i, s, r, o, a, h, l)
                            },
                            bitmapText: function(t, e, i, s, r) {
                                return new n.BitmapText(this.game, t, e, i, s, r)
                            },
                            tilemap: function(t, e, i, s, r) {
                                return new n.Tilemap(this.game, t, e, i, s, r)
                            },
                            renderTexture: function(t, e, i, s) {
                                ("undefined" == typeof i || "" === i) && (i = this.game.rnd.uuid()), "undefined" == typeof s && (s = !1);
                                var r = new n.RenderTexture(this.game, t, e, i);
                                return s && this.game.cache.addRenderTexture(i, r), r
                            },
                            bitmapData: function(t, e, i, s) {
                                "undefined" == typeof s && (s = !1), ("undefined" == typeof i || "" === i) && (i = this.game.rnd.uuid());
                                var r = new n.BitmapData(this.game, i, t, e);
                                return s && this.game.cache.addBitmapData(i, r), r
                            },
                            filter: function(t) {
                                var e = Array.prototype.splice.call(arguments, 1),
                                    t = new n.Filter[t](this.game);
                                return t.init.apply(t, e), t
                            }
                        }, n.GameObjectCreator.prototype.constructor = n.GameObjectCreator, n.BitmapData = function(t, e, i, s) {
                            "undefined" == typeof i && (i = 100), "undefined" == typeof s && (s = 100), this.game = t, this.key = e, this.width = i, this.height = s, this.canvas = n.Canvas.create(i, s, "", !0), this.context = this.canvas.getContext("2d"), this.ctx = this.context, this.imageData = this.context.getImageData(0, 0, i, s), this.data = this.imageData.data, this.pixels = null, this.imageData.data.buffer ? (this.buffer = this.imageData.data.buffer, this.pixels = new Uint32Array(this.buffer)) : window.ArrayBuffer ? (this.buffer = new ArrayBuffer(this.imageData.data.length), this.pixels = new Uint32Array(this.buffer)) : this.pixels = this.imageData.data, this.baseTexture = new PIXI.BaseTexture(this.canvas), this.texture = new PIXI.Texture(this.baseTexture), this.textureFrame = new n.Frame(0, 0, 0, i, s, "bitmapData", t.rnd.uuid()), this.texture.frame = this.textureFrame, this.type = n.BITMAPDATA, this.disableTextureUpload = !1, this.dirty = !1, this.cls = this.clear, this.update = this.refreshBuffer, this._tempR = 0, this._tempG = 0, this._tempB = 0
                        }, n.BitmapData.prototype = {
                            add: function(t) {
                                if (Array.isArray(t))
                                    for (var e = 0; e < t.length; e++) t[e].loadTexture && t[e].loadTexture(this);
                                else t.loadTexture(this)
                            },
                            load: function(t) {
                                "string" == typeof t && (t = this.game.cache.getImage(t)), this.resize(t.width, t.height), this.cls(), t instanceof n.Image || t instanceof n.Sprite ? this.drawSprite(t, 0, 0) : this.draw(t, 0, 0), this.update()
                            },
                            clear: function() {
                                this.context.clearRect(0, 0, this.width, this.height), this.dirty = !0
                            },
                            fill: function(t, e, i, s) {
                                "undefined" == typeof s && (s = 1), this.context.fillStyle = "rgba(" + t + "," + e + "," + i + "," + s + ")", this.context.fillRect(0, 0, this.width, this.height), this.dirty = !0
                            },
                            resize: function(t, e) {
                                (t !== this.width || e !== this.height) && (this.width = t, this.height = e, this.canvas.width = t, this.canvas.height = e, this.baseTexture.width = t, this.baseTexture.height = e, this.textureFrame.width = t, this.textureFrame.height = e, this.texture.width = t, this.texture.height = e, this.texture.crop.width = t, this.texture.crop.height = e, this.refreshBuffer(), this.dirty = !0)
                            },
                            refreshBuffer: function(t, e, i, s) {
                                "undefined" == typeof t && (t = 0), "undefined" == typeof e && (e = 0), "undefined" == typeof i && (i = this.width), "undefined" == typeof s && (s = this.height), this.imageData = this.context.getImageData(t, e, i, s), this.data = this.imageData.data, this.imageData.data.buffer ? (this.buffer = this.imageData.data.buffer, this.pixels = new Uint32Array(this.buffer)) : window.ArrayBuffer ? (this.buffer = new ArrayBuffer(this.imageData.data.length), this.pixels = new Uint32Array(this.buffer)) : this.pixels = this.imageData.data
                            },
                            processPixelRGB: function(t, e, i, s, r, o) {
                                "undefined" == typeof i && (i = 0), "undefined" == typeof s && (s = 0), "undefined" == typeof r && (r = this.width), "undefined" == typeof o && (o = this.height);
                                for (var a = i + r, h = s + o, l = n.Color.createColor(), c = {
                                        r: 0,
                                        g: 0,
                                        b: 0,
                                        a: 0
                                    }, u = !1, d = s; h > d; d++)
                                    for (var p = i; a > p; p++) n.Color.unpackPixel(this.getPixel32(p, d), l), c = t.call(e, l, p, d), c !== !1 && null !== c && void 0 !== c && (this.setPixel32(p, d, c.r, c.g, c.b, c.a, !1), u = !0);
                                u && (this.context.putImageData(this.imageData, 0, 0), this.dirty = !0)
                            },
                            processPixel: function(t, e, i, s, n, r) {
                                "undefined" == typeof i && (i = 0), "undefined" == typeof s && (s = 0), "undefined" == typeof n && (n = this.width), "undefined" == typeof r && (r = this.height);
                                for (var o = i + n, a = s + r, h = 0, l = 0, c = !1, u = s; a > u; u++)
                                    for (var d = i; o > d; d++) h = this.getPixel32(d, u), l = t.call(e, h, d, u), l !== h && (this.pixels[u * this.width + d] = l, c = !0);
                                c && (this.context.putImageData(this.imageData, 0, 0), this.dirty = !0)
                            },
                            replaceRGB: function(t, e, i, s, r, o, a, h, l) {
                                var c = 0,
                                    u = 0,
                                    d = this.width,
                                    p = this.height,
                                    f = n.Color.packPixel(t, e, i, s);
                                void 0 !== l && l instanceof n.Rectangle && (c = l.x, u = l.y, d = l.width, p = l.height);
                                for (var g = 0; p > g; g++)
                                    for (var m = 0; d > m; m++) this.getPixel32(c + m, u + g) === f && this.setPixel32(c + m, u + g, r, o, a, h, !1);
                                this.context.putImageData(this.imageData, 0, 0), this.dirty = !0
                            },
                            setHSL: function(t, e, i, s) {
                                if (("undefined" == typeof t || null === t) && (t = !1), ("undefined" == typeof e || null === e) && (e = !1), ("undefined" == typeof i || null === i) && (i = !1), t || e || i) {
                                    "undefined" == typeof s && (s = new n.Rectangle(0, 0, this.width, this.height));
                                    for (var r = n.Color.createColor(), o = s.y; o < s.bottom; o++)
                                        for (var a = s.x; a < s.right; a++) n.Color.unpackPixel(this.getPixel32(a, o), r, !0), t && (r.h = t), e && (r.s = e), i && (r.l = i), n.Color.HSLtoRGB(r.h, r.s, r.l, r), this.setPixel32(a, o, r.r, r.g, r.b, r.a, !1);
                                    this.context.putImageData(this.imageData, 0, 0), this.dirty = !0
                                }
                            },
                            shiftHSL: function(t, e, i, s) {
                                if (("undefined" == typeof t || null === t) && (t = !1), ("undefined" == typeof e || null === e) && (e = !1), ("undefined" == typeof i || null === i) && (i = !1), t || e || i) {
                                    "undefined" == typeof s && (s = new n.Rectangle(0, 0, this.width, this.height));
                                    for (var r = n.Color.createColor(), o = s.y; o < s.bottom; o++)
                                        for (var a = s.x; a < s.right; a++) n.Color.unpackPixel(this.getPixel32(a, o), r, !0), t && (r.h = this.game.math.wrap(r.h + t, 0, 1)), e && (r.s = this.game.math.limitValue(r.s + e, 0, 1)), i && (r.l = this.game.math.limitValue(r.l + i, 0, 1)), n.Color.HSLtoRGB(r.h, r.s, r.l, r), this.setPixel32(a, o, r.r, r.g, r.b, r.a, !1);
                                    this.context.putImageData(this.imageData, 0, 0), this.dirty = !0
                                }
                            },
                            setPixel32: function(t, e, i, s, r, o, a) {
                                "undefined" == typeof a && (a = !0), t >= 0 && t <= this.width && e >= 0 && e <= this.height && (this.pixels[e * this.width + t] = n.Device.LITTLE_ENDIAN ? o << 24 | r << 16 | s << 8 | i : i << 24 | s << 16 | r << 8 | o, a && (this.context.putImageData(this.imageData, 0, 0), this.dirty = !0))
                            },
                            setPixel: function(t, e, i, s, n, r) {
                                this.setPixel32(t, e, i, s, n, 255, r)
                            },
                            getPixel: function(t, e, i) {
                                i || (i = n.Color.createColor());
                                var s = ~~(t + e * this.width);
                                return s *= 4, i.r = this.data[s], i.g = this.data[++s], i.b = this.data[++s], i.a = this.data[++s], i
                            },
                            getPixel32: function(t, e) {
                                return t >= 0 && t <= this.width && e >= 0 && e <= this.height ? this.pixels[e * this.width + t] : void 0
                            },
                            getPixelRGB: function(t, e, i, s, r) {
                                return n.Color.unpackPixel(this.getPixel32(t, e), i, s, r)
                            },
                            getPixels: function(t) {
                                return this.context.getImageData(t.x, t.y, t.width, t.height)
                            },
                            addToWorld: function(t, e) {
                                return this.game.add.image(t, e, this)
                            },
                            copyPixels: function(t, e, i, s) {
                                "string" == typeof t && (t = this.game.cache.getImage(t));
                                var r = t,
                                    o = 0,
                                    a = 0;
                                if (t instanceof n.Image || t instanceof n.Sprite) {
                                    r = t.texture.baseTexture.source;
                                    var h = t.texture.frame;
                                    o = h.x, a = h.y
                                } else t instanceof n.BitmapData && (r = t.canvas);
                                this.context.drawImage(r, o + e.x, a + e.y, e.width, e.height, i, s, e.width, e.height), this.dirty = !0
                            },
                            draw: function(t, e, i, s, r) {
                                "undefined" == typeof e && (e = 0), "undefined" == typeof i && (i = 0), "string" == typeof t && (t = this.game.cache.getImage(t));
                                var o = t,
                                    a = 0,
                                    h = 0,
                                    l = 0,
                                    c = 0;
                                if (t instanceof n.Image || t instanceof n.Sprite) {
                                    o = t.texture.baseTexture.source;
                                    var u = t.texture.frame;
                                    a = u.x, h = u.y, l = u.width, c = u.height
                                } else t instanceof n.BitmapData && (o = t.canvas), l = t.width, c = t.height;
                                "undefined" == typeof s && (s = l), "undefined" == typeof r && (r = c), this.context.drawImage(o, a, h, l, c, e, i, s, r), this.dirty = !0
                            },
                            drawSprite: function(t, e, i) {
                                "undefined" == typeof e && (e = 0), "undefined" == typeof i && (i = 0), this.draw(t, e, i)
                            },
                            alphaMask: function(t, e, i, s) {
                                ("undefined" == typeof e || null === e) && (e = this);
                                var n = this.context.globalCompositeOperation;
                                "undefined" == typeof s || null === s ? this.draw(e) : this.draw(e, s.x, s.y, s.width, s.height), this.context.globalCompositeOperation = "source-atop", "undefined" == typeof i || null === i ? this.draw(t) : this.draw(t, i.x, i.y, i.width, i.height), this.context.globalCompositeOperation = n, this.update(), this.dirty = !0
                            },
                            extract: function(t, e, i, s, n, r, o, a, h) {
                                return "undefined" == typeof n && (n = 255), "undefined" == typeof r && (r = !1), "undefined" == typeof o && (o = e), "undefined" == typeof a && (a = i), "undefined" == typeof h && (h = s), r && t.resize(this.width, this.height), this.processPixelRGB(function(r, l, c) {
                                    return r.r === e && r.g === i && r.b === s && t.setPixel32(l, c, o, a, h, n, !1), !1
                                }, this), t.context.putImageData(t.imageData, 0, 0), t.dirty = !0, t
                            },
                            rect: function(t, e, i, s, n) {
                                "undefined" != typeof n && (this.context.fillStyle = n), this.context.fillRect(t, e, i, s)
                            },
                            circle: function(t, e, i, s) {
                                "undefined" != typeof s && (this.context.fillStyle = s), this.context.beginPath(), this.context.arc(t, e, i, 0, 2 * Math.PI, !1), this.context.closePath(), this.context.fill()
                            },
                            render: function() {
                                !this.disableTextureUpload && this.game.renderType === n.WEBGL && this.dirty && (PIXI.updateWebGLTexture(this.baseTexture, this.game.renderer.gl), this.dirty = !1)
                            }
                        }, n.BitmapData.prototype.constructor = n.BitmapData, n.Sprite = function(t, e, i, s, r) {
                            e = e || 0, i = i || 0, s = s || null, r = r || null, this.game = t, this.name = "", this.type = n.SPRITE, this.z = 0, this.events = new n.Events(this), this.animations = new n.AnimationManager(this), this.key = s, PIXI.Sprite.call(this, PIXI.TextureCache.__default), this.position.set(e, i), this.world = new n.Point(e, i), this.autoCull = !1, this.input = null, this.body = null, this.alive = !0, this.health = 1, this.lifespan = 0, this.checkWorldBounds = !1, this.outOfBoundsKill = !1, this.debug = !1, this.cameraOffset = new n.Point, this.cropRect = null, this._cache = [0, 0, 0, 0, 1, 0, 1, 0], this._crop = null, this._frame = null, this._bounds = new n.Rectangle, this.loadTexture(s, r)
                        }, n.Sprite.prototype = Object.create(PIXI.Sprite.prototype), n.Sprite.prototype.constructor = n.Sprite, n.Sprite.prototype.preUpdate = function() {
                            if (1 === this._cache[4] && this.exists) return this.world.setTo(this.parent.position.x + this.position.x, this.parent.position.y + this.position.y), this.worldTransform.tx = this.world.x, this.worldTransform.ty = this.world.y, this._cache[0] = this.world.x, this._cache[1] = this.world.y, this._cache[2] = this.rotation, this.body && this.body.preUpdate(), this._cache[4] = 0, !1;
                            if (this._cache[0] = this.world.x, this._cache[1] = this.world.y, this._cache[2] = this.rotation, !this.exists || !this.parent.exists) return this._cache[3] = -1, !1;
                            if (this.lifespan > 0 && (this.lifespan -= this.game.time.elapsed, this.lifespan <= 0)) return this.kill(), !1;
                            if ((this.autoCull || this.checkWorldBounds) && this._bounds.copyFrom(this.getBounds()), this.autoCull && (this.renderable = this.game.world.camera.screenView.intersects(this._bounds)), this.checkWorldBounds)
                                if (1 === this._cache[5] && this.game.world.bounds.intersects(this._bounds)) this._cache[5] = 0, this.events.onEnterBounds.dispatch(this);
                                else if (0 === this._cache[5] && !this.game.world.bounds.intersects(this._bounds) && (this._cache[5] = 1, this.events.onOutOfBounds.dispatch(this), this.outOfBoundsKill)) return this.kill(), !1;
                            this.world.setTo(this.game.camera.x + this.worldTransform.tx, this.game.camera.y + this.worldTransform.ty), this.visible && (this._cache[3] = this.game.stage.currentRenderOrderID++), this.animations.update(), this.body && this.body.preUpdate();
                            for (var t = 0, e = this.children.length; e > t; t++) this.children[t].preUpdate();
                            return !0
                        }, n.Sprite.prototype.update = function() {}, n.Sprite.prototype.postUpdate = function() {
                            this.key instanceof n.BitmapData && this.key.render(), this.exists && this.body && this.body.postUpdate(), 1 === this._cache[7] && (this.position.x = (this.game.camera.view.x + this.cameraOffset.x) / this.game.camera.scale.x, this.position.y = (this.game.camera.view.y + this.cameraOffset.y) / this.game.camera.scale.y);
                            for (var t = 0, e = this.children.length; e > t; t++) this.children[t].postUpdate()
                        }, n.Sprite.prototype.loadTexture = function(t, e, i) {
                            e = e || 0, (i || "undefined" == typeof i) && this.animations.stop(), this.key = t;
                            var s = !0,
                                r = this.smoothed;
                            t instanceof n.RenderTexture ? (this.key = t.key, this.setTexture(t)) : t instanceof n.BitmapData ? this.setTexture(t.texture) : t instanceof PIXI.Texture ? this.setTexture(t) : null === t || "undefined" == typeof t ? (this.key = "__default", this.setTexture(PIXI.TextureCache[this.key])) : "string" != typeof t || this.game.cache.checkImageKey(t) ? (this.setTexture(new PIXI.Texture(PIXI.BaseTextureCache[t])), s = !this.animations.loadFrameData(this.game.cache.getFrameData(t), e)) : (console.warn("Texture with key '" + t + "' not found."), this.key = "__missing", this.setTexture(PIXI.TextureCache[this.key])), s && (this._frame = n.Rectangle.clone(this.texture.frame)), r || (this.smoothed = !1)
                        }, n.Sprite.prototype.setFrame = function(t) {
                            this._frame = t, this.texture.frame.x = t.x, this.texture.frame.y = t.y, this.texture.frame.width = t.width, this.texture.frame.height = t.height, this.texture.crop.x = t.x, this.texture.crop.y = t.y, this.texture.crop.width = t.width, this.texture.crop.height = t.height, t.trimmed && (this.texture.trim ? (this.texture.trim.x = t.spriteSourceSizeX, this.texture.trim.y = t.spriteSourceSizeY, this.texture.trim.width = t.sourceSizeW, this.texture.trim.height = t.sourceSizeH) : this.texture.trim = {
                                x: t.spriteSourceSizeX,
                                y: t.spriteSourceSizeY,
                                width: t.sourceSizeW,
                                height: t.sourceSizeH
                            }, this.texture.width = t.sourceSizeW, this.texture.height = t.sourceSizeH, this.texture.frame.width = t.sourceSizeW, this.texture.frame.height = t.sourceSizeH), this.cropRect ? this.updateCrop() : this.game.renderType === n.WEBGL && PIXI.WebGLRenderer.updateTextureFrame(this.texture)
                        }, n.Sprite.prototype.resetFrame = function() {
                            this._frame && this.setFrame(this._frame)
                        }, n.Sprite.prototype.crop = function(t, e) {
                            "undefined" == typeof e && (e = !1), t ? (e && null !== this.cropRect ? this.cropRect.setTo(t.x, t.y, t.width, t.height) : this.cropRect = e && null === this.cropRect ? new n.Rectangle(t.x, t.y, t.width, t.height) : t, this.updateCrop()) : (this._crop = null, this.cropRect = null, this.resetFrame())
                        }, n.Sprite.prototype.updateCrop = function() {
                            if (this.cropRect) {
                                this._crop = n.Rectangle.clone(this.cropRect, this._crop), this._crop.x += this._frame.x, this._crop.y += this._frame.y;
                                var t = Math.max(this._frame.x, this._crop.x),
                                    e = Math.max(this._frame.y, this._crop.y),
                                    i = Math.min(this._frame.right, this._crop.right) - t,
                                    s = Math.min(this._frame.bottom, this._crop.bottom) - e;
                                this.texture.crop.x = t, this.texture.crop.y = e, this.texture.crop.width = i, this.texture.crop.height = s, this.texture.frame.width = Math.min(i, this.cropRect.width), this.texture.frame.height = Math.min(s, this.cropRect.height), this.texture.width = this.texture.frame.width, this.texture.height = this.texture.frame.height, this.game.renderType === n.WEBGL && PIXI.WebGLRenderer.updateTextureFrame(this.texture)
                            }
                        }, n.Sprite.prototype.revive = function(t) {
                            return "undefined" == typeof t && (t = 1), this.alive = !0, this.exists = !0, this.visible = !0, this.health = t, this.events && this.events.onRevived.dispatch(this), this
                        }, n.Sprite.prototype.kill = function() {
                            return this.alive = !1, this.exists = !1, this.visible = !1, this.events && this.events.onKilled.dispatch(this), this
                        }, n.Sprite.prototype.destroy = function(t) {
                            if (null !== this.game && 1 !== this._cache[8]) {
                                "undefined" == typeof t && (t = !0), this._cache[8] = 1, this.parent && (this.parent instanceof n.Group ? this.parent.remove(this) : this.parent.removeChild(this)), this.input && this.input.destroy(), this.animations && this.animations.destroy(), this.body && this.body.destroy(), this.events && this.events.destroy();
                                var e = this.children.length;
                                if (t)
                                    for (; e--;) this.children[e].destroy(t);
                                else
                                    for (; e--;) this.removeChild(this.children[e]);
                                this._crop && (this._crop = null), this._frame && (this._frame = null), this.alive = !1, this.exists = !1, this.visible = !1, this.filters = null, this.mask = null, this.game = null, this._cache[8] = 0
                            }
                        }, n.Sprite.prototype.damage = function(t) {
                            return this.alive && (this.health -= t, this.health <= 0 && this.kill()), this
                        }, n.Sprite.prototype.reset = function(t, e, i) {
                            return "undefined" == typeof i && (i = 1), this.world.setTo(t, e), this.position.x = t, this.position.y = e, this.alive = !0, this.exists = !0, this.visible = !0, this.renderable = !0, this._outOfBoundsFired = !1, this.health = i, this.body && this.body.reset(t, e, !1, !1), this._cache[4] = 1, this
                        }, n.Sprite.prototype.bringToTop = function() {
                            return this.parent && this.parent.bringToTop(this), this
                        }, n.Sprite.prototype.play = function(t, e, i, s) {
                            return this.animations ? this.animations.play(t, e, i, s) : void 0
                        }, n.Sprite.prototype.overlap = function(t) {
                            return n.Rectangle.intersects(this.getBounds(), t.getBounds())
                        }, Object.defineProperty(n.Sprite.prototype, "angle", {
                            get: function() {
                                return n.Math.wrapAngle(n.Math.radToDeg(this.rotation))
                            },
                            set: function(t) {
                                this.rotation = n.Math.degToRad(n.Math.wrapAngle(t))
                            }
                        }), Object.defineProperty(n.Sprite.prototype, "deltaX", {
                            get: function() {
                                return this.world.x - this._cache[0]
                            }
                        }), Object.defineProperty(n.Sprite.prototype, "deltaY", {
                            get: function() {
                                return this.world.y - this._cache[1]
                            }
                        }), Object.defineProperty(n.Sprite.prototype, "deltaZ", {
                            get: function() {
                                return this.rotation - this._cache[2]
                            }
                        }), Object.defineProperty(n.Sprite.prototype, "inWorld", {
                            get: function() {
                                return this.game.world.bounds.intersects(this.getBounds())
                            }
                        }), Object.defineProperty(n.Sprite.prototype, "inCamera", {
                            get: function() {
                                return this.game.world.camera.screenView.intersects(this.getBounds())
                            }
                        }), Object.defineProperty(n.Sprite.prototype, "frame", {
                            get: function() {
                                return this.animations.frame
                            },
                            set: function(t) {
                                this.animations.frame = t
                            }
                        }), Object.defineProperty(n.Sprite.prototype, "frameName", {
                            get: function() {
                                return this.animations.frameName
                            },
                            set: function(t) {
                                this.animations.frameName = t
                            }
                        }), Object.defineProperty(n.Sprite.prototype, "renderOrderID", {
                            get: function() {
                                return this._cache[3]
                            }
                        }), Object.defineProperty(n.Sprite.prototype, "inputEnabled", {
                            get: function() {
                                return this.input && this.input.enabled
                            },
                            set: function(t) {
                                t ? null === this.input ? (this.input = new n.InputHandler(this), this.input.start()) : this.input && !this.input.enabled && this.input.start() : this.input && this.input.enabled && this.input.stop()
                            }
                        }), Object.defineProperty(n.Sprite.prototype, "exists", {
                            get: function() {
                                return !!this._cache[6]
                            },
                            set: function(t) {
                                t ? (this._cache[6] = 1, this.body && this.body.type === n.Physics.P2JS && this.body.addToWorld(), this.visible = !0) : (this._cache[6] = 0, this.body && this.body.type === n.Physics.P2JS && this.body.removeFromWorld(), this.visible = !1)
                            }
                        }), Object.defineProperty(n.Sprite.prototype, "fixedToCamera", {
                            get: function() {
                                return !!this._cache[7]
                            },
                            set: function(t) {
                                t ? (this._cache[7] = 1, this.cameraOffset.set(this.x, this.y)) : this._cache[7] = 0
                            }
                        }), Object.defineProperty(n.Sprite.prototype, "smoothed", {
                            get: function() {
                                return !this.texture.baseTexture.scaleMode
                            },
                            set: function(t) {
                                t ? this.texture && (this.texture.baseTexture.scaleMode = 0) : this.texture && (this.texture.baseTexture.scaleMode = 1)
                            }
                        }), Object.defineProperty(n.Sprite.prototype, "x", {
                            get: function() {
                                return this.position.x
                            },
                            set: function(t) {
                                this.position.x = t, this.body && this.body.type === n.Physics.ARCADE && 2 === this.body.phase && (this.body._reset = 1)
                            }
                        }), Object.defineProperty(n.Sprite.prototype, "y", {
                            get: function() {
                                return this.position.y
                            },
                            set: function(t) {
                                this.position.y = t, this.body && this.body.type === n.Physics.ARCADE && 2 === this.body.phase && (this.body._reset = 1)
                            }
                        }), Object.defineProperty(n.Sprite.prototype, "destroyPhase", {
                            get: function() {
                                return !!this._cache[8]
                            }
                        }), n.Image = function(t, e, i, s, r) {
                            e = e || 0, i = i || 0, s = s || null, r = r || null, this.game = t, this.exists = !0, this.name = "", this.type = n.IMAGE, this.z = 0, this.events = new n.Events(this), this.key = s, this._frame = 0, this._frameName = "", PIXI.Sprite.call(this, PIXI.TextureCache.__default), this.loadTexture(s, r), this.position.set(e, i), this.world = new n.Point(e, i), this.autoCull = !1, this.input = null, this.cameraOffset = new n.Point, this._cache = [0, 0, 0, 0, 1, 0, 1, 0, 0]
                        }, n.Image.prototype = Object.create(PIXI.Sprite.prototype), n.Image.prototype.constructor = n.Image, n.Image.prototype.preUpdate = function() {
                            if (this._cache[0] = this.world.x, this._cache[1] = this.world.y, this._cache[2] = this.rotation, !this.exists || !this.parent.exists) return this._cache[3] = -1, !1;
                            this.autoCull && (this.renderable = this.game.world.camera.screenView.intersects(this.getBounds())), this.world.setTo(this.game.camera.x + this.worldTransform.tx, this.game.camera.y + this.worldTransform.ty), this.visible && (this._cache[3] = this.game.stage.currentRenderOrderID++);
                            for (var t = 0, e = this.children.length; e > t; t++) this.children[t].preUpdate();
                            return !0
                        }, n.Image.prototype.update = function() {}, n.Image.prototype.postUpdate = function() {
                            this.key instanceof n.BitmapData && this.key.render(), 1 === this._cache[7] && (this.position.x = (this.game.camera.view.x + this.cameraOffset.x) / this.game.camera.scale.x, this.position.y = (this.game.camera.view.y + this.cameraOffset.y) / this.game.camera.scale.y);
                            for (var t = 0, e = this.children.length; e > t; t++) this.children[t].postUpdate()
                        }, n.Image.prototype.loadTexture = function(t, e) {
                            if (e = e || 0, t instanceof n.RenderTexture) return this.key = t.key, void this.setTexture(t);
                            if (t instanceof n.BitmapData) return this.key = t, void this.setTexture(t.texture);
                            if (t instanceof PIXI.Texture) return this.key = t, void this.setTexture(t);
                            if (null === t || "undefined" == typeof t) return this.key = "__default", void this.setTexture(PIXI.TextureCache[this.key]);
                            if ("string" == typeof t && !this.game.cache.checkImageKey(t)) return this.key = "__missing", void this.setTexture(PIXI.TextureCache[this.key]);
                            if (this.game.cache.isSpriteSheet(t)) {
                                this.key = t;
                                var i = this.game.cache.getFrameData(t);
                                return "string" == typeof e ? (this._frame = 0, this._frameName = e, void this.setTexture(PIXI.TextureCache[i.getFrameByName(e).uuid])) : (this._frame = e, this._frameName = "", void this.setTexture(PIXI.TextureCache[i.getFrame(e).uuid]))
                            }
                            return this.key = t, void this.setTexture(PIXI.TextureCache[t])
                        }, n.Image.prototype.crop = function(t) {
                            if ("undefined" == typeof t || null === t) this.texture.hasOwnProperty("sourceWidth") && this.texture.setFrame(new n.Rectangle(0, 0, this.texture.sourceWidth, this.texture.sourceHeight));
                            else if (this.texture instanceof PIXI.Texture) {
                                var e = {};
                                n.Utils.extend(!0, e, this.texture), e.sourceWidth = e.width, e.sourceHeight = e.height, e.frame = t, e.width = t.width, e.height = t.height, this.texture = e, this.texture.updateFrame = !0, PIXI.Texture.frameUpdates.push(this.texture)
                            } else this.texture.setFrame(t)
                        }, n.Image.prototype.revive = function() {
                            return this.alive = !0, this.exists = !0, this.visible = !0, this.events && this.events.onRevived.dispatch(this), this
                        }, n.Image.prototype.kill = function() {
                            return this.alive = !1, this.exists = !1, this.visible = !1, this.events && this.events.onKilled.dispatch(this), this
                        }, n.Image.prototype.destroy = function(t) {
                            if (null !== this.game && !this.destroyPhase) {
                                "undefined" == typeof t && (t = !0), this._cache[8] = 1, this.parent && (this.parent instanceof n.Group ? this.parent.remove(this) : this.parent.removeChild(this)), this.events && this.events.destroy(), this.input && this.input.destroy();
                                var e = this.children.length;
                                if (t)
                                    for (; e--;) this.children[e].destroy(t);
                                else
                                    for (; e--;) this.removeChild(this.children[e]);
                                this.alive = !1, this.exists = !1, this.visible = !1, this.filters = null, this.mask = null, this.game = null, this._cache[8] = 0
                            }
                        }, n.Image.prototype.reset = function(t, e) {
                            return this.world.setTo(t, e), this.position.x = t, this.position.y = e, this.alive = !0, this.exists = !0, this.visible = !0, this.renderable = !0, this
                        }, n.Image.prototype.bringToTop = function() {
                            return this.parent && this.parent.bringToTop(this), this
                        }, Object.defineProperty(n.Image.prototype, "angle", {
                            get: function() {
                                return n.Math.wrapAngle(n.Math.radToDeg(this.rotation))
                            },
                            set: function(t) {
                                this.rotation = n.Math.degToRad(n.Math.wrapAngle(t))
                            }
                        }), Object.defineProperty(n.Image.prototype, "deltaX", {
                            get: function() {
                                return this.world.x - this._cache[0]
                            }
                        }), Object.defineProperty(n.Image.prototype, "deltaY", {
                            get: function() {
                                return this.world.y - this._cache[1]
                            }
                        }), Object.defineProperty(n.Image.prototype, "deltaZ", {
                            get: function() {
                                return this.rotation - this._cache[2]
                            }
                        }), Object.defineProperty(n.Image.prototype, "inWorld", {
                            get: function() {
                                return this.game.world.bounds.intersects(this.getBounds())
                            }
                        }), Object.defineProperty(n.Image.prototype, "inCamera", {
                            get: function() {
                                return this.game.world.camera.screenView.intersects(this.getBounds())
                            }
                        }), Object.defineProperty(n.Image.prototype, "frame", {
                            get: function() {
                                return this._frame
                            },
                            set: function(t) {
                                if (t !== this.frame && this.game.cache.isSpriteSheet(this.key)) {
                                    var e = this.game.cache.getFrameData(this.key);
                                    e && t < e.total && e.getFrame(t) && (this.setTexture(PIXI.TextureCache[e.getFrame(t).uuid]), this._frame = t)
                                }
                            }
                        }), Object.defineProperty(n.Image.prototype, "frameName", {
                            get: function() {
                                return this._frameName
                            },
                            set: function(t) {
                                if (t !== this.frameName && this.game.cache.isSpriteSheet(this.key)) {
                                    var e = this.game.cache.getFrameData(this.key);
                                    e && e.getFrameByName(t) && (this.setTexture(PIXI.TextureCache[e.getFrameByName(t).uuid]), this._frameName = t)
                                }
                            }
                        }), Object.defineProperty(n.Image.prototype, "renderOrderID", {
                            get: function() {
                                return this._cache[3]
                            }
                        }), Object.defineProperty(n.Image.prototype, "inputEnabled", {
                            get: function() {
                                return this.input && this.input.enabled
                            },
                            set: function(t) {
                                t ? null === this.input ? (this.input = new n.InputHandler(this), this.input.start()) : this.input && !this.input.enabled && this.input.start() : this.input && this.input.enabled && this.input.stop()
                            }
                        }), Object.defineProperty(n.Image.prototype, "fixedToCamera", {
                            get: function() {
                                return !!this._cache[7]
                            },
                            set: function(t) {
                                t ? (this._cache[7] = 1, this.cameraOffset.set(this.x, this.y)) : this._cache[7] = 0
                            }
                        }), Object.defineProperty(n.Image.prototype, "smoothed", {
                            get: function() {
                                return !this.texture.baseTexture.scaleMode
                            },
                            set: function(t) {
                                t ? this.texture && (this.texture.baseTexture.scaleMode = 0) : this.texture && (this.texture.baseTexture.scaleMode = 1)
                            }
                        }), Object.defineProperty(n.Image.prototype, "destroyPhase", {
                            get: function() {
                                return !!this._cache[8]
                            }
                        }), n.TileSprite = function(t, e, i, s, r, o, a) {
                            e = e || 0, i = i || 0, s = s || 256, r = r || 256, o = o || null, a = a || null, this.game = t, this.name = "", this.type = n.TILESPRITE, this.z = 0, this.events = new n.Events(this), this.animations = new n.AnimationManager(this), this.key = o, this._frame = 0, this._frameName = "", this._scroll = new n.Point, PIXI.TilingSprite.call(this, PIXI.TextureCache.__default, s, r), this.position.set(e, i), this.input = null, this.world = new n.Point(e, i), this.autoCull = !1, this.checkWorldBounds = !1, this.cameraOffset = new n.Point, this.body = null, this._cache = [0, 0, 0, 0, 1, 0, 1, 0, 0], this.loadTexture(o, a)
                        }, n.TileSprite.prototype = Object.create(PIXI.TilingSprite.prototype), n.TileSprite.prototype.constructor = n.TileSprite, n.TileSprite.prototype.preUpdate = function() {
                            if (1 === this._cache[4] && this.exists) return this.world.setTo(this.parent.position.x + this.position.x, this.parent.position.y + this.position.y), this.worldTransform.tx = this.world.x, this.worldTransform.ty = this.world.y, this._cache[0] = this.world.x, this._cache[1] = this.world.y, this._cache[2] = this.rotation, this.body && this.body.preUpdate(), this._cache[4] = 0, !1;
                            if (this._cache[0] = this.world.x, this._cache[1] = this.world.y, this._cache[2] = this.rotation, !this.exists || !this.parent.exists) return this._cache[3] = -1, !1;
                            (this.autoCull || this.checkWorldBounds) && this._bounds.copyFrom(this.getBounds()), this.autoCull && (this.renderable = this.game.world.camera.screenView.intersects(this._bounds)), this.checkWorldBounds && (1 === this._cache[5] && this.game.world.bounds.intersects(this._bounds) ? (this._cache[5] = 0, this.events.onEnterBounds.dispatch(this)) : 0 !== this._cache[5] || this.game.world.bounds.intersects(this._bounds) || (this._cache[5] = 1, this.events.onOutOfBounds.dispatch(this))), this.world.setTo(this.game.camera.x + this.worldTransform.tx, this.game.camera.y + this.worldTransform.ty), this.visible && (this._cache[3] = this.game.stage.currentRenderOrderID++), this.animations.update(), 0 !== this._scroll.x && (this.tilePosition.x += this._scroll.x * this.game.time.physicsElapsed), 0 !== this._scroll.y && (this.tilePosition.y += this._scroll.y * this.game.time.physicsElapsed), this.body && this.body.preUpdate();
                            for (var t = 0, e = this.children.length; e > t; t++) this.children[t].preUpdate();
                            return !0
                        }, n.TileSprite.prototype.update = function() {}, n.TileSprite.prototype.postUpdate = function() {
                            this.exists && this.body && this.body.postUpdate(), 1 === this._cache[7] && (this.position.x = this.game.camera.view.x + this.cameraOffset.x, this.position.y = this.game.camera.view.y + this.cameraOffset.y);
                            for (var t = 0, e = this.children.length; e > t; t++) this.children[t].postUpdate()
                        }, n.TileSprite.prototype.autoScroll = function(t, e) {
                            this._scroll.set(t, e)
                        }, n.TileSprite.prototype.stopScroll = function() {
                            this._scroll.set(0, 0)
                        }, n.TileSprite.prototype.loadTexture = function(t, e) {
                            e = e || 0, this.key = t, t instanceof n.RenderTexture ? (this.key = t.key, this.setTexture(t)) : t instanceof n.BitmapData ? this.setTexture(t.texture) : t instanceof PIXI.Texture ? this.setTexture(t) : null === t || "undefined" == typeof t ? (this.key = "__default", this.setTexture(PIXI.TextureCache[this.key])) : "string" != typeof t || this.game.cache.checkImageKey(t) ? (this.setTexture(new PIXI.Texture(PIXI.BaseTextureCache[t])), this.animations.loadFrameData(this.game.cache.getFrameData(t), e)) : (console.warn("Texture with key '" + t + "' not found."), this.key = "__missing", this.setTexture(PIXI.TextureCache[this.key]))
                        }, n.TileSprite.prototype.setFrame = function(t) {
                            this.texture.frame.x = t.x, this.texture.frame.y = t.y, this.texture.frame.width = t.width, this.texture.frame.height = t.height, this.texture.crop.x = t.x, this.texture.crop.y = t.y, this.texture.crop.width = t.width, this.texture.crop.height = t.height, t.trimmed && (this.texture.trim ? (this.texture.trim.x = t.spriteSourceSizeX, this.texture.trim.y = t.spriteSourceSizeY, this.texture.trim.width = t.sourceSizeW, this.texture.trim.height = t.sourceSizeH) : this.texture.trim = {
                                x: t.spriteSourceSizeX,
                                y: t.spriteSourceSizeY,
                                width: t.sourceSizeW,
                                height: t.sourceSizeH
                            }, this.texture.width = t.sourceSizeW, this.texture.height = t.sourceSizeH, this.texture.frame.width = t.sourceSizeW, this.texture.frame.height = t.sourceSizeH), this.game.renderType === n.WEBGL && PIXI.WebGLRenderer.updateTextureFrame(this.texture)
                        }, n.TileSprite.prototype.destroy = function(t) {
                            if (null !== this.game && !this.destroyPhase) {
                                "undefined" == typeof t && (t = !0), this._cache[8] = 1, this.filters && (this.filters = null), this.parent && (this.parent instanceof n.Group ? this.parent.remove(this) : this.parent.removeChild(this)), this.animations.destroy(), this.events.destroy();
                                var e = this.children.length;
                                if (t)
                                    for (; e--;) this.children[e].destroy(t);
                                else
                                    for (; e--;) this.removeChild(this.children[e]);
                                this.exists = !1, this.visible = !1, this.filters = null, this.mask = null, this.game = null, this._cache[8] = 0
                            }
                        }, n.TileSprite.prototype.play = function(t, e, i, s) {
                            return this.animations.play(t, e, i, s)
                        }, n.TileSprite.prototype.reset = function(t, e) {
                            return this.world.setTo(t, e), this.position.x = t, this.position.y = e, this.alive = !0, this.exists = !0, this.visible = !0, this.renderable = !0, this._outOfBoundsFired = !1, this.tilePosition.x = 0, this.tilePosition.y = 0, this.body && this.body.reset(t, e, !1, !1), this._cache[4] = 1, this
                        }, Object.defineProperty(n.TileSprite.prototype, "angle", {
                            get: function() {
                                return n.Math.wrapAngle(n.Math.radToDeg(this.rotation))
                            },
                            set: function(t) {
                                this.rotation = n.Math.degToRad(n.Math.wrapAngle(t))
                            }
                        }), Object.defineProperty(n.TileSprite.prototype, "frame", {
                            get: function() {
                                return this.animations.frame
                            },
                            set: function(t) {
                                t !== this.animations.frame && (this.animations.frame = t)
                            }
                        }), Object.defineProperty(n.TileSprite.prototype, "frameName", {
                            get: function() {
                                return this.animations.frameName
                            },
                            set: function(t) {
                                t !== this.animations.frameName && (this.animations.frameName = t)
                            }
                        }), Object.defineProperty(n.TileSprite.prototype, "fixedToCamera", {
                            get: function() {
                                return !!this._cache[7]
                            },
                            set: function(t) {
                                t ? (this._cache[7] = 1, this.cameraOffset.set(this.x, this.y)) : this._cache[7] = 0
                            }
                        }), Object.defineProperty(n.TileSprite.prototype, "exists", {
                            get: function() {
                                return !!this._cache[6]
                            },
                            set: function(t) {
                                t ? (this._cache[6] = 1, this.body && this.body.type === n.Physics.P2JS && this.body.addToWorld(), this.visible = !0) : (this._cache[6] = 0, this.body && this.body.type === n.Physics.P2JS && (this.body.safeRemove = !0), this.visible = !1)
                            }
                        }), Object.defineProperty(n.TileSprite.prototype, "inputEnabled", {
                            get: function() {
                                return this.input && this.input.enabled
                            },
                            set: function(t) {
                                t ? null === this.input ? (this.input = new n.InputHandler(this), this.input.start()) : this.input && !this.input.enabled && this.input.start() : this.input && this.input.enabled && this.input.stop()
                            }
                        }), Object.defineProperty(n.TileSprite.prototype, "x", {
                            get: function() {
                                return this.position.x
                            },
                            set: function(t) {
                                this.position.x = t, this.body && this.body.type === n.Physics.ARCADE && 2 === this.body.phase && (this.body._reset = 1)
                            }
                        }), Object.defineProperty(n.TileSprite.prototype, "y", {
                            get: function() {
                                return this.position.y
                            },
                            set: function(t) {
                                this.position.y = t, this.body && this.body.type === n.Physics.ARCADE && 2 === this.body.phase && (this.body._reset = 1)
                            }
                        }), Object.defineProperty(n.TileSprite.prototype, "destroyPhase", {
                            get: function() {
                                return !!this._cache[8]
                            }
                        }), n.Text = function(t, e, i, s, r) {
                            e = e || 0, i = i || 0, s = s || " ", r = r || {}, s = 0 === s.length ? " " : s.toString(), this.game = t, this.exists = !0, this.name = "", this.type = n.TEXT, this.z = 0, this.world = new n.Point(e, i), this._text = s, this._font = "", this._fontSize = 32, this._fontWeight = "normal", this._lineSpacing = 0, this.events = new n.Events(this), this.input = null, this.cameraOffset = new n.Point, this.setStyle(r), PIXI.Text.call(this, s, this.style), this.position.set(e, i), this._cache = [0, 0, 0, 0, 1, 0, 1, 0, 0]
                        }, n.Text.prototype = Object.create(PIXI.Text.prototype), n.Text.prototype.constructor = n.Text, n.Text.prototype.preUpdate = function() {
                            if (this._cache[0] = this.world.x, this._cache[1] = this.world.y, this._cache[2] = this.rotation, !this.exists || !this.parent.exists) return this.renderOrderID = -1, !1;
                            this.autoCull && (this.renderable = this.game.world.camera.screenView.intersects(this.getBounds())), this.world.setTo(this.game.camera.x + this.worldTransform.tx, this.game.camera.y + this.worldTransform.ty), this.visible && (this._cache[3] = this.game.stage.currentRenderOrderID++);
                            for (var t = 0, e = this.children.length; e > t; t++) this.children[t].preUpdate();
                            return !0
                        }, n.Text.prototype.update = function() {}, n.Text.prototype.postUpdate = function() {
                            1 === this._cache[7] && (this.position.x = (this.game.camera.view.x + this.cameraOffset.x) / this.game.camera.scale.x, this.position.y = (this.game.camera.view.y + this.cameraOffset.y) / this.game.camera.scale.y);
                            for (var t = 0, e = this.children.length; e > t; t++) this.children[t].postUpdate()
                        }, n.Text.prototype.destroy = function(t) {
                            if (null !== this.game && !this.destroyPhase) {
                                "undefined" == typeof t && (t = !0), this._cache[8] = 1, this.parent && (this.parent instanceof n.Group ? this.parent.remove(this) : this.parent.removeChild(this)), this.texture.destroy(), this.canvas.parentNode ? this.canvas.parentNode.removeChild(this.canvas) : (this.canvas = null, this.context = null);
                                var e = this.children.length;
                                if (t)
                                    for (; e--;) this.children[e].destroy(t);
                                else
                                    for (; e--;) this.removeChild(this.children[e]);
                                this.exists = !1, this.visible = !1, this.filters = null, this.mask = null, this.game = null, this._cache[8] = 0
                            }
                        }, n.Text.prototype.setShadow = function(t, e, i, s) {
                            this.style.shadowOffsetX = t || 0, this.style.shadowOffsetY = e || 0, this.style.shadowColor = i || "rgba(0,0,0,0)", this.style.shadowBlur = s || 0, this.dirty = !0
                        }, n.Text.prototype.setStyle = function(t) {
                            t = t || {}, t.font = t.font || "bold 20pt Arial", t.fill = t.fill || "black", t.align = t.align || "left", t.stroke = t.stroke || "black", t.strokeThickness = t.strokeThickness || 0, t.wordWrap = t.wordWrap || !1, t.wordWrapWidth = t.wordWrapWidth || 100, t.shadowOffsetX = t.shadowOffsetX || 0, t.shadowOffsetY = t.shadowOffsetY || 0, t.shadowColor = t.shadowColor || "rgba(0,0,0,0)", t.shadowBlur = t.shadowBlur || 0, this.style = t, this.dirty = !0
                        }, n.Text.prototype.updateText = function() {
                            this.context.font = this.style.font;
                            var t = this.text;
                            this.style.wordWrap && (t = this.runWordWrap(this.text));
                            for (var e = t.split(/(?:\r\n|\r|\n)/), i = [], s = 0, n = 0; n < e.length; n++) {
                                var r = this.context.measureText(e[n]).width;
                                i[n] = r, s = Math.max(s, r)
                            }
                            this.canvas.width = s + this.style.strokeThickness;
                            var o = this.determineFontHeight("font: " + this.style.font + ";") + this.style.strokeThickness + this._lineSpacing + this.style.shadowOffsetY;
                            for (this.canvas.height = o * e.length, navigator.isCocoonJS && this.context.clearRect(0, 0, this.canvas.width, this.canvas.height), this.context.fillStyle = this.style.fill, this.context.font = this.style.font, this.context.strokeStyle = this.style.stroke, this.context.lineWidth = this.style.strokeThickness, this.context.shadowOffsetX = this.style.shadowOffsetX, this.context.shadowOffsetY = this.style.shadowOffsetY, this.context.shadowColor = this.style.shadowColor, this.context.shadowBlur = this.style.shadowBlur, this.context.textBaseline = "top", this.context.lineCap = "round", this.context.lineJoin = "round", n = 0; n < e.length; n++) {
                                var a = new PIXI.Point(this.style.strokeThickness / 2, this.style.strokeThickness / 2 + n * o);
                                "right" === this.style.align ? a.x += s - i[n] : "center" === this.style.align && (a.x += (s - i[n]) / 2), a.y += this._lineSpacing, this.style.stroke && this.style.strokeThickness && this.context.strokeText(e[n], a.x, a.y), this.style.fill && this.context.fillText(e[n], a.x, a.y)
                            }
                            this.updateTexture()
                        }, n.Text.prototype.runWordWrap = function(t) {
                            for (var e = "", i = t.split("\n"), s = 0; s < i.length; s++) {
                                for (var n = this.style.wordWrapWidth, r = i[s].split(" "), o = 0; o < r.length; o++) {
                                    var a = this.context.measureText(r[o]).width,
                                        h = a + this.context.measureText(" ").width;
                                    h > n ? (o > 0 && (e += "\n"), e += r[o] + " ", n = this.style.wordWrapWidth - a) : (n -= h, e += r[o] + " ")
                                }
                                s < i.length - 1 && (e += "\n")
                            }
                            return e
                        }, Object.defineProperty(n.Text.prototype, "angle", {
                            get: function() {
                                return n.Math.radToDeg(this.rotation)
                            },
                            set: function(t) {
                                this.rotation = n.Math.degToRad(t)
                            }
                        }), Object.defineProperty(n.Text.prototype, "text", {
                            get: function() {
                                return this._text
                            },
                            set: function(t) {
                                t !== this._text && (this._text = t.toString() || " ", this.dirty = !0, this.updateTransform())
                            }
                        }), Object.defineProperty(n.Text.prototype, "font", {
                            get: function() {
                                return this._font
                            },
                            set: function(t) {
                                t !== this._font && (this._font = t.trim(), this.style.font = this._fontWeight + " " + this._fontSize + "px '" + this._font + "'", this.dirty = !0, this.updateTransform())
                            }
                        }), Object.defineProperty(n.Text.prototype, "fontSize", {
                            get: function() {
                                return this._fontSize
                            },
                            set: function(t) {
                                t = parseInt(t, 10), t !== this._fontSize && (this._fontSize = t, this.style.font = this._fontWeight + " " + this._fontSize + "px '" + this._font + "'", this.dirty = !0, this.updateTransform())
                            }
                        }), Object.defineProperty(n.Text.prototype, "fontWeight", {
                            get: function() {
                                return this._fontWeight
                            },
                            set: function(t) {
                                t !== this._fontWeight && (this._fontWeight = t, this.style.font = this._fontWeight + " " + this._fontSize + "px '" + this._font + "'", this.dirty = !0, this.updateTransform())
                            }
                        }), Object.defineProperty(n.Text.prototype, "fill", {
                            get: function() {
                                return this.style.fill
                            },
                            set: function(t) {
                                t !== this.style.fill && (this.style.fill = t, this.dirty = !0)
                            }
                        }), Object.defineProperty(n.Text.prototype, "align", {
                            get: function() {
                                return this.style.align
                            },
                            set: function(t) {
                                t !== this.style.align && (this.style.align = t, this.dirty = !0)
                            }
                        }), Object.defineProperty(n.Text.prototype, "stroke", {
                            get: function() {
                                return this.style.stroke
                            },
                            set: function(t) {
                                t !== this.style.stroke && (this.style.stroke = t, this.dirty = !0)
                            }
                        }), Object.defineProperty(n.Text.prototype, "strokeThickness", {
                            get: function() {
                                return this.style.strokeThickness
                            },
                            set: function(t) {
                                t !== this.style.strokeThickness && (this.style.strokeThickness = t, this.dirty = !0)
                            }
                        }), Object.defineProperty(n.Text.prototype, "wordWrap", {
                            get: function() {
                                return this.style.wordWrap
                            },
                            set: function(t) {
                                t !== this.style.wordWrap && (this.style.wordWrap = t, this.dirty = !0)
                            }
                        }), Object.defineProperty(n.Text.prototype, "wordWrapWidth", {
                            get: function() {
                                return this.style.wordWrapWidth
                            },
                            set: function(t) {
                                t !== this.style.wordWrapWidth && (this.style.wordWrapWidth = t, this.dirty = !0)
                            }
                        }), Object.defineProperty(n.Text.prototype, "lineSpacing", {
                            get: function() {
                                return this._lineSpacing
                            },
                            set: function(t) {
                                t !== this._lineSpacing && (this._lineSpacing = parseFloat(t), this.dirty = !0, this.updateTransform())
                            }
                        }), Object.defineProperty(n.Text.prototype, "shadowOffsetX", {
                            get: function() {
                                return this.style.shadowOffsetX
                            },
                            set: function(t) {
                                t !== this.style.shadowOffsetX && (this.style.shadowOffsetX = t, this.dirty = !0)
                            }
                        }), Object.defineProperty(n.Text.prototype, "shadowOffsetY", {
                            get: function() {
                                return this.style.shadowOffsetY
                            },
                            set: function(t) {
                                t !== this.style.shadowOffsetY && (this.style.shadowOffsetY = t, this.dirty = !0)
                            }
                        }), Object.defineProperty(n.Text.prototype, "shadowColor", {
                            get: function() {
                                return this.style.shadowColor
                            },
                            set: function(t) {
                                t !== this.style.shadowColor && (this.style.shadowColor = t, this.dirty = !0)
                            }
                        }), Object.defineProperty(n.Text.prototype, "shadowBlur", {
                            get: function() {
                                return this.style.shadowBlur
                            },
                            set: function(t) {
                                t !== this.style.shadowBlur && (this.style.shadowBlur = t, this.dirty = !0)
                            }
                        }), Object.defineProperty(n.Text.prototype, "inputEnabled", {
                            get: function() {
                                return this.input && this.input.enabled
                            },
                            set: function(t) {
                                t ? null === this.input ? (this.input = new n.InputHandler(this), this.input.start()) : this.input && !this.input.enabled && this.input.start() : this.input && this.input.enabled && this.input.stop()
                            }
                        }), Object.defineProperty(n.Text.prototype, "fixedToCamera", {
                            get: function() {
                                return !!this._cache[7]
                            },
                            set: function(t) {
                                t ? (this._cache[7] = 1, this.cameraOffset.set(this.x, this.y)) : this._cache[7] = 0
                            }
                        }), Object.defineProperty(n.Text.prototype, "destroyPhase", {
                            get: function() {
                                return !!this._cache[8]
                            }
                        }), n.BitmapText = function(t, e, i, s, r, o) {
                            e = e || 0, i = i || 0, s = s || "", r = r || "", o = o || 32, this.game = t, this.exists = !0, this.name = "", this.type = n.BITMAPTEXT, this.z = 0, this.world = new n.Point(e, i), this._text = r, this._font = s, this._fontSize = o, this._align = "left", this._tint = 16777215, this.events = new n.Events(this), this.input = null, this.cameraOffset = new n.Point, PIXI.BitmapText.call(this, r), this.position.set(e, i), this._cache = [0, 0, 0, 0, 1, 0, 1, 0, 0]
                        }, n.BitmapText.prototype = Object.create(PIXI.BitmapText.prototype), n.BitmapText.prototype.constructor = n.BitmapText, n.BitmapText.prototype.setStyle = function() {
                            this.style = {
                                align: this._align
                            }, this.fontName = this._font, this.fontSize = this._fontSize, this.dirty = !0
                        }, n.BitmapText.prototype.preUpdate = function() {
                            return this._cache[0] = this.world.x, this._cache[1] = this.world.y, this._cache[2] = this.rotation, this.exists && this.parent.exists ? (this.autoCull && (this.renderable = this.game.world.camera.screenView.intersects(this.getBounds())), this.world.setTo(this.game.camera.x + this.worldTransform.tx, this.game.camera.y + this.worldTransform.ty), this.visible && (this._cache[3] = this.game.stage.currentRenderOrderID++), !0) : (this.renderOrderID = -1, !1)
                        }, n.BitmapText.prototype.update = function() {}, n.BitmapText.prototype.postUpdate = function() {
                            1 === this._cache[7] && (this.position.x = (this.game.camera.view.x + this.cameraOffset.x) / this.game.camera.scale.x, this.position.y = (this.game.camera.view.y + this.cameraOffset.y) / this.game.camera.scale.y)
                        }, n.BitmapText.prototype.destroy = function(t) {
                            if (null !== this.game && !this.destroyPhase) {
                                "undefined" == typeof t && (t = !0), this._cache[8] = 1, this.parent && (this.parent instanceof n.Group ? this.parent.remove(this) : this.parent.removeChild(this));
                                var e = this.children.length;
                                if (t)
                                    for (; e--;) this.children[e].destroy ? this.children[e].destroy(t) : this.removeChild(this.children[e]);
                                else
                                    for (; e--;) this.removeChild(this.children[e]);
                                this.exists = !1, this.visible = !1, this.filters = null, this.mask = null, this.game = null, this._cache[8] = 0
                            }
                        }, Object.defineProperty(n.BitmapText.prototype, "align", {
                            get: function() {
                                return this._align
                            },
                            set: function(t) {
                                t !== this._align && (this._align = t, this.setStyle())
                            }
                        }), Object.defineProperty(n.BitmapText.prototype, "tint", {
                            get: function() {
                                return this._tint
                            },
                            set: function(t) {
                                t !== this._tint && (this._tint = t, this.dirty = !0)
                            }
                        }), Object.defineProperty(n.BitmapText.prototype, "angle", {
                            get: function() {
                                return n.Math.radToDeg(this.rotation)
                            },
                            set: function(t) {
                                this.rotation = n.Math.degToRad(t)
                            }
                        }), Object.defineProperty(n.BitmapText.prototype, "font", {
                            get: function() {
                                return this._font
                            },
                            set: function(t) {
                                t !== this._font && (this._font = t.trim(), this.style.font = this._fontSize + "px '" + this._font + "'", this.dirty = !0)
                            }
                        }), Object.defineProperty(n.BitmapText.prototype, "fontSize", {
                            get: function() {
                                return this._fontSize
                            },
                            set: function(t) {
                                t = parseInt(t, 10), t !== this._fontSize && (this._fontSize = t, this.style.font = this._fontSize + "px '" + this._font + "'", this.dirty = !0)
                            }
                        }), Object.defineProperty(n.BitmapText.prototype, "text", {
                            get: function() {
                                return this._text
                            },
                            set: function(t) {
                                t !== this._text && (this._text = t.toString() || " ", this.dirty = !0)
                            }
                        }), Object.defineProperty(n.BitmapText.prototype, "inputEnabled", {
                            get: function() {
                                return this.input && this.input.enabled
                            },
                            set: function(t) {
                                t ? null === this.input ? (this.input = new n.InputHandler(this), this.input.start()) : this.input && !this.input.enabled && this.input.start() : this.input && this.input.enabled && this.input.stop()
                            }
                        }), Object.defineProperty(n.BitmapText.prototype, "fixedToCamera", {
                            get: function() {
                                return !!this._cache[7]
                            },
                            set: function(t) {
                                t ? (this._cache[7] = 1, this.cameraOffset.set(this.x, this.y)) : this._cache[7] = 0
                            }
                        }), Object.defineProperty(n.BitmapText.prototype, "destroyPhase", {
                            get: function() {
                                return !!this._cache[8]
                            }
                        }), n.Button = function(t, e, i, s, r, o, a, h, l, c) {
                            e = e || 0, i = i || 0, s = s || null, r = r || null, o = o || this, n.Image.call(this, t, e, i, s, h), this.type = n.BUTTON, this._onOverFrameName = null, this._onOutFrameName = null, this._onDownFrameName = null, this._onUpFrameName = null, this._onOverFrameID = null, this._onOutFrameID = null, this._onDownFrameID = null, this._onUpFrameID = null, this.onOverMouseOnly = !1, this.onOverSound = null, this.onOutSound = null, this.onDownSound = null, this.onUpSound = null, this.onOverSoundMarker = "", this.onOutSoundMarker = "", this.onDownSoundMarker = "", this.onUpSoundMarker = "", this.onInputOver = new n.Signal, this.onInputOut = new n.Signal, this.onInputDown = new n.Signal, this.onInputUp = new n.Signal, this.freezeFrames = !1, this.forceOut = !1, this.inputEnabled = !0, this.input.start(0, !0), this.setFrames(a, h, l, c), null !== r && this.onInputUp.add(r, o), this.events.onInputOver.add(this.onInputOverHandler, this), this.events.onInputOut.add(this.onInputOutHandler, this), this.events.onInputDown.add(this.onInputDownHandler, this), this.events.onInputUp.add(this.onInputUpHandler, this)
                        }, n.Button.prototype = Object.create(n.Image.prototype), n.Button.prototype.constructor = n.Button, n.Button.prototype.clearFrames = function() {
                            this._onOverFrameName = null, this._onOverFrameID = null, this._onOutFrameName = null, this._onOutFrameID = null, this._onDownFrameName = null, this._onDownFrameID = null, this._onUpFrameName = null, this._onUpFrameID = null
                        }, n.Button.prototype.setFrames = function(t, e, i, s) {
                            this.clearFrames(), null !== t && ("string" == typeof t ? (this._onOverFrameName = t, this.input.pointerOver() && (this.frameName = t)) : (this._onOverFrameID = t, this.input.pointerOver() && (this.frame = t))), null !== e && ("string" == typeof e ? (this._onOutFrameName = e, this.input.pointerOver() === !1 && (this.frameName = e)) : (this._onOutFrameID = e, this.input.pointerOver() === !1 && (this.frame = e))), null !== i && ("string" == typeof i ? (this._onDownFrameName = i, this.input.pointerDown() && (this.frameName = i)) : (this._onDownFrameID = i, this.input.pointerDown() && (this.frame = i))), null !== s && ("string" == typeof s ? (this._onUpFrameName = s, this.input.pointerUp() && (this.frameName = s)) : (this._onUpFrameID = s, this.input.pointerUp() && (this.frame = s)))
                        }, n.Button.prototype.setSounds = function(t, e, i, s, n, r, o, a) {
                            this.setOverSound(t, e), this.setOutSound(n, r), this.setDownSound(i, s), this.setUpSound(o, a)
                        }, n.Button.prototype.setOverSound = function(t, e) {
                            this.onOverSound = null, this.onOverSoundMarker = "", t instanceof n.Sound && (this.onOverSound = t), "string" == typeof e && (this.onOverSoundMarker = e)
                        }, n.Button.prototype.setOutSound = function(t, e) {
                            this.onOutSound = null, this.onOutSoundMarker = "", t instanceof n.Sound && (this.onOutSound = t), "string" == typeof e && (this.onOutSoundMarker = e)
                        }, n.Button.prototype.setDownSound = function(t, e) {
                            this.onDownSound = null, this.onDownSoundMarker = "", t instanceof n.Sound && (this.onDownSound = t), "string" == typeof e && (this.onDownSoundMarker = e)
                        }, n.Button.prototype.setUpSound = function(t, e) {
                            this.onUpSound = null, this.onUpSoundMarker = "", t instanceof n.Sound && (this.onUpSound = t), "string" == typeof e && (this.onUpSoundMarker = e)
                        }, n.Button.prototype.onInputOverHandler = function(t, e) {
                            this.freezeFrames === !1 && this.setState(1), (!this.onOverMouseOnly || e.isMouse) && (this.onOverSound && this.onOverSound.play(this.onOverSoundMarker), this.onInputOver && this.onInputOver.dispatch(this, e))
                        }, n.Button.prototype.onInputOutHandler = function(t, e) {
                            this.freezeFrames === !1 && this.setState(2), this.onOutSound && this.onOutSound.play(this.onOutSoundMarker), this.onInputOut && this.onInputOut.dispatch(this, e)
                        }, n.Button.prototype.onInputDownHandler = function(t, e) {
                            this.freezeFrames === !1 && this.setState(3), this.onDownSound && this.onDownSound.play(this.onDownSoundMarker), this.onInputDown && this.onInputDown.dispatch(this, e)
                        }, n.Button.prototype.onInputUpHandler = function(t, e, i) {
                            this.onUpSound && this.onUpSound.play(this.onUpSoundMarker), this.onInputUp && this.onInputUp.dispatch(this, e, i), this.freezeFrames || this.setState(this.forceOut ? 2 : null !== this._onUpFrameName || null !== this._onUpFrameID ? 4 : i ? 1 : 2)
                        }, n.Button.prototype.setState = function(t) {
                            1 === t ? null != this._onOverFrameName ? this.frameName = this._onOverFrameName : null != this._onOverFrameID && (this.frame = this._onOverFrameID) : 2 === t ? null != this._onOutFrameName ? this.frameName = this._onOutFrameName : null != this._onOutFrameID && (this.frame = this._onOutFrameID) : 3 === t ? null != this._onDownFrameName ? this.frameName = this._onDownFrameName : null != this._onDownFrameID && (this.frame = this._onDownFrameID) : 4 === t && (null != this._onUpFrameName ? this.frameName = this._onUpFrameName : null != this._onUpFrameID && (this.frame = this._onUpFrameID))
                        }, n.Graphics = function(t, e, i) {
                            e = e || 0, i = i || 0, this.game = t, this.exists = !0, this.name = "", this.type = n.GRAPHICS, this.z = 0, this.world = new n.Point(e, i), this.cameraOffset = new n.Point, PIXI.Graphics.call(this), this.position.set(e, i), this._cache = [0, 0, 0, 0, 1, 0, 1, 0, 0]
                        }, n.Graphics.prototype = Object.create(PIXI.Graphics.prototype), n.Graphics.prototype.constructor = n.Graphics, n.Graphics.prototype.preUpdate = function() {
                            return this._cache[0] = this.world.x, this._cache[1] = this.world.y, this._cache[2] = this.rotation, this.exists && this.parent.exists ? (this.autoCull && (this.renderable = this.game.world.camera.screenView.intersects(this.getBounds())), this.world.setTo(this.game.camera.x + this.worldTransform.tx, this.game.camera.y + this.worldTransform.ty), this.visible && (this._cache[3] = this.game.stage.currentRenderOrderID++), !0) : (this.renderOrderID = -1, !1)
                        }, n.Graphics.prototype.update = function() {}, n.Graphics.prototype.postUpdate = function() {
                            1 === this._cache[7] && (this.position.x = (this.game.camera.view.x + this.cameraOffset.x) / this.game.camera.scale.x, this.position.y = (this.game.camera.view.y + this.cameraOffset.y) / this.game.camera.scale.y)
                        }, n.Graphics.prototype.destroy = function(t) {
                            if (null !== this.game && !this.destroyPhase) {
                                "undefined" == typeof t && (t = !0), this._cache[8] = 1, this.clear(), this.parent && (this.parent instanceof n.Group ? this.parent.remove(this) : this.parent.removeChild(this));
                                var e = this.children.length;
                                if (t)
                                    for (; e--;) this.children[e].destroy(t);
                                else
                                    for (; e--;) this.removeChild(this.children[e]);
                                this.exists = !1, this.visible = !1, this.game = null, this._cache[8] = 0
                            }
                        }, n.Graphics.prototype.drawPolygon = function(t) {
                            this.moveTo(t.points[0].x, t.points[0].y);
                            for (var e = 1; e < t.points.length; e += 1) this.lineTo(t.points[e].x, t.points[e].y);
                            this.lineTo(t.points[0].x, t.points[0].y)
                        }, n.Graphics.prototype.drawTriangle = function(t, e) {
                            "undefined" == typeof e && (e = !1);
                            var i = new n.Polygon(t);
                            if (e) {
                                var s = new n.Point(this.game.camera.x - t[0].x, this.game.camera.y - t[0].y),
                                    r = new n.Point(t[1].x - t[0].x, t[1].y - t[0].y),
                                    o = new n.Point(t[1].x - t[2].x, t[1].y - t[2].y),
                                    a = o.cross(r);
                                s.dot(a) > 0 && this.drawPolygon(i)
                            } else this.drawPolygon(i)
                        }, n.Graphics.prototype.drawTriangles = function(t, e, i) {
                            "undefined" == typeof i && (i = !1);
                            var s, r = new n.Point,
                                o = new n.Point,
                                a = new n.Point,
                                h = [];
                            if (e)
                                if (t[0] instanceof n.Point)
                                    for (s = 0; s < e.length / 3; s++) h.push(t[e[3 * s]]), h.push(t[e[3 * s + 1]]), h.push(t[e[3 * s + 2]]), 3 === h.length && (this.drawTriangle(h, i), h = []);
                                else
                                    for (s = 0; s < e.length; s++) r.x = t[2 * e[s]], r.y = t[2 * e[s] + 1], h.push(r.copyTo({})), 3 === h.length && (this.drawTriangle(h, i), h = []);
                            else if (t[0] instanceof n.Point)
                                for (s = 0; s < t.length / 3; s++) this.drawTriangle([t[3 * s], t[3 * s + 1], t[3 * s + 2]], i);
                            else
                                for (s = 0; s < t.length / 6; s++) r.x = t[6 * s + 0], r.y = t[6 * s + 1], o.x = t[6 * s + 2], o.y = t[6 * s + 3], a.x = t[6 * s + 4], a.y = t[6 * s + 5], this.drawTriangle([r, o, a], i)
                        }, Object.defineProperty(n.Graphics.prototype, "angle", {
                            get: function() {
                                return n.Math.radToDeg(this.rotation)
                            },
                            set: function(t) {
                                this.rotation = n.Math.degToRad(t)
                            }
                        }), Object.defineProperty(n.Graphics.prototype, "fixedToCamera", {
                            get: function() {
                                return !!this._cache[7]
                            },
                            set: function(t) {
                                t ? (this._cache[7] = 1, this.cameraOffset.set(this.x, this.y)) : this._cache[7] = 0
                            }
                        }), Object.defineProperty(n.Graphics.prototype, "destroyPhase", {
                            get: function() {
                                return !!this._cache[8]
                            }
                        }), n.RenderTexture = function(t, e, i, s, r) {
                            "undefined" == typeof s && (s = ""), "undefined" == typeof r && (r = n.scaleModes.DEFAULT), this.game = t, this.key = s, this.type = n.RENDERTEXTURE, this._temp = new n.Point, PIXI.RenderTexture.call(this, e, i, this.game.renderer, r)
                        }, n.RenderTexture.prototype = Object.create(PIXI.RenderTexture.prototype), n.RenderTexture.prototype.constructor = n.RenderTexture, n.RenderTexture.prototype.renderXY = function(t, e, i, s) {
                            this._temp.set(e, i), this.render(t, this._temp, s)
                        }, n.SpriteBatch = function(t, e, i, s) {
                            ("undefined" == typeof e || null === e) && (e = t.world), PIXI.SpriteBatch.call(this), n.Group.call(this, t, e, i, s), this.type = n.SPRITEBATCH
                        }, n.SpriteBatch.prototype = n.Utils.extend(!0, n.SpriteBatch.prototype, n.Group.prototype, PIXI.SpriteBatch.prototype), n.SpriteBatch.prototype.constructor = n.SpriteBatch, n.RetroFont = function(t, e, i, s, r, o, a, h, l, c) {
                            if (!t.cache.checkImageKey(e)) return !1;
                            ("undefined" == typeof o || null === o) && (o = t.cache.getImage(e).width / i), this.characterWidth = i, this.characterHeight = s, this.characterSpacingX = a || 0, this.characterSpacingY = h || 0, this.characterPerRow = o, this.offsetX = l || 0, this.offsetY = c || 0, this.align = "left", this.multiLine = !1, this.autoUpperCase = !0, this.customSpacingX = 0, this.customSpacingY = 0, this.fixedWidth = 0, this.fontSet = t.cache.getImage(e), this._text = "", this.grabData = [];
                            for (var u = this.offsetX, d = this.offsetY, p = 0, f = new n.FrameData, g = 0; g < r.length; g++) {
                                var m = t.rnd.uuid(),
                                    y = f.addFrame(new n.Frame(g, u, d, this.characterWidth, this.characterHeight, "", m));
                                this.grabData[r.charCodeAt(g)] = y.index, PIXI.TextureCache[m] = new PIXI.Texture(PIXI.BaseTextureCache[e], {
                                    x: u,
                                    y: d,
                                    width: this.characterWidth,
                                    height: this.characterHeight
                                }), p++, p == this.characterPerRow ? (p = 0, u = this.offsetX, d += this.characterHeight + this.characterSpacingY) : u += this.characterWidth + this.characterSpacingX
                            }
                            t.cache.updateFrameData(e, f), this.stamp = new n.Image(t, 0, 0, e, 0), n.RenderTexture.call(this, t, 100, 100, "", n.scaleModes.NEAREST), this.type = n.RETROFONT
                        }, n.RetroFont.prototype = Object.create(n.RenderTexture.prototype), n.RetroFont.prototype.constructor = n.RetroFont, n.RetroFont.ALIGN_LEFT = "left", n.RetroFont.ALIGN_RIGHT = "right", n.RetroFont.ALIGN_CENTER = "center", n.RetroFont.TEXT_SET1 = " !\"#$%&'()*+,-./0123456789:;<=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\\]^_`abcdefghijklmnopqrstuvwxyz{|}~", n.RetroFont.TEXT_SET2 = " !\"#$%&'()*+,-./0123456789:;<=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ", n.RetroFont.TEXT_SET3 = "ABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789 ", n.RetroFont.TEXT_SET4 = "ABCDEFGHIJKLMNOPQRSTUVWXYZ 0123456789", n.RetroFont.TEXT_SET5 = "ABCDEFGHIJKLMNOPQRSTUVWXYZ.,/() '!?-*:0123456789", n.RetroFont.TEXT_SET6 = "ABCDEFGHIJKLMNOPQRSTUVWXYZ!?:;0123456789\"(),-.' ", n.RetroFont.TEXT_SET7 = "AGMSY+:4BHNTZ!;5CIOU.?06DJPV,(17EKQW\")28FLRX-'39", n.RetroFont.TEXT_SET8 = "0123456789 .ABCDEFGHIJKLMNOPQRSTUVWXYZ", n.RetroFont.TEXT_SET9 = "ABCDEFGHIJKLMNOPQRSTUVWXYZ()-0123456789.:,'\"?!", n.RetroFont.TEXT_SET10 = "ABCDEFGHIJKLMNOPQRSTUVWXYZ", n.RetroFont.TEXT_SET11 = "ABCDEFGHIJKLMNOPQRSTUVWXYZ.,\"-+!?()':;0123456789", n.RetroFont.prototype.setFixedWidth = function(t, e) {
                            "undefined" == typeof e && (e = "left"), this.fixedWidth = t, this.align = e
                        }, n.RetroFont.prototype.setText = function(t, e, i, s, n, r) {
                            this.multiLine = e || !1, this.customSpacingX = i || 0, this.customSpacingY = s || 0, this.align = n || "left", this.autoUpperCase = r ? !1 : !0, t.length > 0 && (this.text = t)
                        }, n.RetroFont.prototype.buildRetroFontText = function() {
                            var t = 0,
                                e = 0;
                            if (this.clear(), this.multiLine) {
                                var i = this._text.split("\n");
                                this.fixedWidth > 0 ? this.resize(this.fixedWidth, i.length * (this.characterHeight + this.customSpacingY) - this.customSpacingY, !0) : this.resize(this.getLongestLine() * (this.characterWidth + this.customSpacingX), i.length * (this.characterHeight + this.customSpacingY) - this.customSpacingY, !0);
                                for (var s = 0; s < i.length; s++) {
                                    switch (this.align) {
                                        case n.RetroFont.ALIGN_LEFT:
                                            t = 0;
                                            break;
                                        case n.RetroFont.ALIGN_RIGHT:
                                            t = this.width - i[s].length * (this.characterWidth + this.customSpacingX);
                                            break;
                                        case n.RetroFont.ALIGN_CENTER:
                                            t = this.width / 2 - i[s].length * (this.characterWidth + this.customSpacingX) / 2, t += this.customSpacingX / 2
                                    }
                                    0 > t && (t = 0), this.pasteLine(i[s], t, e, this.customSpacingX), e += this.characterHeight + this.customSpacingY
                                }
                            } else {
                                switch (this.fixedWidth > 0 ? this.resize(this.fixedWidth, this.characterHeight, !0) : this.resize(this._text.length * (this.characterWidth + this.customSpacingX), this.characterHeight, !0), this.align) {
                                    case n.RetroFont.ALIGN_LEFT:
                                        t = 0;
                                        break;
                                    case n.RetroFont.ALIGN_RIGHT:
                                        t = this.width - this._text.length * (this.characterWidth + this.customSpacingX);
                                        break;
                                    case n.RetroFont.ALIGN_CENTER:
                                        t = this.width / 2 - this._text.length * (this.characterWidth + this.customSpacingX) / 2, t += this.customSpacingX / 2
                                }
                                this.textureBuffer.clear(), this.pasteLine(this._text, t, 0, this.customSpacingX)
                            }
                        }, n.RetroFont.prototype.pasteLine = function(t, e, i, s) {
                            for (var r = new n.Point, o = 0; o < t.length; o++)
                                if (" " == t.charAt(o)) e += this.characterWidth + s;
                                else if (this.grabData[t.charCodeAt(o)] >= 0 && (this.stamp.frame = this.grabData[t.charCodeAt(o)], r.set(e, i), this.render(this.stamp, r, !1), e += this.characterWidth + s, e > this.width)) break
                        }, n.RetroFont.prototype.getLongestLine = function() {
                            var t = 0;
                            if (this._text.length > 0)
                                for (var e = this._text.split("\n"), i = 0; i < e.length; i++) e[i].length > t && (t = e[i].length);
                            return t
                        }, n.RetroFont.prototype.removeUnsupportedCharacters = function(t) {
                            for (var e = "", i = 0; i < this._text.length; i++) {
                                var s = this._text[i],
                                    n = s.charCodeAt(0);
                                (this.grabData[n] >= 0 || !t && "\n" === s) && (e = e.concat(s))
                            }
                            return e
                        }, n.RetroFont.prototype.updateOffset = function(t, e) {
                            if (this.offsetX !== t || this.offsetY !== e) {
                                for (var i = t - this.offsetX, s = e - this.offsetY, n = this.game.cache.getFrameData(this.stamp.key).getFrames(), r = n.length; r--;) n[r].x += i, n[r].y += s, PIXI.TextureCache[n[r].uuid].frame.x = n[r].x, PIXI.TextureCache[n[r].uuid].frame.y = n[r].y;
                                this.buildRetroFontText()
                            }
                        }, Object.defineProperty(n.RetroFont.prototype, "text", {
                            get: function() {
                                return this._text
                            },
                            set: function(t) {
                                var e;
                                e = this.autoUpperCase ? t.toUpperCase() : t, e !== this._text && (this._text = e, this.removeUnsupportedCharacters(this.multiLine), this.buildRetroFontText())
                            }
                        }), Object.defineProperty(n.RetroFont.prototype, "smoothed", {
                            get: function() {
                                return this.stamp.smoothed
                            },
                            set: function(t) {
                                this.stamp.smoothed = t, this.buildRetroFontText()
                            }
                        }), n.Particle = function(t, e, i, s, r) {
                            n.Sprite.call(this, t, e, i, s, r), this.autoScale = !1, this.scaleData = null, this._s = 0, this.autoAlpha = !1, this.alphaData = null, this._a = 0
                        }, n.Particle.prototype = Object.create(n.Sprite.prototype), n.Particle.prototype.constructor = n.Particle, n.Particle.prototype.update = function() {
                            this.autoScale && (this._s--, this._s ? this.scale.set(this.scaleData[this._s].x, this.scaleData[this._s].y) : this.autoScale = !1), this.autoAlpha && (this._a--, this._a ? this.alpha = this.alphaData[this._a].v : this.autoAlpha = !1)
                        }, n.Particle.prototype.onEmit = function() {}, n.Particle.prototype.setAlphaData = function(t) {
                            this.alphaData = t, this._a = t.length - 1, this.alpha = this.alphaData[this._a].v, this.autoAlpha = !0
                        }, n.Particle.prototype.setScaleData = function(t) {
                            this.scaleData = t, this._s = t.length - 1, this.scale.set(this.scaleData[this._s].x, this.scaleData[this._s].y), this.autoScale = !0
                        }, n.Particle.prototype.reset = function(t, e, i) {
                            return "undefined" == typeof i && (i = 1), this.world.setTo(t, e), this.position.x = t, this.position.y = e, this.alive = !0, this.exists = !0, this.visible = !0, this.renderable = !0, this._outOfBoundsFired = !1, this.health = i, this.body && this.body.reset(t, e, !1, !1), this._cache[4] = 1, this.alpha = 1, this.scale.set(1), this.autoScale = !1, this.autoAlpha = !1, this
                        }, n.Canvas = {
                            create: function(t, e, i, s) {
                                "undefined" == typeof s && (s = !1), t = t || 256, e = e || 256;
                                var n = document.createElement("canvas");
                                return "string" == typeof i && "" !== i && (n.id = i), n.width = t, n.height = e, n.style.display = "block", n
                            },
                            getOffset: function(t, e) {
                                e = e || new n.Point;
                                var i = t.getBoundingClientRect(),
                                    s = t.clientTop || document.body.clientTop || 0,
                                    r = t.clientLeft || document.body.clientLeft || 0,
                                    o = 0,
                                    a = 0;
                                return "CSS1Compat" === document.compatMode ? (o = window.pageYOffset || document.documentElement.scrollTop || t.scrollTop || 0, a = window.pageXOffset || document.documentElement.scrollLeft || t.scrollLeft || 0) : (o = window.pageYOffset || document.body.scrollTop || t.scrollTop || 0, a = window.pageXOffset || document.body.scrollLeft || t.scrollLeft || 0), e.x = i.left + a - r, e.y = i.top + o - s, e
                            },
                            getAspectRatio: function(t) {
                                return t.width / t.height
                            },
                            setBackgroundColor: function(t, e) {
                                return e = e || "rgb(0,0,0)", t.style.backgroundColor = e, t
                            },
                            setTouchAction: function(t, e) {
                                return e = e || "none", t.style.msTouchAction = e, t.style["ms-touch-action"] = e, t.style["touch-action"] = e, t
                            },
                            setUserSelect: function(t, e) {
                                return e = e || "none", t.style["-webkit-touch-callout"] = e, t.style["-webkit-user-select"] = e, t.style["-khtml-user-select"] = e, t.style["-moz-user-select"] = e, t.style["-ms-user-select"] = e, t.style["user-select"] = e, t.style["-webkit-tap-highlight-color"] = "rgba(0, 0, 0, 0)", t
                            },
                            addToDOM: function(t, e, i) {
                                var s;
                                return "undefined" == typeof i && (i = !0), e && ("string" == typeof e ? s = document.getElementById(e) : "object" == typeof e && 1 === e.nodeType && (s = e)), s || (s = document.body), i && s.style && (s.style.overflow = "hidden"), s.appendChild(t), t
                            },
                            setTransform: function(t, e, i, s, n, r, o) {
                                return t.setTransform(s, r, o, n, e, i), t
                            },
                            setSmoothingEnabled: function(t, e) {
                                return t.imageSmoothingEnabled = e, t.mozImageSmoothingEnabled = e, t.oImageSmoothingEnabled = e, t.webkitImageSmoothingEnabled = e, t.msImageSmoothingEnabled = e, t
                            },
                            setImageRenderingCrisp: function(t) {
                                return t.style["image-rendering"] = "optimizeSpeed", t.style["image-rendering"] = "crisp-edges", t.style["image-rendering"] = "-moz-crisp-edges", t.style["image-rendering"] = "-webkit-optimize-contrast", t.style["image-rendering"] = "optimize-contrast", t.style.msInterpolationMode = "nearest-neighbor", t
                            },
                            setImageRenderingBicubic: function(t) {
                                return t.style["image-rendering"] = "auto", t.style.msInterpolationMode = "bicubic", t
                            }
                        }, n.Device = function(t) {
                            this.game = t, this.desktop = !1, this.iOS = !1, this.cocoonJS = !1, this.ejecta = !1, this.crosswalk = !1, this.android = !1, this.chromeOS = !1, this.linux = !1, this.macOS = !1, this.windows = !1, this.windowsPhone = !1, this.canvas = !1, this.file = !1, this.fileSystem = !1, this.localStorage = !1, this.webGL = !1, this.worker = !1, this.touch = !1, this.mspointer = !1, this.css3D = !1, this.pointerLock = !1, this.typedArray = !1, this.vibration = !1, this.getUserMedia = !1, this.quirksMode = !1, this.arora = !1, this.chrome = !1, this.epiphany = !1, this.firefox = !1, this.ie = !1, this.ieVersion = 0, this.trident = !1, this.tridentVersion = 0, this.mobileSafari = !1, this.midori = !1, this.opera = !1, this.safari = !1, this.webApp = !1, this.silk = !1, this.audioData = !1, this.webAudio = !1, this.ogg = !1, this.opus = !1, this.mp3 = !1, this.wav = !1, this.m4a = !1, this.webm = !1, this.iPhone = !1, this.iPhone4 = !1, this.iPad = !1, this.pixelRatio = 0, this.littleEndian = !1, this.support32bit = !1, this.fullscreen = !1, this.requestFullscreen = "", this.cancelFullscreen = "", this.fullscreenKeyboard = !1, this._checkOS(), this._checkAudio(), this._checkBrowser(), this._checkCSS3D(), this._checkDevice(), this._checkFeatures()
                        }, n.Device.LITTLE_ENDIAN = !1, n.Device.prototype = {
                            _checkOS: function() {
                                var t = navigator.userAgent;
                                /Android/.test(t) ? this.android = !0 : /CrOS/.test(t) ? this.chromeOS = !0 : /iP[ao]d|iPhone/i.test(t) ? this.iOS = !0 : /Linux/.test(t) ? this.linux = !0 : /Mac OS/.test(t) ? this.macOS = !0 : /Windows/.test(t) && (this.windows = !0, /Windows Phone/i.test(t) && (this.windowsPhone = !0)), (this.windows || this.macOS || this.linux && this.silk === !1) && (this.desktop = !0), (this.windowsPhone || /Windows NT/i.test(t) && /Touch/i.test(t)) && (this.desktop = !1)
                            },
                            _checkFeatures: function() {
                                this.canvas = !!window.CanvasRenderingContext2D || this.cocoonJS;
                                try {
                                    this.localStorage = !!localStorage.getItem
                                } catch (t) {
                                    this.localStorage = !1
                                }
                                this.file = !!(window.File && window.FileReader && window.FileList && window.Blob), this.fileSystem = !!window.requestFileSystem, this.webGL = function() {
                                    try {
                                        var t = document.createElement("canvas");
                                        return !!window.WebGLRenderingContext && (t.getContext("webgl") || t.getContext("experimental-webgl"))
                                    } catch (e) {
                                        return !1
                                    }
                                }(), this.webGL = null === this.webGL || this.webGL === !1 ? !1 : !0, this.worker = !!window.Worker, ("ontouchstart" in document.documentElement || window.navigator.maxTouchPoints && window.navigator.maxTouchPoints > 1) && (this.touch = !0), (window.navigator.msPointerEnabled || window.navigator.pointerEnabled) && (this.mspointer = !0), this.pointerLock = "pointerLockElement" in document || "mozPointerLockElement" in document || "webkitPointerLockElement" in document, this.quirksMode = "CSS1Compat" === document.compatMode ? !1 : !0, this.getUserMedia = !!(navigator.getUserMedia || navigator.webkitGetUserMedia || navigator.mozGetUserMedia || navigator.msGetUserMedia)
                            },
                            checkFullScreenSupport: function() {
                                for (var t = ["requestFullscreen", "requestFullScreen", "webkitRequestFullscreen", "webkitRequestFullScreen", "msRequestFullscreen", "msRequestFullScreen", "mozRequestFullScreen", "mozRequestFullscreen"], e = 0; e < t.length; e++)
                                    if (this.game.canvas[t[e]]) {
                                        this.fullscreen = !0, this.requestFullscreen = t[e];
                                        break
                                    }
                                var i = ["cancelFullScreen", "exitFullscreen", "webkitCancelFullScreen", "webkitExitFullscreen", "msCancelFullScreen", "msExitFullscreen", "mozCancelFullScreen", "mozExitFullscreen"];
                                if (this.fullscreen)
                                    for (var e = 0; e < i.length; e++)
                                        if (document[i[e]]) {
                                            this.cancelFullscreen = i[e];
                                            break
                                        }
                                window.Element && Element.ALLOW_KEYBOARD_INPUT && (this.fullscreenKeyboard = !0)
                            },
                            _checkBrowser: function() {
                                var t = navigator.userAgent;
                                /Arora/.test(t) ? this.arora = !0 : /Chrome/.test(t) ? this.chrome = !0 : /Epiphany/.test(t) ? this.epiphany = !0 : /Firefox/.test(t) ? this.firefox = !0 : /AppleWebKit/.test(t) && this.iOS ? this.mobileSafari = !0 : /MSIE (\d+\.\d+);/.test(t) ? (this.ie = !0, this.ieVersion = parseInt(RegExp.$1, 10)) : /Midori/.test(t) ? this.midori = !0 : /Opera/.test(t) ? this.opera = !0 : /Safari/.test(t) ? this.safari = !0 : /Trident\/(\d+\.\d+)(.*)rv:(\d+\.\d+)/.test(t) && (this.ie = !0, this.trident = !0, this.tridentVersion = parseInt(RegExp.$1, 10), this.ieVersion = parseInt(RegExp.$3, 10)), /Silk/.test(t) && (this.silk = !0), navigator.standalone && (this.webApp = !0), navigator.isCocoonJS && (this.cocoonJS = !0), "undefined" != typeof window.ejecta && (this.ejecta = !0), /Crosswalk/.test(t) && (this.crosswalk = !0)
                            },
                            _checkAudio: function() {
                                this.audioData = !!window.Audio, this.webAudio = !(!window.webkitAudioContext && !window.AudioContext);
                                var t = document.createElement("audio"),
                                    e = !1;
                                try {
                                    (e = !!t.canPlayType) && (t.canPlayType('audio/ogg; codecs="vorbis"').replace(/^no$/, "") && (this.ogg = !0), t.canPlayType('audio/ogg; codecs="opus"').replace(/^no$/, "") && (this.opus = !0), t.canPlayType("audio/mpeg;").replace(/^no$/, "") && (this.mp3 = !0), t.canPlayType('audio/wav; codecs="1"').replace(/^no$/, "") && (this.wav = !0), (t.canPlayType("audio/x-m4a;") || t.canPlayType("audio/aac;").replace(/^no$/, "")) && (this.m4a = !0), t.canPlayType('audio/webm; codecs="vorbis"').replace(/^no$/, "") && (this.webm = !0))
                                } catch (i) {}
                            },
                            _checkDevice: function() {
                                this.pixelRatio = window.devicePixelRatio || 1, this.iPhone = -1 != navigator.userAgent.toLowerCase().indexOf("iphone"), this.iPhone4 = 2 == this.pixelRatio && this.iPhone, this.iPad = -1 != navigator.userAgent.toLowerCase().indexOf("ipad"), this.typedArray = "undefined" != typeof Int8Array ? !0 : !1, "undefined" != typeof ArrayBuffer && "undefined" != typeof Uint8Array && "undefined" != typeof Uint32Array && (this.littleEndian = this._checkIsLittleEndian(), n.Device.LITTLE_ENDIAN = this.littleEndian), this.support32bit = "undefined" != typeof ArrayBuffer && "undefined" != typeof Uint8ClampedArray && "undefined" != typeof Int32Array && null !== this.littleEndian && this._checkIsUint8ClampedImageData(), navigator.vibrate = navigator.vibrate || navigator.webkitVibrate || navigator.mozVibrate || navigator.msVibrate, navigator.vibrate && (this.vibration = !0)
                            },
                            _checkIsLittleEndian: function() {
                                var t = new ArrayBuffer(4),
                                    e = new Uint8Array(t),
                                    i = new Uint32Array(t);
                                return e[0] = 161, e[1] = 178, e[2] = 195, e[3] = 212, 3569595041 == i[0] ? !0 : 2712847316 == i[0] ? !1 : null
                            },
                            _checkIsUint8ClampedImageData: function() {
                                if ("undefined" == typeof Uint8ClampedArray) return !1;
                                var t = document.createElement("canvas"),
                                    e = t.getContext("2d");
                                if (!e) return !1;
                                var i = e.createImageData(1, 1);
                                return i.data instanceof Uint8ClampedArray
                            },
                            _checkCSS3D: function() {
                                var t, e = document.createElement("p"),
                                    i = {
                                        webkitTransform: "-webkit-transform",
                                        OTransform: "-o-transform",
                                        msTransform: "-ms-transform",
                                        MozTransform: "-moz-transform",
                                        transform: "transform"
                                    };
                                document.body.insertBefore(e, null);
                                for (var s in i) void 0 !== e.style[s] && (e.style[s] = "translate3d(1px,1px,1px)", t = window.getComputedStyle(e).getPropertyValue(i[s]));
                                document.body.removeChild(e), this.css3D = void 0 !== t && t.length > 0 && "none" !== t
                            },
                            canPlayAudio: function(t) {
                                return "mp3" == t && this.mp3 ? !0 : "ogg" == t && (this.ogg || this.opus) ? !0 : "m4a" == t && this.m4a ? !0 : "wav" == t && this.wav ? !0 : "webm" == t && this.webm ? !0 : !1
                            },
                            isConsoleOpen: function() {
                                return window.console && window.console.firebug ? !0 : window.console && (console.profile(), console.profileEnd(), console.clear && console.clear(), console.profiles) ? console.profiles.length > 0 : !1
                            }
                        }, n.Device.prototype.constructor = n.Device, n.RequestAnimationFrame = function(t, e) {
                            "undefined" == typeof e && (e = !1), this.game = t, this.isRunning = !1, this.forceSetTimeOut = e;
                            for (var i = ["ms", "moz", "webkit", "o"], s = 0; s < i.length && !window.requestAnimationFrame; s++) window.requestAnimationFrame = window[i[s] + "RequestAnimationFrame"], window.cancelAnimationFrame = window[i[s] + "CancelAnimationFrame"];
                            this._isSetTimeOut = !1, this._onLoop = null, this._timeOutID = null
                        }, n.RequestAnimationFrame.prototype = {
                            start: function() {
                                this.isRunning = !0;
                                var t = this;
                                !window.requestAnimationFrame || this.forceSetTimeOut ? (this._isSetTimeOut = !0, this._onLoop = function() {
                                    return t.updateSetTimeout()
                                }, this._timeOutID = window.setTimeout(this._onLoop, 0)) : (this._isSetTimeOut = !1, this._onLoop = function(e) {
                                    return t.updateRAF(e)
                                }, this._timeOutID = window.requestAnimationFrame(this._onLoop))
                            },
                            updateRAF: function() {
                                this.game.update(Date.now()), this._timeOutID = window.requestAnimationFrame(this._onLoop)
                            },
                            updateSetTimeout: function() {
                                this.game.update(Date.now()), this._timeOutID = window.setTimeout(this._onLoop, this.game.time.timeToCall)
                            },
                            stop: function() {
                                this._isSetTimeOut ? clearTimeout(this._timeOutID) : window.cancelAnimationFrame(this._timeOutID), this.isRunning = !1
                            },
                            isSetTimeOut: function() {
                                return this._isSetTimeOut
                            },
                            isRAF: function() {
                                return this._isSetTimeOut === !1
                            }
                        }, n.RequestAnimationFrame.prototype.constructor = n.RequestAnimationFrame, n.Math = {
                            PI2: 2 * Math.PI,
                            fuzzyEqual: function(t, e, i) {
                                return "undefined" == typeof i && (i = 1e-4), Math.abs(t - e) < i
                            },
                            fuzzyLessThan: function(t, e, i) {
                                return "undefined" == typeof i && (i = 1e-4), e + i > t
                            },
                            fuzzyGreaterThan: function(t, e, i) {
                                return "undefined" == typeof i && (i = 1e-4), t > e - i
                            },
                            fuzzyCeil: function(t, e) {
                                return "undefined" == typeof e && (e = 1e-4), Math.ceil(t - e)
                            },
                            fuzzyFloor: function(t, e) {
                                return "undefined" == typeof e && (e = 1e-4), Math.floor(t + e)
                            },
                            average: function() {
                                for (var t = [], e = 0; e < arguments.length - 0; e++) t[e] = arguments[e + 0];
                                for (var i = 0, s = 0; s < t.length; s++) i += t[s];
                                return i / t.length
                            },
                            truncate: function(t) {
                                return t > 0 ? Math.floor(t) : Math.ceil(t)
                            },
                            shear: function(t) {
                                return t % 1
                            },
                            snapTo: function(t, e, i) {
                                return "undefined" == typeof i && (i = 0), 0 === e ? t : (t -= i, t = e * Math.round(t / e), i + t)
                            },
                            snapToFloor: function(t, e, i) {
                                return "undefined" == typeof i && (i = 0), 0 === e ? t : (t -= i, t = e * Math.floor(t / e), i + t)
                            },
                            snapToCeil: function(t, e, i) {
                                return "undefined" == typeof i && (i = 0), 0 === e ? t : (t -= i, t = e * Math.ceil(t / e), i + t)
                            },
                            snapToInArray: function(t, e, i) {
                                if ("undefined" == typeof i && (i = !0), i && e.sort(), t < e[0]) return e[0];
                                for (var s = 1; e[s] < t;) s++;
                                var n = e[s - 1],
                                    r = s < e.length ? e[s] : Number.POSITIVE_INFINITY;
                                return t - n >= r - t ? r : n
                            },
                            roundTo: function(t, e, i) {
                                "undefined" == typeof e && (e = 0), "undefined" == typeof i && (i = 10);
                                var s = Math.pow(i, -e);
                                return Math.round(t * s) / s
                            },
                            floorTo: function(t, e, i) {
                                "undefined" == typeof e && (e = 0), "undefined" == typeof i && (i = 10);
                                var s = Math.pow(i, -e);
                                return Math.floor(t * s) / s
                            },
                            ceilTo: function(t, e, i) {
                                "undefined" == typeof e && (e = 0), "undefined" == typeof i && (i = 10);
                                var s = Math.pow(i, -e);
                                return Math.ceil(t * s) / s
                            },
                            interpolateFloat: function(t, e, i) {
                                return (e - t) * i + t
                            },
                            angleBetween: function(t, e, i, s) {
                                return Math.atan2(s - e, i - t)
                            },
                            angleBetweenPoints: function(t, e) {
                                return Math.atan2(e.y - t.y, e.x - t.x)
                            },
                            reverseAngle: function(t) {
                                return this.normalizeAngle(t + Math.PI, !0)
                            },
                            normalizeAngle: function(t) {
                                return t %= 2 * Math.PI, t >= 0 ? t : t + 2 * Math.PI
                            },
                            normalizeLatitude: function(t) {
                                return Math.max(-90, Math.min(90, t))
                            },
                            normalizeLongitude: function(t) {
                                return t % 360 == 180 ? 180 : (t %= 360, -180 > t ? t + 360 : t > 180 ? t - 360 : t)
                            },
                            chanceRoll: function(t) {
                                return "undefined" == typeof t && (t = 50), 0 >= t ? !1 : t >= 100 ? !0 : 100 * Math.random() >= t ? !1 : !0
                            },
                            numberArray: function(t, e) {
                                for (var i = [], s = t; e >= s; s++) i.push(s);
                                return i
                            },
                            maxAdd: function(t, e, i) {
                                return t += e, t > i && (t = i), t
                            },
                            minSub: function(t, e, i) {
                                return t -= e, i > t && (t = i), t
                            },
                            wrap: function(t, e, i) {
                                var s = i - e;
                                if (0 >= s) return 0;
                                var n = (t - e) % s;
                                return 0 > n && (n += s), n + e
                            },
                            wrapValue: function(t, e, i) {
                                var s;
                                return t = Math.abs(t), e = Math.abs(e), i = Math.abs(i), s = (t + e) % i
                            },
                            limitValue: function(t, e, i) {
                                return e > t ? e : t > i ? i : t
                            },
                            randomSign: function() {
                                return Math.random() > .5 ? 1 : -1
                            },
                            isOdd: function(t) {
                                return 1 & t
                            },
                            isEven: function(t) {
                                return 1 & t ? !1 : !0
                            },
                            min: function() {
                                if (1 === arguments.length && "object" == typeof arguments[0]) var t = arguments[0];
                                else var t = arguments;
                                for (var e = 1, i = 0, s = t.length; s > e; e++) t[e] < t[i] && (i = e);
                                return t[i]
                            },
                            max: function() {
                                if (1 === arguments.length && "object" == typeof arguments[0]) var t = arguments[0];
                                else var t = arguments;
                                for (var e = 1, i = 0, s = t.length; s > e; e++) t[e] > t[i] && (i = e);
                                return t[i]
                            },
                            minProperty: function(t) {
                                if (2 === arguments.length && "object" == typeof arguments[1]) var e = arguments[1];
                                else var e = arguments.slice(1);
                                for (var i = 1, s = 0, n = e.length; n > i; i++) e[i][t] < e[s][t] && (s = i);
                                return e[s][t]
                            },
                            maxProperty: function(t) {
                                if (2 === arguments.length && "object" == typeof arguments[1]) var e = arguments[1];
                                else var e = arguments.slice(1);
                                for (var i = 1, s = 0, n = e.length; n > i; i++) e[i][t] > e[s][t] && (s = i);
                                return e[s][t]
                            },
                            wrapAngle: function(t, e) {
                                var i = e ? Math.PI / 180 : 1;
                                return this.wrap(t, -180 * i, 180 * i)
                            },
                            angleLimit: function(t, e, i) {
                                var s = t;
                                return t > i ? s = i : e > t && (s = e), s
                            },
                            linearInterpolation: function(t, e) {
                                var i = t.length - 1,
                                    s = i * e,
                                    n = Math.floor(s);
                                return 0 > e ? this.linear(t[0], t[1], s) : e > 1 ? this.linear(t[i], t[i - 1], i - s) : this.linear(t[n], t[n + 1 > i ? i : n + 1], s - n)
                            },
                            bezierInterpolation: function(t, e) {
                                for (var i = 0, s = t.length - 1, n = 0; s >= n; n++) i += Math.pow(1 - e, s - n) * Math.pow(e, n) * t[n] * this.bernstein(s, n);
                                return i
                            },
                            catmullRomInterpolation: function(t, e) {
                                var i = t.length - 1,
                                    s = i * e,
                                    n = Math.floor(s);
                                return t[0] === t[i] ? (0 > e && (n = Math.floor(s = i * (1 + e))), this.catmullRom(t[(n - 1 + i) % i], t[n], t[(n + 1) % i], t[(n + 2) % i], s - n)) : 0 > e ? t[0] - (this.catmullRom(t[0], t[0], t[1], t[1], -s) - t[0]) : e > 1 ? t[i] - (this.catmullRom(t[i], t[i], t[i - 1], t[i - 1], s - i) - t[i]) : this.catmullRom(t[n ? n - 1 : 0], t[n], t[n + 1 > i ? i : n + 1], t[n + 2 > i ? i : n + 2], s - n)
                            },
                            linear: function(t, e, i) {
                                return (e - t) * i + t
                            },
                            bernstein: function(t, e) {
                                return this.factorial(t) / this.factorial(e) / this.factorial(t - e)
                            },
                            factorial: function(t) {
                                if (0 === t) return 1;
                                for (var e = t; --t;) e *= t;
                                return e
                            },
                            catmullRom: function(t, e, i, s, n) {
                                var r = .5 * (i - t),
                                    o = .5 * (s - e),
                                    a = n * n,
                                    h = n * a;
                                return (2 * e - 2 * i + r + o) * h + (-3 * e + 3 * i - 2 * r - o) * a + r * n + e
                            },
                            difference: function(t, e) {
                                return Math.abs(t - e)
                            },
                            getRandom: function(t, e, i) {
                                if ("undefined" == typeof e && (e = 0), "undefined" == typeof i && (i = 0), null != t) {
                                    var s = i;
                                    if ((0 === s || s > t.length - e) && (s = t.length - e), s > 0) return t[e + Math.floor(Math.random() * s)]
                                }
                                return null
                            },
                            removeRandom: function(t, e, i) {
                                if ("undefined" == typeof e && (e = 0), "undefined" == typeof i && (i = 0), null != t) {
                                    var s = i;
                                    if ((0 === s || s > t.length - e) && (s = t.length - e), s > 0) {
                                        var n = e + Math.floor(Math.random() * s),
                                            r = t.splice(n, 1);
                                        return r[0]
                                    }
                                }
                                return null
                            },
                            floor: function(t) {
                                var e = 0 | t;
                                return t > 0 ? e : e != t ? e - 1 : e
                            },
                            ceil: function(t) {
                                var e = 0 | t;
                                return t > 0 && e != t ? e + 1 : e
                            },
                            sinCosGenerator: function(t, e, i, s) {
                                "undefined" == typeof e && (e = 1), "undefined" == typeof i && (i = 1), "undefined" == typeof s && (s = 1);
                                for (var n = e, r = i, o = s * Math.PI / t, a = [], h = [], l = 0; t > l; l++) r -= n * o, n += r * o, a[l] = r, h[l] = n;
                                return {
                                    sin: h,
                                    cos: a,
                                    length: t
                                }
                            },
                            shift: function(t) {
                                var e = t.shift();
                                return t.push(e), e
                            },
                            shuffleArray: function(t) {
                                for (var e = t.length - 1; e > 0; e--) {
                                    var i = Math.floor(Math.random() * (e + 1)),
                                        s = t[e];
                                    t[e] = t[i], t[i] = s
                                }
                                return t
                            },
                            distance: function(t, e, i, s) {
                                var n = t - i,
                                    r = e - s;
                                return Math.sqrt(n * n + r * r)
                            },
                            distancePow: function(t, e, i, s, n) {
                                return "undefined" == typeof n && (n = 2), Math.sqrt(Math.pow(i - t, n) + Math.pow(s - e, n))
                            },
                            distanceRounded: function(t, e, i, s) {
                                return Math.round(n.Math.distance(t, e, i, s))
                            },
                            clamp: function(t, e, i) {
                                return e > t ? e : t > i ? i : t
                            },
                            clampBottom: function(t, e) {
                                return e > t ? e : t
                            },
                            within: function(t, e, i) {
                                return Math.abs(t - e) <= i
                            },
                            mapLinear: function(t, e, i, s, n) {
                                return s + (t - e) * (n - s) / (i - e)
                            },
                            smoothstep: function(t, e, i) {
                                return t = Math.max(0, Math.min(1, (t - e) / (i - e))), t * t * (3 - 2 * t)
                            },
                            smootherstep: function(t, e, i) {
                                return t = Math.max(0, Math.min(1, (t - e) / (i - e))), t * t * t * (t * (6 * t - 15) + 10)
                            },
                            sign: function(t) {
                                return 0 > t ? -1 : t > 0 ? 1 : 0
                            },
                            percent: function(t, e, i) {
                                return "undefined" == typeof i && (i = 0), t > e || i > e ? 1 : i > t || i > t ? 0 : (t - i) / e
                            },
                            degToRad: function() {
                                var t = Math.PI / 180;
                                return function(e) {
                                    return e * t
                                }
                            }(),
                            radToDeg: function() {
                                var t = 180 / Math.PI;
                                return function(e) {
                                    return e * t
                                }
                            }()
                        }, n.RandomDataGenerator = function(t) {
                            "undefined" == typeof t && (t = []), this.c = 1, this.s0 = 0, this.s1 = 0, this.s2 = 0, this.sow(t)
                        }, n.RandomDataGenerator.prototype = {
                            rnd: function() {
                                var t = 2091639 * this.s0 + 2.3283064365386963e-10 * this.c;
                                return this.c = 0 | t, this.s0 = this.s1, this.s1 = this.s2, this.s2 = t - this.c, this.s2
                            },
                            sow: function(t) {
                                "undefined" == typeof t && (t = []), this.s0 = this.hash(" "), this.s1 = this.hash(this.s0), this.s2 = this.hash(this.s1), this.c = 1;
                                for (var e, i = 0; e = t[i++];) this.s0 -= this.hash(e), this.s0 += ~~(this.s0 < 0), this.s1 -= this.hash(e), this.s1 += ~~(this.s1 < 0), this.s2 -= this.hash(e), this.s2 += ~~(this.s2 < 0)
                            },
                            hash: function(t) {
                                var e, i, s;
                                for (s = 4022871197, t = t.toString(), i = 0; i < t.length; i++) s += t.charCodeAt(i), e = .02519603282416938 * s, s = e >>> 0, e -= s, e *= s, s = e >>> 0, e -= s, s += 4294967296 * e;
                                return 2.3283064365386963e-10 * (s >>> 0)
                            },
                            integer: function() {
                                return 4294967296 * this.rnd.apply(this)
                            },
                            frac: function() {
                                return this.rnd.apply(this) + 1.1102230246251565e-16 * (2097152 * this.rnd.apply(this) | 0)
                            },
                            real: function() {
                                return this.integer() + this.frac()
                            },
                            integerInRange: function(t, e) {
                                return Math.floor(this.realInRange(0, e - t + 1) + t)
                            },
                            between: function(t, e) {
                                return this.integerInRange(t, e)
                            },
                            realInRange: function(t, e) {
                                return this.frac() * (e - t) + t
                            },
                            normal: function() {
                                return 1 - 2 * this.frac()
                            },
                            uuid: function() {
                                var t = "",
                                    e = "";
                                for (e = t = ""; t++ < 36; e += ~t % 5 | 3 * t & 4 ? (15 ^ t ? 8 ^ this.frac() * (20 ^ t ? 16 : 4) : 4).toString(16) : "-");
                                return e
                            },
                            pick: function(t) {
                                return t[this.integerInRange(0, t.length - 1)]
                            },
                            weightedPick: function(t) {
                                return t[~~(Math.pow(this.frac(), 2) * (t.length - 1))]
                            },
                            timestamp: function(t, e) {
                                return this.realInRange(t || 9466848e5, e || 1577862e6)
                            },
                            angle: function() {
                                return this.integerInRange(-180, 180)
                            }
                        }, n.RandomDataGenerator.prototype.constructor = n.RandomDataGenerator, n.QuadTree = function(t, e, i, s, n, r, o) {
                            this.maxObjects = 10, this.maxLevels = 4, this.level = 0, this.bounds = {}, this.objects = [], this.nodes = [], this._empty = [], this.reset(t, e, i, s, n, r, o)
                        }, n.QuadTree.prototype = {
                            reset: function(t, e, i, s, n, r, o) {
                                this.maxObjects = n || 10, this.maxLevels = r || 4, this.level = o || 0, this.bounds = {
                                    x: Math.round(t),
                                    y: Math.round(e),
                                    width: i,
                                    height: s,
                                    subWidth: Math.floor(i / 2),
                                    subHeight: Math.floor(s / 2),
                                    right: Math.round(t) + Math.floor(i / 2),
                                    bottom: Math.round(e) + Math.floor(s / 2)
                                }, this.objects.length = 0, this.nodes.length = 0
                            },
                            populate: function(t) {
                                t.forEach(this.populateHandler, this, !0)
                            },
                            populateHandler: function(t) {
                                t.body && t.exists && this.insert(t.body)
                            },
                            split: function() {
                                this.nodes[0] = new n.QuadTree(this.bounds.right, this.bounds.y, this.bounds.subWidth, this.bounds.subHeight, this.maxObjects, this.maxLevels, this.level + 1), this.nodes[1] = new n.QuadTree(this.bounds.x, this.bounds.y, this.bounds.subWidth, this.bounds.subHeight, this.maxObjects, this.maxLevels, this.level + 1), this.nodes[2] = new n.QuadTree(this.bounds.x, this.bounds.bottom, this.bounds.subWidth, this.bounds.subHeight, this.maxObjects, this.maxLevels, this.level + 1), this.nodes[3] = new n.QuadTree(this.bounds.right, this.bounds.bottom, this.bounds.subWidth, this.bounds.subHeight, this.maxObjects, this.maxLevels, this.level + 1)
                            },
                            insert: function(t) {
                                var e, i = 0;
                                if (null != this.nodes[0] && (e = this.getIndex(t), -1 !== e)) return void this.nodes[e].insert(t);
                                if (this.objects.push(t), this.objects.length > this.maxObjects && this.level < this.maxLevels)
                                    for (null == this.nodes[0] && this.split(); i < this.objects.length;) e = this.getIndex(this.objects[i]), -1 !== e ? this.nodes[e].insert(this.objects.splice(i, 1)[0]) : i++
                            },
                            getIndex: function(t) {
                                var e = -1;
                                return t.x < this.bounds.right && t.right < this.bounds.right ? t.y < this.bounds.bottom && t.bottom < this.bounds.bottom ? e = 1 : t.y > this.bounds.bottom && (e = 2) : t.x > this.bounds.right && (t.y < this.bounds.bottom && t.bottom < this.bounds.bottom ? e = 0 : t.y > this.bounds.bottom && (e = 3)), e
                            },
                            retrieve: function(t) {
                                if (t instanceof n.Rectangle) var e = this.objects,
                                    i = this.getIndex(t);
                                else {
                                    if (!t.body) return this._empty;
                                    var e = this.objects,
                                        i = this.getIndex(t.body)
                                }
                                return this.nodes[0] && (-1 !== i ? e = e.concat(this.nodes[i].retrieve(t)) : (e = e.concat(this.nodes[0].retrieve(t)), e = e.concat(this.nodes[1].retrieve(t)), e = e.concat(this.nodes[2].retrieve(t)), e = e.concat(this.nodes[3].retrieve(t)))), e
                            },
                            clear: function() {
                                this.objects.length = 0;
                                for (var t = this.nodes.length; t--;) this.nodes[t].clear(), this.nodes.splice(t, 1);
                                this.nodes.length = 0
                            }
                        }, n.QuadTree.prototype.constructor = n.QuadTree, n.Net = function(t) {
                            this.game = t
                        }, n.Net.prototype = {
                            getHostName: function() {
                                return window.location && window.location.hostname ? window.location.hostname : null
                            },
                            checkDomainName: function(t) {
                                return -1 !== window.location.hostname.indexOf(t)
                            },
                            updateQueryString: function(t, e, i, s) {
                                "undefined" == typeof i && (i = !1), ("undefined" == typeof s || "" === s) && (s = window.location.href);
                                var n = "",
                                    r = new RegExp("([?|&])" + t + "=.*?(&|#|$)(.*)", "gi");
                                if (r.test(s)) n = "undefined" != typeof e && null !== e ? s.replace(r, "$1" + t + "=" + e + "$2$3") : s.replace(r, "$1$3").replace(/(&|\?)$/, "");
                                else if ("undefined" != typeof e && null !== e) {
                                    var o = -1 !== s.indexOf("?") ? "&" : "?",
                                        a = s.split("#");
                                    s = a[0] + o + t + "=" + e, a[1] && (s += "#" + a[1]), n = s
                                } else n = s;
                                return i ? void(window.location.href = n) : n
                            },
                            getQueryString: function(t) {
                                "undefined" == typeof t && (t = "");
                                var e = {},
                                    i = location.search.substring(1).split("&");
                                for (var s in i) {
                                    var n = i[s].split("=");
                                    if (n.length > 1) {
                                        if (t && t == this.decodeURI(n[0])) return this.decodeURI(n[1]);
                                        e[this.decodeURI(n[0])] = this.decodeURI(n[1])
                                    }
                                }
                                return e
                            },
                            decodeURI: function(t) {
                                return decodeURIComponent(t.replace(/\+/g, " "))
                            }
                        }, n.Net.prototype.constructor = n.Net, n.TweenManager = function(t) {
                            this.game = t, this._tweens = [], this._add = [], this.game.onPause.add(this._pauseAll, this), this.game.onResume.add(this._resumeAll, this)
                        }, n.TweenManager.prototype = {
                            getAll: function() {
                                return this._tweens
                            },
                            removeAll: function() {
                                for (var t = 0; t < this._tweens.length; t++) this._tweens[t].pendingDelete = !0;
                                this._add = []
                            },
                            add: function(t) {
                                t._manager = this, this._add.push(t)
                            },
                            create: function(t) {
                                return new n.Tween(t, this.game, this)
                            },
                            remove: function(t) {
                                var e = this._tweens.indexOf(t); - 1 !== e ? this._tweens[e].pendingDelete = !0 : (e = this._add.indexOf(t), -1 !== e && (this._add[e].pendingDelete = !0))
                            },
                            update: function() {
                                var t = this._add.length,
                                    e = this._tweens.length;
                                if (0 === e && 0 === t) return !1;
                                for (var i = 0; e > i;) this._tweens[i].update(this.game.time.now) ? i++ : (this._tweens.splice(i, 1), e--);
                                return t > 0 && (this._tweens = this._tweens.concat(this._add), this._add.length = 0), !0
                            },
                            isTweening: function(t) {
                                return this._tweens.some(function(e) {
                                    return e._object === t
                                })
                            },
                            _pauseAll: function() {
                                for (var t = this._tweens.length - 1; t >= 0; t--) this._tweens[t]._pause()
                            },
                            _resumeAll: function() {
                                for (var t = this._tweens.length - 1; t >= 0; t--) this._tweens[t]._resume()
                            },
                            pauseAll: function() {
                                for (var t = this._tweens.length - 1; t >= 0; t--) this._tweens[t].pause()
                            },
                            resumeAll: function() {
                                for (var t = this._tweens.length - 1; t >= 0; t--) this._tweens[t].resume(!0)
                            }
                        }, n.TweenManager.prototype.constructor = n.TweenManager, n.Tween = function(t, e, i) {
                            this._object = t, this.game = e, this._manager = i, this._valuesStart = {}, this._valuesEnd = {}, this._valuesStartRepeat = {}, this._duration = 1e3, this._repeat = 0, this._yoyo = !1, this._reversed = !1, this._delayTime = 0, this._startTime = null, this._easingFunction = n.Easing.Linear.None, this._interpolationFunction = n.Math.linearInterpolation, this._chainedTweens = [], this._onStartCallbackFired = !1, this._onUpdateCallback = null, this._onUpdateCallbackContext = null, this._paused = !1, this._pausedTime = 0, this._codePaused = !1, this.pendingDelete = !1, this.onStart = new n.Signal, this.onLoop = new n.Signal, this.onComplete = new n.Signal, this.isRunning = !1
                        }, n.Tween.prototype = {
                            to: function(t, e, i, s, n, r, o) {
                                e = e || 1e3, i = i || null, s = s || !1, n = n || 0, r = r || 0, o = o || !1, o && 0 === r && (r = 1);
                                var a;
                                return this._parent ? (a = this._manager.create(this._object), this._lastChild.chain(a), this._lastChild = a) : (a = this, this._parent = this, this._lastChild = this), a._repeat = r, a._duration = e, a._valuesEnd = t, null !== i && (a._easingFunction = i), n > 0 && (a._delayTime = n), a._yoyo = o, s ? this.start() : this
                            },
                            from: function(t, e, i, s, n, r, o) {
                                var a = {};
                                for (var h in t) a[h] = this._object[h], this._object[h] = t[h];
                                return this.to(a, e, i, s, n, r, o)
                            },
                            start: function() {
                                if (null !== this.game && null !== this._object) {
                                    this._manager.add(this), this.isRunning = !0, this._onStartCallbackFired = !1, this._startTime = this.game.time.now + this._delayTime;
                                    for (var t in this._valuesEnd) {
                                        if (Array.isArray(this._valuesEnd[t])) {
                                            if (0 === this._valuesEnd[t].length) continue;
                                            this._valuesEnd[t] = [this._object[t]].concat(this._valuesEnd[t])
                                        }
                                        this._valuesStart[t] = this._object[t], Array.isArray(this._valuesStart[t]) || (this._valuesStart[t] *= 1), this._valuesStartRepeat[t] = this._valuesStart[t] || 0
                                    }
                                    return this
                                }
                            },
                            generateData: function(t, e) {
                                if (null === this.game || null === this._object) return null;
                                this._startTime = 0;
                                for (var i in this._valuesEnd) {
                                    if (Array.isArray(this._valuesEnd[i])) {
                                        if (0 === this._valuesEnd[i].length) continue;
                                        this._valuesEnd[i] = [this._object[i]].concat(this._valuesEnd[i])
                                    }
                                    this._valuesStart[i] = this._object[i], Array.isArray(this._valuesStart[i]) || (this._valuesStart[i] *= 1), this._valuesStartRepeat[i] = this._valuesStart[i] || 0
                                }
                                for (var s = 0, n = Math.floor(t * (this._duration / 1e3)), r = this._duration / n, o = []; n--;) {
                                    var i, a = (s - this._startTime) / this._duration;
                                    a = a > 1 ? 1 : a;
                                    var h = this._easingFunction(a),
                                        l = {};
                                    for (i in this._valuesEnd) {
                                        var c = this._valuesStart[i] || 0,
                                            u = this._valuesEnd[i];
                                        u instanceof Array ? l[i] = this._interpolationFunction(u, h) : ("string" == typeof u && (u = c + parseFloat(u, 10)), "number" == typeof u && (l[i] = c + (u - c) * h))
                                    }
                                    o.push(l), s += r
                                }
                                if (this._yoyo) {
                                    var d = o.slice();
                                    d.reverse(), o = o.concat(d)
                                }
                                return "undefined" != typeof e ? e = e.concat(o) : o
                            },
                            stop: function() {
                                return this.isRunning = !1, this._onUpdateCallback = null, this._manager.remove(this), this
                            },
                            delay: function(t) {
                                return this._delayTime = t, this
                            },
                            repeat: function(t) {
                                return this._repeat = t, this
                            },
                            yoyo: function(t) {
                                return this._yoyo = t, t && 0 === this._repeat && (this._repeat = 1), this
                            },
                            easing: function(t) {
                                return this._easingFunction = t, this
                            },
                            interpolation: function(t) {
                                return this._interpolationFunction = t, this
                            },
                            chain: function() {
                                return this._chainedTweens = arguments, this
                            },
                            loop: function() {
                                return this._lastChild.chain(this), this
                            },
                            onUpdateCallback: function(t, e) {
                                return this._onUpdateCallback = t, this._onUpdateCallbackContext = e, this
                            },
                            pause: function() {
                                this._codePaused = !0, this._paused = !0, this._pausedTime = this.game.time.now
                            },
                            _pause: function() {
                                this._codePaused || (this._paused = !0, this._pausedTime = this.game.time.now)
                            },
                            resume: function() {
                                this._paused && (this._paused = !1, this._codePaused = !1, this._startTime += this.game.time.now - this._pausedTime)
                            },
                            _resume: function() {
                                this._codePaused || (this._startTime += this.game.time.pauseDuration, this._paused = !1)
                            },
                            update: function(t) {
                                if (this.pendingDelete) return !1;
                                if (this._paused || t < this._startTime) return !0;
                                var e;
                                if (t < this._startTime) return !0;
                                this._onStartCallbackFired === !1 && (this.onStart.dispatch(this._object), this._onStartCallbackFired = !0);
                                var i = (t - this._startTime) / this._duration;
                                i = i > 1 ? 1 : i;
                                var s = this._easingFunction(i);
                                for (e in this._valuesEnd) {
                                    var n = this._valuesStart[e] || 0,
                                        r = this._valuesEnd[e];
                                    r instanceof Array ? this._object[e] = this._interpolationFunction(r, s) : ("string" == typeof r && (r = n + parseFloat(r, 10)), "number" == typeof r && (this._object[e] = n + (r - n) * s))
                                }
                                if (null !== this._onUpdateCallback && (this._onUpdateCallback.call(this._onUpdateCallbackContext, this, s), !this.isRunning)) return !1;
                                if (1 == i) {
                                    if (this._repeat > 0) {
                                        isFinite(this._repeat) && this._repeat--;
                                        for (e in this._valuesStartRepeat) {
                                            if ("string" == typeof this._valuesEnd[e] && (this._valuesStartRepeat[e] = this._valuesStartRepeat[e] + parseFloat(this._valuesEnd[e], 10)), this._yoyo) {
                                                var o = this._valuesStartRepeat[e];
                                                this._valuesStartRepeat[e] = this._valuesEnd[e], this._valuesEnd[e] = o
                                            }
                                            this._valuesStart[e] = this._valuesStartRepeat[e]
                                        }
                                        return this._yoyo && (this._reversed = !this._reversed), this._startTime = t + this._delayTime, this.onLoop.dispatch(this._object), !0
                                    }
                                    this.isRunning = !1, this.onComplete.dispatch(this._object);
                                    for (var a = 0, h = this._chainedTweens.length; h > a; a++) this._chainedTweens[a].start(t);
                                    return !1
                                }
                                return !0
                            }
                        }, n.Tween.prototype.constructor = n.Tween, n.Easing = {
                            Linear: {
                                None: function(t) {
                                    return t
                                }
                            },
                            Quadratic: {
                                In: function(t) {
                                    return t * t
                                },
                                Out: function(t) {
                                    return t * (2 - t)
                                },
                                InOut: function(t) {
                                    return (t *= 2) < 1 ? .5 * t * t : -.5 * (--t * (t - 2) - 1)
                                }
                            },
                            Cubic: {
                                In: function(t) {
                                    return t * t * t
                                },
                                Out: function(t) {
                                    return --t * t * t + 1
                                },
                                InOut: function(t) {
                                    return (t *= 2) < 1 ? .5 * t * t * t : .5 * ((t -= 2) * t * t + 2)
                                }
                            },
                            Quartic: {
                                In: function(t) {
                                    return t * t * t * t
                                },
                                Out: function(t) {
                                    return 1 - --t * t * t * t
                                },
                                InOut: function(t) {
                                    return (t *= 2) < 1 ? .5 * t * t * t * t : -.5 * ((t -= 2) * t * t * t - 2)
                                }
                            },
                            Quintic: {
                                In: function(t) {
                                    return t * t * t * t * t
                                },
                                Out: function(t) {
                                    return --t * t * t * t * t + 1
                                },
                                InOut: function(t) {
                                    return (t *= 2) < 1 ? .5 * t * t * t * t * t : .5 * ((t -= 2) * t * t * t * t + 2)
                                }
                            },
                            Sinusoidal: {
                                In: function(t) {
                                    return 1 - Math.cos(t * Math.PI / 2)
                                },
                                Out: function(t) {
                                    return Math.sin(t * Math.PI / 2)
                                },
                                InOut: function(t) {
                                    return .5 * (1 - Math.cos(Math.PI * t))
                                }
                            },
                            Exponential: {
                                In: function(t) {
                                    return 0 === t ? 0 : Math.pow(1024, t - 1)
                                },
                                Out: function(t) {
                                    return 1 === t ? 1 : 1 - Math.pow(2, -10 * t)
                                },
                                InOut: function(t) {
                                    return 0 === t ? 0 : 1 === t ? 1 : (t *= 2) < 1 ? .5 * Math.pow(1024, t - 1) : .5 * (-Math.pow(2, -10 * (t - 1)) + 2)
                                }
                            },
                            Circular: {
                                In: function(t) {
                                    return 1 - Math.sqrt(1 - t * t)
                                },
                                Out: function(t) {
                                    return Math.sqrt(1 - --t * t)
                                },
                                InOut: function(t) {
                                    return (t *= 2) < 1 ? -.5 * (Math.sqrt(1 - t * t) - 1) : .5 * (Math.sqrt(1 - (t -= 2) * t) + 1)
                                }
                            },
                            Elastic: {
                                In: function(t) {
                                    var e, i = .1,
                                        s = .4;
                                    return 0 === t ? 0 : 1 === t ? 1 : (!i || 1 > i ? (i = 1, e = s / 4) : e = s * Math.asin(1 / i) / (2 * Math.PI), -(i * Math.pow(2, 10 * (t -= 1)) * Math.sin(2 * (t - e) * Math.PI / s)))
                                },
                                Out: function(t) {
                                    var e, i = .1,
                                        s = .4;
                                    return 0 === t ? 0 : 1 === t ? 1 : (!i || 1 > i ? (i = 1, e = s / 4) : e = s * Math.asin(1 / i) / (2 * Math.PI), i * Math.pow(2, -10 * t) * Math.sin(2 * (t - e) * Math.PI / s) + 1)
                                },
                                InOut: function(t) {
                                    var e, i = .1,
                                        s = .4;
                                    return 0 === t ? 0 : 1 === t ? 1 : (!i || 1 > i ? (i = 1, e = s / 4) : e = s * Math.asin(1 / i) / (2 * Math.PI), (t *= 2) < 1 ? -.5 * i * Math.pow(2, 10 * (t -= 1)) * Math.sin(2 * (t - e) * Math.PI / s) : i * Math.pow(2, -10 * (t -= 1)) * Math.sin(2 * (t - e) * Math.PI / s) * .5 + 1)
                                }
                            },
                            Back: {
                                In: function(t) {
                                    var e = 1.70158;
                                    return t * t * ((e + 1) * t - e)
                                },
                                Out: function(t) {
                                    var e = 1.70158;
                                    return --t * t * ((e + 1) * t + e) + 1
                                },
                                InOut: function(t) {
                                    var e = 2.5949095;
                                    return (t *= 2) < 1 ? .5 * t * t * ((e + 1) * t - e) : .5 * ((t -= 2) * t * ((e + 1) * t + e) + 2)
                                }
                            },
                            Bounce: {
                                In: function(t) {
                                    return 1 - n.Easing.Bounce.Out(1 - t)
                                },
                                Out: function(t) {
                                    return 1 / 2.75 > t ? 7.5625 * t * t : 2 / 2.75 > t ? 7.5625 * (t -= 1.5 / 2.75) * t + .75 : 2.5 / 2.75 > t ? 7.5625 * (t -= 2.25 / 2.75) * t + .9375 : 7.5625 * (t -= 2.625 / 2.75) * t + .984375
                                },
                                InOut: function(t) {
                                    return .5 > t ? .5 * n.Easing.Bounce.In(2 * t) : .5 * n.Easing.Bounce.Out(2 * t - 1) + .5
                                }
                            }
                        }, n.Time = function(t) {
                            this.game = t, this.time = 0, this.now = 0, this.elapsed = 0, this.pausedTime = 0, this.advancedTiming = !1, this.fps = 0, this.fpsMin = 1e3, this.fpsMax = 0, this.msMin = 1e3, this.msMax = 0, this.physicsElapsed = 0, this.deltaCap = 0, this.timeCap = 1e3, this.frames = 0, this.pauseDuration = 0, this.timeToCall = 0, this.lastTime = 0, this.events = new n.Timer(this.game, !1), this._started = 0, this._timeLastSecond = 0, this._pauseStarted = 0, this._justResumed = !1, this._timers = [], this._len = 0, this._i = 0
                        }, n.Time.prototype = {
                            boot: function() {
                                this._started = Date.now(), this.events.start()
                            },
                            add: function(t) {
                                return this._timers.push(t), t
                            },
                            create: function(t) {
                                "undefined" == typeof t && (t = !0);
                                var e = new n.Timer(this.game, t);
                                return this._timers.push(e), e
                            },
                            removeAll: function() {
                                for (var t = 0; t < this._timers.length; t++) this._timers[t].destroy();
                                this._timers = [], this.events.removeAll()
                            },
                            update: function(t) {
                                if (this.now = t, this.timeToCall = this.game.math.max(0, 16 - (t - this.lastTime)), this.elapsed = this.now - this.time, this.elapsed > this.timeCap && (this.elapsed = 1 / 60), this.physicsElapsed = this.elapsed / 1e3 || 1 / 60, this.deltaCap > 0 && this.physicsElapsed > this.deltaCap && (this.physicsElapsed = this.deltaCap), this.advancedTiming && (this.msMin = this.game.math.min(this.msMin, this.elapsed), this.msMax = this.game.math.max(this.msMax, this.elapsed), this.frames++, this.now > this._timeLastSecond + 1e3 && (this.fps = Math.round(1e3 * this.frames / (this.now - this._timeLastSecond)), this.fpsMin = this.game.math.min(this.fpsMin, this.fps), this.fpsMax = this.game.math.max(this.fpsMax, this.fps), this._timeLastSecond = this.now, this.frames = 0)), this.time = this.now, this.lastTime = t + this.timeToCall, !this.game.paused)
                                    for (this.events.update(this.now), this._i = 0, this._len = this._timers.length; this._i < this._len;) this._timers[this._i].update(this.now) ? this._i++ : (this._timers.splice(this._i, 1), this._len--)
                            },
                            gamePaused: function() {
                                this._pauseStarted = this.now, this.events.pause();
                                for (var t = this._timers.length; t--;) this._timers[t]._pause()
                            },
                            gameResumed: function() {
                                this.time = this.now = Date.now(), this.pauseDuration = this.time - this._pauseStarted, this.events.resume();
                                for (var t = this._timers.length; t--;) this._timers[t]._resume()
                            },
                            totalElapsedSeconds: function() {
                                return .001 * (this.now - this._started)
                            },
                            elapsedSince: function(t) {
                                return this.now - t
                            },
                            elapsedSecondsSince: function(t) {
                                return .001 * (this.now - t)
                            },
                            reset: function() {
                                this._started = this.now, this.removeAll()
                            }
                        }, n.Time.prototype.constructor = n.Time, n.Timer = function(t, e) {
                            "undefined" == typeof e && (e = !0), this.game = t, this.running = !1, this.autoDestroy = e, this.expired = !1, this.elapsed = 0, this.events = [], this.onComplete = new n.Signal, this.nextTick = 0, this.timeCap = 1e3, this.paused = !1, this._codePaused = !1, this._started = 0, this._pauseStarted = 0, this._pauseTotal = 0, this._now = Date.now(), this._len = 0, this._marked = 0, this._i = 0, this._diff = 0, this._newTick = 0
                        }, n.Timer.MINUTE = 6e4, n.Timer.SECOND = 1e3, n.Timer.HALF = 500, n.Timer.QUARTER = 250, n.Timer.prototype = {
                            create: function(t, e, i, s, r, o) {
                                var a = t;
                                a += 0 === this._now ? this.game.time.now : this._now;
                                var h = new n.TimerEvent(this, t, a, i, e, s, r, o);
                                return this.events.push(h), this.order(), this.expired = !1, h
                            },
                            add: function(t, e, i) {
                                return this.create(t, !1, 0, e, i, Array.prototype.splice.call(arguments, 3))
                            },
                            repeat: function(t, e, i, s) {
                                return this.create(t, !1, e, i, s, Array.prototype.splice.call(arguments, 4))
                            },
                            loop: function(t, e, i) {
                                return this.create(t, !0, 0, e, i, Array.prototype.splice.call(arguments, 3))
                            },
                            start: function(t) {
                                if (!this.running) {
                                    this._started = this.game.time.now + (t || 0), this.running = !0;
                                    for (var e = 0; e < this.events.length; e++) this.events[e].tick = this.events[e].delay + this._started
                                }
                            },
                            stop: function(t) {
                                this.running = !1, "undefined" == typeof t && (t = !0), t && (this.events.length = 0)
                            },
                            remove: function(t) {
                                for (var e = 0; e < this.events.length; e++)
                                    if (this.events[e] === t) return this.events[e].pendingDelete = !0, !0;
                                return !1
                            },
                            order: function() {
                                this.events.length > 0 && (this.events.sort(this.sortHandler), this.nextTick = this.events[0].tick)
                            },
                            sortHandler: function(t, e) {
                                return t.tick < e.tick ? -1 : t.tick > e.tick ? 1 : 0
                            },
                            clearPendingEvents: function() {
                                for (this._i = this.events.length; this._i--;) this.events[this._i].pendingDelete && this.events.splice(this._i, 1);
                                this._len = this.events.length, this._i = 0
                            },
                            update: function(t) {
                                if (this.paused) return !0;
                                if (this.elapsed = t - this._now, this._now = t, this.elapsed > this.timeCap && this.adjustEvents(t - this.elapsed), this._marked = 0, this.clearPendingEvents(), this.running && this._now >= this.nextTick && this._len > 0) {
                                    for (; this._i < this._len && this.running && this._now >= this.events[this._i].tick;) this._newTick = this._now + this.events[this._i].delay - (this._now - this.events[this._i].tick), this._newTick < 0 && (this._newTick = this._now + this.events[this._i].delay), this.events[this._i].loop === !0 ? (this.events[this._i].tick = this._newTick, this.events[this._i].callback.apply(this.events[this._i].callbackContext, this.events[this._i].args)) : this.events[this._i].repeatCount > 0 ? (this.events[this._i].repeatCount--, this.events[this._i].tick = this._newTick, this.events[this._i].callback.apply(this.events[this._i].callbackContext, this.events[this._i].args)) : (this._marked++, this.events[this._i].pendingDelete = !0, this.events[this._i].callback.apply(this.events[this._i].callbackContext, this.events[this._i].args)), this._i++;
                                    this.events.length > this._marked ? this.order() : (this.expired = !0, this.onComplete.dispatch(this))
                                }
                                return this.expired && this.autoDestroy ? !1 : !0
                            },
                            pause: function() {
                                this.running && (this._codePaused = !0, this.paused || (this._pauseStarted = this.game.time.now, this.paused = !0))
                            },
                            _pause: function() {
                                !this.paused && this.running && (this._pauseStarted = this.game.time.now, this.paused = !0)
                            },
                            adjustEvents: function(t) {
                                for (var e = 0; e < this.events.length; e++)
                                    if (!this.events[e].pendingDelete) {
                                        var i = this.events[e].tick - t;
                                        0 > i && (i = 0), this.events[e].tick = this._now + i
                                    }
                                var s = this.nextTick - t;
                                this.nextTick = 0 > s ? this._now : this._now + s
                            },
                            resume: function() {
                                if (this.paused) {
                                    var t = this.game.time.now;
                                    this._pauseTotal += t - this._now, this._now = t, this.adjustEvents(this._pauseStarted), this.paused = !1, this._codePaused = !1
                                }
                            },
                            _resume: function() {
                                this._codePaused || this.resume()
                            },
                            removeAll: function() {
                                this.onComplete.removeAll(), this.events.length = 0, this._len = 0, this._i = 0
                            },
                            destroy: function() {
                                this.onComplete.removeAll(), this.running = !1, this.events = [], this._len = 0, this._i = 0
                            }
                        }, Object.defineProperty(n.Timer.prototype, "next", {
                            get: function() {
                                return this.nextTick
                            }
                        }), Object.defineProperty(n.Timer.prototype, "duration", {
                            get: function() {
                                return this.running && this.nextTick > this._now ? this.nextTick - this._now : 0
                            }
                        }), Object.defineProperty(n.Timer.prototype, "length", {
                            get: function() {
                                return this.events.length
                            }
                        }), Object.defineProperty(n.Timer.prototype, "ms", {
                            get: function() {
                                return this.running ? this._now - this._started - this._pauseTotal : 0
                            }
                        }), Object.defineProperty(n.Timer.prototype, "seconds", {
                            get: function() {
                                return this.running ? .001 * this.ms : 0
                            }
                        }), n.Timer.prototype.constructor = n.Timer, n.TimerEvent = function(t, e, i, s, n, r, o, a) {
                            this.timer = t, this.delay = e, this.tick = i, this.repeatCount = s - 1, this.loop = n, this.callback = r, this.callbackContext = o, this.args = a, this.pendingDelete = !1
                        }, n.TimerEvent.prototype.constructor = n.TimerEvent, n.AnimationManager = function(t) {
                            this.sprite = t, this.game = t.game, this.currentFrame = null, this.currentAnim = null, this.updateIfVisible = !0, this.isLoaded = !1, this._frameData = null, this._anims = {}, this._outputFrames = []
                        }, n.AnimationManager.prototype = {
                            loadFrameData: function(t, e) {
                                if (this.isLoaded)
                                    for (var i in this._anims) this._anims[i].updateFrameData(t);
                                return this._frameData = t, "undefined" == typeof e || null === e ? this.frame = 0 : "string" == typeof e ? this.frameName = e : this.frame = e, this.isLoaded = !0, this._frameData ? !0 : !1
                            },
                            add: function(t, e, i, s, r) {
                                return null === this._frameData ? void console.warn("No FrameData available for Phaser.Animation " + t) : (e = e || [], i = i || 60, "undefined" == typeof s && (s = !1), "undefined" == typeof r && (r = e && "number" == typeof e[0] ? !0 : !1), null === this.sprite.events.onAnimationStart && (this.sprite.events.onAnimationStart = new n.Signal, this.sprite.events.onAnimationComplete = new n.Signal, this.sprite.events.onAnimationLoop = new n.Signal), this._outputFrames.length = 0, this._frameData.getFrameIndexes(e, r, this._outputFrames), this._anims[t] = new n.Animation(this.game, this.sprite, t, this._frameData, this._outputFrames, i, s), this.currentAnim = this._anims[t], this.currentFrame = this.currentAnim.currentFrame, this.sprite.__tilePattern && (this.sprite.__tilePattern = !1, this.tilingTexture = !1), this._anims[t])
                            },
                            validateFrames: function(t, e) {
                                "undefined" == typeof e && (e = !0);
                                for (var i = 0; i < t.length; i++)
                                    if (e === !0) {
                                        if (t[i] > this._frameData.total) return !1
                                    } else if (this._frameData.checkFrameName(t[i]) === !1) return !1;
                                return !0
                            },
                            play: function(t, e, i, s) {
                                return this._anims[t] ? this.currentAnim === this._anims[t] ? this.currentAnim.isPlaying === !1 ? (this.currentAnim.paused = !1, this.currentAnim.play(e, i, s)) : this.currentAnim : (this.currentAnim && this.currentAnim.isPlaying && this.currentAnim.stop(), this.currentAnim = this._anims[t], this.currentAnim.paused = !1, this.currentFrame = this.currentAnim.currentFrame, this.currentAnim.play(e, i, s)) : void 0
                            },
                            stop: function(t, e) {
                                "undefined" == typeof e && (e = !1), "string" == typeof t ? this._anims[t] && (this.currentAnim = this._anims[t], this.currentAnim.stop(e)) : this.currentAnim && this.currentAnim.stop(e)
                            },
                            update: function() {
                                return this.updateIfVisible && !this.sprite.visible ? !1 : this.currentAnim && this.currentAnim.update() === !0 ? (this.currentFrame = this.currentAnim.currentFrame, !0) : !1
                            },
                            next: function(t) {
                                this.currentAnim && (this.currentAnim.next(t), this.currentFrame = this.currentAnim.currentFrame)
                            },
                            previous: function(t) {
                                this.currentAnim && (this.currentAnim.previous(t), this.currentFrame = this.currentAnim.currentFrame)
                            },
                            getAnimation: function(t) {
                                return "string" == typeof t && this._anims[t] ? this._anims[t] : null
                            },
                            refreshFrame: function() {
                                this.sprite.setTexture(PIXI.TextureCache[this.currentFrame.uuid]), this.sprite.__tilePattern && (this.__tilePattern = !1, this.tilingTexture = !1)
                            },
                            destroy: function() {
                                var t = null;
                                for (var t in this._anims) this._anims.hasOwnProperty(t) && this._anims[t].destroy();
                                this._anims = {}, this._frameData = null, this._frameIndex = 0, this.currentAnim = null, this.currentFrame = null
                            }
                        }, n.AnimationManager.prototype.constructor = n.AnimationManager, Object.defineProperty(n.AnimationManager.prototype, "frameData", {
                            get: function() {
                                return this._frameData
                            }
                        }), Object.defineProperty(n.AnimationManager.prototype, "frameTotal", {
                            get: function() {
                                return this._frameData ? this._frameData.total : -1
                            }
                        }), Object.defineProperty(n.AnimationManager.prototype, "paused", {
                            get: function() {
                                return this.currentAnim.isPaused
                            },
                            set: function(t) {
                                this.currentAnim.paused = t
                            }
                        }), Object.defineProperty(n.AnimationManager.prototype, "frame", {
                            get: function() {
                                return this.currentFrame ? this._frameIndex : void 0
                            },
                            set: function(t) {
                                "number" == typeof t && this._frameData && null !== this._frameData.getFrame(t) && (this.currentFrame = this._frameData.getFrame(t), this.currentFrame && (this._frameIndex = t, this.sprite.setFrame(this.currentFrame), this.sprite.__tilePattern && (this.__tilePattern = !1, this.tilingTexture = !1)))
                            }
                        }), Object.defineProperty(n.AnimationManager.prototype, "frameName", {
                            get: function() {
                                return this.currentFrame ? this.currentFrame.name : void 0
                            },
                            set: function(t) {
                                "string" == typeof t && this._frameData && null !== this._frameData.getFrameByName(t) ? (this.currentFrame = this._frameData.getFrameByName(t), this.currentFrame && (this._frameIndex = this.currentFrame.index, this.sprite.setFrame(this.currentFrame), this.sprite.__tilePattern && (this.__tilePattern = !1, this.tilingTexture = !1))) : console.warn("Cannot set frameName: " + t)
                            }
                        }), n.Animation = function(t, e, i, s, r, o, a) {
                            this.game = t, this._parent = e, this._frameData = s, this.name = i, this._frames = [], this._frames = this._frames.concat(r), this.delay = 1e3 / o, this.loop = a, this.loopCount = 0, this.killOnComplete = !1, this.isFinished = !1, this.isPlaying = !1, this.isPaused = !1, this._pauseStartTime = 0, this._frameIndex = 0, this._frameDiff = 0, this._frameSkip = 1, this.currentFrame = this._frameData.getFrame(this._frames[this._frameIndex]), this.onStart = new n.Signal, this.onComplete = new n.Signal, this.onLoop = new n.Signal, this.game.onPause.add(this.onPause, this), this.game.onResume.add(this.onResume, this)
                        }, n.Animation.prototype = {
                            play: function(t, e, i) {
                                return "number" == typeof t && (this.delay = 1e3 / t), "boolean" == typeof e && (this.loop = e), "undefined" != typeof i && (this.killOnComplete = i), this.isPlaying = !0, this.isFinished = !1, this.paused = !1, this.loopCount = 0, this._timeLastFrame = this.game.time.now, this._timeNextFrame = this.game.time.now + this.delay, this._frameIndex = 0, this.currentFrame = this._frameData.getFrame(this._frames[this._frameIndex]), this._parent.setFrame(this.currentFrame), this._parent.__tilePattern && (this._parent.__tilePattern = !1, this._parent.tilingTexture = !1), this._parent.events.onAnimationStart.dispatch(this._parent, this), this.onStart.dispatch(this._parent, this), this
                            },
                            restart: function() {
                                this.isPlaying = !0, this.isFinished = !1, this.paused = !1, this.loopCount = 0, this._timeLastFrame = this.game.time.now, this._timeNextFrame = this.game.time.now + this.delay, this._frameIndex = 0, this.currentFrame = this._frameData.getFrame(this._frames[this._frameIndex]), this._parent.setFrame(this.currentFrame), this.onStart.dispatch(this._parent, this)
                            },
                            setFrame: function(t, e) {
                                var i;
                                if ("undefined" == typeof e && (e = !1), "string" == typeof t)
                                    for (var s = 0; s < this._frames.length; s++) this._frameData.getFrame(this._frames[s]).name === t && (i = s);
                                else if ("number" == typeof t)
                                    if (e) i = t;
                                    else
                                        for (var s = 0; s < this._frames.length; s++) this.frames[s] === i && (i = s);
                                i && (this._frameIndex = i - 1, this._timeNextFrame = this.game.time.now, this.update())
                            },
                            stop: function(t, e) {
                                "undefined" == typeof t && (t = !1), "undefined" == typeof e && (e = !1), this.isPlaying = !1, this.isFinished = !0, this.paused = !1, t && (this.currentFrame = this._frameData.getFrame(this._frames[0]), this._parent.setFrame(this.currentFrame)), e && (this._parent.events.onAnimationComplete.dispatch(this._parent, this), this.onComplete.dispatch(this._parent, this))
                            },
                            onPause: function() {
                                this.isPlaying && (this._frameDiff = this._timeNextFrame - this.game.time.now)
                            },
                            onResume: function() {
                                this.isPlaying && (this._timeNextFrame = this.game.time.now + this._frameDiff)
                            },
                            update: function() {
                                return this.isPaused ? !1 : this.isPlaying && this.game.time.now >= this._timeNextFrame ? (this._frameSkip = 1, this._frameDiff = this.game.time.now - this._timeNextFrame, this._timeLastFrame = this.game.time.now, this._frameDiff > this.delay && (this._frameSkip = Math.floor(this._frameDiff / this.delay), this._frameDiff -= this._frameSkip * this.delay), this._timeNextFrame = this.game.time.now + (this.delay - this._frameDiff), this._frameIndex += this._frameSkip, this._frameIndex >= this._frames.length && (this.loop ? (this._frameIndex %= this._frames.length, this.currentFrame = this._frameData.getFrame(this._frames[this._frameIndex]), this.loopCount++, this._parent.events.onAnimationLoop.dispatch(this._parent, this), this.onLoop.dispatch(this._parent, this)) : this.complete()), this.currentFrame = this._frameData.getFrame(this._frames[this._frameIndex]), this.currentFrame && (this._parent.setFrame(this.currentFrame), this._parent.__tilePattern && (this._parent.__tilePattern = !1, this._parent.tilingTexture = !1)), !0) : !1
                            },
                            next: function(t) {
                                "undefined" == typeof t && (t = 1);
                                var e = this._frameIndex + t;
                                e >= this._frames.length && (this.loop ? e %= this._frames.length : e = this._frames.length - 1), e !== this._frameIndex && (this._frameIndex = e, this.currentFrame = this._frameData.getFrame(this._frames[this._frameIndex]), this.currentFrame && (this._parent.setFrame(this.currentFrame), this._parent.__tilePattern && (this._parent.__tilePattern = !1, this._parent.tilingTexture = !1)))
                            },
                            previous: function(t) {
                                "undefined" == typeof t && (t = 1);
                                var e = this._frameIndex - t;
                                0 > e && (this.loop ? e = this._frames.length + e : e++), e !== this._frameIndex && (this._frameIndex = e, this.currentFrame = this._frameData.getFrame(this._frames[this._frameIndex]), this.currentFrame && (this._parent.setFrame(this.currentFrame), this._parent.__tilePattern && (this._parent.__tilePattern = !1, this._parent.tilingTexture = !1)))
                            },
                            updateFrameData: function(t) {
                                this._frameData = t, this.currentFrame = this._frameData ? this._frameData.getFrame(this._frames[this._frameIndex % this._frames.length]) : null
                            },
                            destroy: function() {
                                this.game.onPause.remove(this.onPause, this), this.game.onResume.remove(this.onResume, this), this.game = null, this._parent = null, this._frames = null, this._frameData = null, this.currentFrame = null, this.isPlaying = !1, this.onStart.dispose(), this.onLoop.dispose(), this.onComplete.dispose()
                            },
                            complete: function() {
                                this.isPlaying = !1, this.isFinished = !0, this.paused = !1, this._parent.events.onAnimationComplete.dispatch(this._parent, this), this.onComplete.dispatch(this._parent, this), this.killOnComplete && this._parent.kill()
                            }
                        }, n.Animation.prototype.constructor = n.Animation, Object.defineProperty(n.Animation.prototype, "paused", {
                            get: function() {
                                return this.isPaused
                            },
                            set: function(t) {
                                this.isPaused = t, t ? this._pauseStartTime = this.game.time.now : this.isPlaying && (this._timeNextFrame = this.game.time.now + this.delay)
                            }
                        }), Object.defineProperty(n.Animation.prototype, "frameTotal", {
                            get: function() {
                                return this._frames.length
                            }
                        }), Object.defineProperty(n.Animation.prototype, "frame", {
                            get: function() {
                                return null !== this.currentFrame ? this.currentFrame.index : this._frameIndex
                            },
                            set: function(t) {
                                this.currentFrame = this._frameData.getFrame(this._frames[t]), null !== this.currentFrame && (this._frameIndex = t, this._parent.setFrame(this.currentFrame))
                            }
                        }), Object.defineProperty(n.Animation.prototype, "speed", {
                            get: function() {
                                return Math.round(1e3 / this.delay)
                            },
                            set: function(t) {
                                t >= 1 && (this.delay = 1e3 / t)
                            }
                        }), n.Animation.generateFrameNames = function(t, e, i, s, r) {
                            "undefined" == typeof s && (s = "");
                            var o = [],
                                a = "";
                            if (i > e)
                                for (var h = e; i >= h; h++) a = "number" == typeof r ? n.Utils.pad(h.toString(), r, "0", 1) : h.toString(), a = t + a + s, o.push(a);
                            else
                                for (var h = e; h >= i; h--) a = "number" == typeof r ? n.Utils.pad(h.toString(), r, "0", 1) : h.toString(), a = t + a + s, o.push(a);
                            return o
                        }, n.Frame = function(t, e, i, s, r, o, a) {
                            this.index = t, this.x = e, this.y = i, this.width = s, this.height = r, this.name = o, this.uuid = a, this.centerX = Math.floor(s / 2), this.centerY = Math.floor(r / 2), this.distance = n.Math.distance(0, 0, s, r), this.rotated = !1, this.rotationDirection = "cw", this.trimmed = !1, this.sourceSizeW = s, this.sourceSizeH = r, this.spriteSourceSizeX = 0, this.spriteSourceSizeY = 0, this.spriteSourceSizeW = 0, this.spriteSourceSizeH = 0, this.right = this.x + this.width, this.bottom = this.y + this.height
                        }, n.Frame.prototype = {
                            setTrim: function(t, e, i, s, n, r, o) {
                                this.trimmed = t, t && (this.sourceSizeW = e, this.sourceSizeH = i, this.centerX = Math.floor(e / 2), this.centerY = Math.floor(i / 2), this.spriteSourceSizeX = s, this.spriteSourceSizeY = n, this.spriteSourceSizeW = r, this.spriteSourceSizeH = o)
                            },
                            getRect: function(t) {
                                return "undefined" == typeof t ? t = new n.Rectangle(this.x, this.y, this.width, this.height) : t.setTo(this.x, this.y, this.width, this.height), t
                            }
                        }, n.Frame.prototype.constructor = n.Frame, n.FrameData = function() {
                            this._frames = [], this._frameNames = []
                        }, n.FrameData.prototype = {
                            addFrame: function(t) {
                                return t.index = this._frames.length, this._frames.push(t), "" !== t.name && (this._frameNames[t.name] = t.index), t
                            },
                            getFrame: function(t) {
                                return t > this._frames.length && (t = 0), this._frames[t]
                            },
                            getFrameByName: function(t) {
                                return "number" == typeof this._frameNames[t] ? this._frames[this._frameNames[t]] : null
                            },
                            checkFrameName: function(t) {
                                return null == this._frameNames[t] ? !1 : !0
                            },
                            getFrameRange: function(t, e, i) {
                                "undefined" == typeof i && (i = []);
                                for (var s = t; e >= s; s++) i.push(this._frames[s]);
                                return i
                            },
                            getFrames: function(t, e, i) {
                                if ("undefined" == typeof e && (e = !0), "undefined" == typeof i && (i = []), "undefined" == typeof t || 0 === t.length)
                                    for (var s = 0; s < this._frames.length; s++) i.push(this._frames[s]);
                                else
                                    for (var s = 0, n = t.length; n > s; s++) i.push(e ? this.getFrame(t[s]) : this.getFrameByName(t[s]));
                                return i
                            },
                            getFrameIndexes: function(t, e, i) {
                                if ("undefined" == typeof e && (e = !0), "undefined" == typeof i && (i = []), "undefined" == typeof t || 0 === t.length)
                                    for (var s = 0, n = this._frames.length; n > s; s++) i.push(this._frames[s].index);
                                else
                                    for (var s = 0, n = t.length; n > s; s++) e ? i.push(t[s]) : this.getFrameByName(t[s]) && i.push(this.getFrameByName(t[s]).index);
                                return i
                            }
                        }, n.FrameData.prototype.constructor = n.FrameData, Object.defineProperty(n.FrameData.prototype, "total", {
                            get: function() {
                                return this._frames.length
                            }
                        }), n.AnimationParser = {
                            spriteSheet: function(t, e, i, s, r, o, a) {
                                var h = t.cache.getImage(e);
                                if (null == h) return null;
                                var l = h.width,
                                    c = h.height;
                                0 >= i && (i = Math.floor(-l / Math.min(-1, i))), 0 >= s && (s = Math.floor(-c / Math.min(-1, s)));
                                var u = Math.floor((l - o) / (i + a)),
                                    d = Math.floor((c - o) / (s + a)),
                                    p = u * d;
                                if (-1 !== r && (p = r), 0 === l || 0 === c || i > l || s > c || 0 === p) return console.warn("Phaser.AnimationParser.spriteSheet: '" + e + "'s width/height zero or width/height < given frameWidth/frameHeight"), null;
                                for (var f = new n.FrameData, g = o, m = o, y = 0; p > y; y++) {
                                    var v = t.rnd.uuid();
                                    f.addFrame(new n.Frame(y, g, m, i, s, "", v)), PIXI.TextureCache[v] = new PIXI.Texture(PIXI.BaseTextureCache[e], {
                                        x: g,
                                        y: m,
                                        width: i,
                                        height: s
                                    }), g += i + a, g + i > l && (g = o, m += s + a)
                                }
                                return f
                            },
                            JSONData: function(t, e, i) {
                                if (!e.frames) return console.warn("Phaser.AnimationParser.JSONData: Invalid Texture Atlas JSON given, missing 'frames' array"), void console.log(e);
                                for (var s, r = new n.FrameData, o = e.frames, a = 0; a < o.length; a++) {
                                    var h = t.rnd.uuid();
                                    s = r.addFrame(new n.Frame(a, o[a].frame.x, o[a].frame.y, o[a].frame.w, o[a].frame.h, o[a].filename, h)), PIXI.TextureCache[h] = new PIXI.Texture(PIXI.BaseTextureCache[i], {
                                        x: o[a].frame.x,
                                        y: o[a].frame.y,
                                        width: o[a].frame.w,
                                        height: o[a].frame.h
                                    }), o[a].trimmed && s.setTrim(o[a].trimmed, o[a].sourceSize.w, o[a].sourceSize.h, o[a].spriteSourceSize.x, o[a].spriteSourceSize.y, o[a].spriteSourceSize.w, o[a].spriteSourceSize.h)
                                }
                                return r
                            },
                            JSONDataHash: function(t, e, i) {
                                if (!e.frames) return console.warn("Phaser.AnimationParser.JSONDataHash: Invalid Texture Atlas JSON given, missing 'frames' object"), void console.log(e);
                                var s, r = new n.FrameData,
                                    o = e.frames,
                                    a = 0;
                                for (var h in o) {
                                    var l = t.rnd.uuid();
                                    s = r.addFrame(new n.Frame(a, o[h].frame.x, o[h].frame.y, o[h].frame.w, o[h].frame.h, h, l)), PIXI.TextureCache[l] = new PIXI.Texture(PIXI.BaseTextureCache[i], {
                                        x: o[h].frame.x,
                                        y: o[h].frame.y,
                                        width: o[h].frame.w,
                                        height: o[h].frame.h
                                    }), o[h].trimmed && s.setTrim(o[h].trimmed, o[h].sourceSize.w, o[h].sourceSize.h, o[h].spriteSourceSize.x, o[h].spriteSourceSize.y, o[h].spriteSourceSize.w, o[h].spriteSourceSize.h), a++
                                }
                                return r
                            },
                            XMLData: function(t, e, i) {
                                if (!e.getElementsByTagName("TextureAtlas")) return void console.warn("Phaser.AnimationParser.XMLData: Invalid Texture Atlas XML given, missing <TextureAtlas> tag");
                                for (var s, r, o, a, h, l, c, u, d, p, f, g, m = new n.FrameData, y = e.getElementsByTagName("SubTexture"), v = 0; v < y.length; v++) r = t.rnd.uuid(), a = y[v].attributes, o = a.name.nodeValue, h = parseInt(a.x.nodeValue, 10), l = parseInt(a.y.nodeValue, 10), c = parseInt(a.width.nodeValue, 10), u = parseInt(a.height.nodeValue, 10), d = null, p = null, a.frameX && (d = Math.abs(parseInt(a.frameX.nodeValue, 10)), p = Math.abs(parseInt(a.frameY.nodeValue, 10)), f = parseInt(a.frameWidth.nodeValue, 10), g = parseInt(a.frameHeight.nodeValue, 10)), s = m.addFrame(new n.Frame(v, h, l, c, u, o, r)), PIXI.TextureCache[r] = new PIXI.Texture(PIXI.BaseTextureCache[i], {
                                    x: h,
                                    y: l,
                                    width: c,
                                    height: u
                                }), (null !== d || null !== p) && s.setTrim(!0, c, u, d, p, f, g);
                                return m
                            }
                        }, n.Cache = function(t) {
                            this.game = t, this._canvases = {}, this._images = {}, this._textures = {}, this._sounds = {}, this._text = {}, this._json = {}, this._physics = {}, this._tilemaps = {}, this._binary = {}, this._bitmapDatas = {}, this._bitmapFont = {}, this.addDefaultImage(), this.addMissingImage(), this.onSoundUnlock = new n.Signal, this._cacheMap = [], this._cacheMap[n.Cache.CANVAS] = this._canvases, this._cacheMap[n.Cache.IMAGE] = this._images, this._cacheMap[n.Cache.TEXTURE] = this._textures, this._cacheMap[n.Cache.SOUND] = this._sounds, this._cacheMap[n.Cache.TEXT] = this._text, this._cacheMap[n.Cache.PHYSICS] = this._physics, this._cacheMap[n.Cache.TILEMAP] = this._tilemaps, this._cacheMap[n.Cache.BINARY] = this._binary, this._cacheMap[n.Cache.BITMAPDATA] = this._bitmapDatas, this._cacheMap[n.Cache.BITMAPFONT] = this._bitmapFont, this._cacheMap[n.Cache.JSON] = this._json
                        }, n.Cache.CANVAS = 1, n.Cache.IMAGE = 2, n.Cache.TEXTURE = 3, n.Cache.SOUND = 4, n.Cache.TEXT = 5, n.Cache.PHYSICS = 6, n.Cache.TILEMAP = 7, n.Cache.BINARY = 8, n.Cache.BITMAPDATA = 9, n.Cache.BITMAPFONT = 10, n.Cache.JSON = 11, n.Cache.prototype = {
                            addCanvas: function(t, e, i) {
                                this._canvases[t] = {
                                    canvas: e,
                                    context: i
                                }
                            },
                            addBinary: function(t, e) {
                                this._binary[t] = e
                            },
                            addBitmapData: function(t, e) {
                                return this._bitmapDatas[t] = e, e
                            },
                            addRenderTexture: function(t, e) {
                                var i = new n.Frame(0, 0, 0, e.width, e.height, "", "");
                                this._textures[t] = {
                                    texture: e,
                                    frame: i
                                }
                            },
                            addSpriteSheet: function(t, e, i, s, r, o, a, h) {
                                this._images[t] = {
                                    url: e,
                                    data: i,
                                    spriteSheet: !0,
                                    frameWidth: s,
                                    frameHeight: r,
                                    margin: a,
                                    spacing: h
                                }, PIXI.BaseTextureCache[t] = new PIXI.BaseTexture(i), PIXI.TextureCache[t] = new PIXI.Texture(PIXI.BaseTextureCache[t]), this._images[t].frameData = n.AnimationParser.spriteSheet(this.game, t, s, r, o, a, h)
                            },
                            addTilemap: function(t, e, i, s) {
                                this._tilemaps[t] = {
                                    url: e,
                                    data: i,
                                    format: s
                                }
                            },
                            addTextureAtlas: function(t, e, i, s, r) {
                                this._images[t] = {
                                    url: e,
                                    data: i,
                                    spriteSheet: !0
                                }, PIXI.BaseTextureCache[t] = new PIXI.BaseTexture(i), PIXI.TextureCache[t] = new PIXI.Texture(PIXI.BaseTextureCache[t]), r == n.Loader.TEXTURE_ATLAS_JSON_ARRAY ? this._images[t].frameData = n.AnimationParser.JSONData(this.game, s, t) : r == n.Loader.TEXTURE_ATLAS_JSON_HASH ? this._images[t].frameData = n.AnimationParser.JSONDataHash(this.game, s, t) : r == n.Loader.TEXTURE_ATLAS_XML_STARLING && (this._images[t].frameData = n.AnimationParser.XMLData(this.game, s, t))
                            },
                            addBitmapFont: function(t, e, i, s, r, o) {
                                this._images[t] = {
                                    url: e,
                                    data: i,
                                    spriteSheet: !0
                                }, PIXI.BaseTextureCache[t] = new PIXI.BaseTexture(i), PIXI.TextureCache[t] = new PIXI.Texture(PIXI.BaseTextureCache[t]), n.LoaderParser.bitmapFont(this.game, s, t, r, o)
                            },
                            addPhysicsData: function(t, e, i, s) {
                                this._physics[t] = {
                                    url: e,
                                    data: i,
                                    format: s
                                }
                            },
                            addDefaultImage: function() {
                                var t = new Image;
                                t.src = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAgAQMAAABJtOi3AAAAA1BMVEX///+nxBvIAAAAAXRSTlMAQObYZgAAABVJREFUeF7NwIEAAAAAgKD9qdeocAMAoAABm3DkcAAAAABJRU5ErkJggg==", this._images.__default = {
                                    url: null,
                                    data: t,
                                    spriteSheet: !1
                                }, this._images.__default.frame = new n.Frame(0, 0, 0, 32, 32, "", ""), PIXI.BaseTextureCache.__default = new PIXI.BaseTexture(t), PIXI.TextureCache.__default = new PIXI.Texture(PIXI.BaseTextureCache.__default)
                            },
                            addMissingImage: function() {
                                var t = new Image;
                                t.src = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAIAAAD8GO2jAAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAAJ9JREFUeNq01ssOwyAMRFG46v//Mt1ESmgh+DFmE2GPOBARKb2NVjo+17PXLD8a1+pl5+A+wSgFygymWYHBb0FtsKhJDdZlncG2IzJ4ayoMDv20wTmSMzClEgbWYNTAkQ0Z+OJ+A/eWnAaR9+oxCF4Os0H8htsMUp+pwcgBBiMNnAwF8GqIgL2hAzaGFFgZauDPKABmowZ4GL369/0rwACp2yA/ttmvsQAAAABJRU5ErkJggg==", this._images.__missing = {
                                    url: null,
                                    data: t,
                                    spriteSheet: !1
                                }, this._images.__missing.frame = new n.Frame(0, 0, 0, 32, 32, "", ""), PIXI.BaseTextureCache.__missing = new PIXI.BaseTexture(t), PIXI.TextureCache.__missing = new PIXI.Texture(PIXI.BaseTextureCache.__missing)
                            },
                            addText: function(t, e, i) {
                                this._text[t] = {
                                    url: e,
                                    data: i
                                }
                            },
                            addJSON: function(t, e, i) {
                                this._json[t] = {
                                    url: e,
                                    data: i
                                }
                            },
                            addImage: function(t, e, i) {
                                this._images[t] = {
                                    url: e,
                                    data: i,
                                    spriteSheet: !1
                                }, this._images[t].frame = new n.Frame(0, 0, 0, i.width, i.height, t, this.game.rnd.uuid()), PIXI.BaseTextureCache[t] = new PIXI.BaseTexture(i), PIXI.TextureCache[t] = new PIXI.Texture(PIXI.BaseTextureCache[t])
                            },
                            addSound: function(t, e, i, s, n) {
                                s = s || !0, n = n || !1;
                                var r = !1;
                                n && (r = !0), this._sounds[t] = {
                                    url: e,
                                    data: i,
                                    isDecoding: !1,
                                    decoded: r,
                                    webAudio: s,
                                    audioTag: n,
                                    locked: this.game.sound.touchLocked
                                }
                            },
                            reloadSound: function(t) {
                                var e = this;
                                this._sounds[t] && (this._sounds[t].data.src = this._sounds[t].url, this._sounds[t].data.addEventListener("canplaythrough", function() {
                                    return e.reloadSoundComplete(t)
                                }, !1), this._sounds[t].data.load())
                            },
                            reloadSoundComplete: function(t) {
                                this._sounds[t] && (this._sounds[t].locked = !1, this.onSoundUnlock.dispatch(t))
                            },
                            updateSound: function(t, e, i) {
                                this._sounds[t] && (this._sounds[t][e] = i)
                            },
                            decodedSound: function(t, e) {
                                this._sounds[t].data = e, this._sounds[t].decoded = !0, this._sounds[t].isDecoding = !1
                            },
                            getCanvas: function(t) {
                                return this._canvases[t] ? this._canvases[t].canvas : void console.warn('Phaser.Cache.getCanvas: Invalid key: "' + t + '"')
                            },
                            getBitmapData: function(t) {
                                return this._bitmapDatas[t] ? this._bitmapDatas[t] : void console.warn('Phaser.Cache.getBitmapData: Invalid key: "' + t + '"')
                            },
                            getBitmapFont: function(t) {
                                return this._bitmapFont[t] ? this._bitmapFont[t] : void console.warn('Phaser.Cache.getBitmapFont: Invalid key: "' + t + '"')
                            },
                            getPhysicsData: function(t, e, i) {
                                if ("undefined" == typeof e || null === e) {
                                    if (this._physics[t]) return this._physics[t].data;
                                    console.warn('Phaser.Cache.getPhysicsData: Invalid key: "' + t + '"')
                                } else if (this._physics[t] && this._physics[t].data[e]) {
                                    var s = this._physics[t].data[e];
                                    if (!s || !i) return s;
                                    for (var n in s)
                                        if (n = s[n], n.fixtureKey === i) return n;
                                    console.warn('Phaser.Cache.getPhysicsData: Could not find given fixtureKey: "' + i + " in " + t + '"')
                                } else console.warn('Phaser.Cache.getPhysicsData: Invalid key/object: "' + t + " / " + e + '"');
                                return null
                            },
                            checkKey: function(t, e) {
                                return this._cacheMap[t][e] ? !0 : !1
                            },
                            checkCanvasKey: function(t) {
                                return this.checkKey(n.Cache.CANVAS, t)
                            },
                            checkImageKey: function(t) {
                                return this.checkKey(n.Cache.IMAGE, t)
                            },
                            checkTextureKey: function(t) {
                                return this.checkKey(n.Cache.TEXTURE, t)
                            },
                            checkSoundKey: function(t) {
                                return this.checkKey(n.Cache.SOUND, t)
                            },
                            checkTextKey: function(t) {
                                return this.checkKey(n.Cache.TEXT, t)
                            },
                            checkPhysicsKey: function(t) {
                                return this.checkKey(n.Cache.PHYSICS, t)
                            },
                            checkTilemapKey: function(t) {
                                return this.checkKey(n.Cache.TILEMAP, t)
                            },
                            checkBinaryKey: function(t) {
                                return this.checkKey(n.Cache.BINARY, t)
                            },
                            checkBitmapDataKey: function(t) {
                                return this.checkKey(n.Cache.BITMAPDATA, t)
                            },
                            checkBitmapFontKey: function(t) {
                                return this.checkKey(n.Cache.BITMAPFONT, t)
                            },
                            checkJSONKey: function(t) {
                                return this.checkKey(n.Cache.JSON, t)
                            },
                            getImage: function(t) {
                                return this._images[t] ? this._images[t].data : void console.warn('Phaser.Cache.getImage: Invalid key: "' + t + '"')
                            },
                            getTilemapData: function(t) {
                                return this._tilemaps[t] ? this._tilemaps[t] : void console.warn('Phaser.Cache.getTilemapData: Invalid key: "' + t + '"')
                            },
                            getFrameData: function(t) {
                                return this._images[t] && this._images[t].frameData ? this._images[t].frameData : null
                            },
                            updateFrameData: function(t, e) {
                                this._images[t] && (this._images[t].spriteSheet = !0, this._images[t].frameData = e)
                            },
                            getFrameByIndex: function(t, e) {
                                return this._images[t] && this._images[t].frameData ? this._images[t].frameData.getFrame(e) : null
                            },
                            getFrameByName: function(t, e) {
                                return this._images[t] && this._images[t].frameData ? this._images[t].frameData.getFrameByName(e) : null
                            },
                            getFrame: function(t) {
                                return this._images[t] && this._images[t].spriteSheet === !1 ? this._images[t].frame : null
                            },
                            getTextureFrame: function(t) {
                                return this._textures[t] ? this._textures[t].frame : null
                            },
                            getTexture: function(t) {
                                return this._textures[t] ? this._textures[t] : void console.warn('Phaser.Cache.getTexture: Invalid key: "' + t + '"')
                            },
                            getSound: function(t) {
                                return this._sounds[t] ? this._sounds[t] : void console.warn('Phaser.Cache.getSound: Invalid key: "' + t + '"')
                            },
                            getSoundData: function(t) {
                                return this._sounds[t] ? this._sounds[t].data : void console.warn('Phaser.Cache.getSoundData: Invalid key: "' + t + '"')
                            },
                            isSoundDecoded: function(t) {
                                return this._sounds[t] ? this._sounds[t].decoded : void 0
                            },
                            isSoundReady: function(t) {
                                return this._sounds[t] && this._sounds[t].decoded && this.game.sound.touchLocked === !1
                            },
                            isSpriteSheet: function(t) {
                                return this._images[t] ? this._images[t].spriteSheet : !1
                            },
                            getText: function(t) {
                                return this._text[t] ? this._text[t].data : void console.warn('Phaser.Cache.getText: Invalid key: "' + t + '"')
                            },
                            getJSON: function(t) {
                                return this._json[t] ? this._json[t].data : void console.warn('Phaser.Cache.getJSON: Invalid key: "' + t + '"')
                            },
                            getBinary: function(t) {
                                return this._binary[t] ? this._binary[t] : void console.warn('Phaser.Cache.getBinary: Invalid key: "' + t + '"')
                            },
                            getKeys: function(t) {
                                var e = null;
                                switch (t) {
                                    case n.Cache.CANVAS:
                                        e = this._canvases;
                                        break;
                                    case n.Cache.IMAGE:
                                        e = this._images;
                                        break;
                                    case n.Cache.TEXTURE:
                                        e = this._textures;
                                        break;
                                    case n.Cache.SOUND:
                                        e = this._sounds;
                                        break;
                                    case n.Cache.TEXT:
                                        e = this._text;
                                        break;
                                    case n.Cache.PHYSICS:
                                        e = this._physics;
                                        break;
                                    case n.Cache.TILEMAP:
                                        e = this._tilemaps;
                                        break;
                                    case n.Cache.BINARY:
                                        e = this._binary;
                                        break;
                                    case n.Cache.BITMAPDATA:
                                        e = this._bitmapDatas;
                                        break;
                                    case n.Cache.BITMAPFONT:
                                        e = this._bitmapFont;
                                        break;
                                    case n.Cache.JSON:
                                        e = this._json
                                }
                                if (e) {
                                    var i = [];
                                    for (var s in e) "__default" !== s && "__missing" !== s && i.push(s);
                                    return i
                                }
                            },
                            removeCanvas: function(t) {
                                delete this._canvases[t]
                            },
                            removeImage: function(t) {
                                delete this._images[t]
                            },
                            removeSound: function(t) {
                                delete this._sounds[t]
                            },
                            removeText: function(t) {
                                delete this._text[t]
                            },
                            removeJSON: function(t) {
                                delete this._json[t]
                            },
                            removePhysics: function(t) {
                                delete this._physics[t]
                            },
                            removeTilemap: function(t) {
                                delete this._tilemaps[t]
                            },
                            removeBinary: function(t) {
                                delete this._binary[t]
                            },
                            removeBitmapData: function(t) {
                                delete this._bitmapDatas[t]
                            },
                            removeBitmapFont: function(t) {
                                delete this._bitmapFont[t]
                            },
                            destroy: function() {
                                for (var t in this._canvases) delete this._canvases[t];
                                for (var t in this._images) "__default" !== t && "__missing" !== t && delete this._images[t];
                                for (var t in this._sounds) delete this._sounds[t];
                                for (var t in this._text) delete this._text[t];
                                for (var t in this._json) delete this._json[t];
                                for (var t in this._textures) delete this._textures[t];
                                for (var t in this._physics) delete this._physics[t];
                                for (var t in this._tilemaps) delete this._tilemaps[t];
                                for (var t in this._binary) delete this._binary[t];
                                for (var t in this._bitmapDatas) delete this._bitmapDatas[t];
                                for (var t in this._bitmapFont) delete this._bitmapFont[t]
                            }
                        }, n.Cache.prototype.constructor = n.Cache, n.Loader = function(t) {
                            this.game = t, this.isLoading = !1, this.hasLoaded = !1, this.progress = 0, this.progressFloat = 0, this.preloadSprite = null, this.crossOrigin = !1, this.baseURL = "", this.onLoadStart = new n.Signal, this.onFileStart = new n.Signal, this.onFileComplete = new n.Signal, this.onFileError = new n.Signal, this.onLoadComplete = new n.Signal, this.onPackComplete = new n.Signal, this._packList = [], this._packIndex = 0, this._fileList = [], this._fileIndex = 0, this._progressChunk = 0, this._xhr = new XMLHttpRequest, this._ajax = null
                        }, n.Loader.TEXTURE_ATLAS_JSON_ARRAY = 0, n.Loader.TEXTURE_ATLAS_JSON_HASH = 1, n.Loader.TEXTURE_ATLAS_XML_STARLING = 2, n.Loader.PHYSICS_LIME_CORONA_JSON = 3, n.Loader.PHYSICS_PHASER_JSON = 4, n.Loader.prototype = {
                            setPreloadSprite: function(t, e) {
                                e = e || 0, this.preloadSprite = {
                                    sprite: t,
                                    direction: e,
                                    width: t.width,
                                    height: t.height,
                                    rect: null
                                }, this.preloadSprite.rect = 0 === e ? new n.Rectangle(0, 0, 1, t.height) : new n.Rectangle(0, 0, t.width, 1), t.crop(this.preloadSprite.rect), t.visible = !0
                            },
                            checkKeyExists: function(t, e) {
                                if (this._fileList.length > 0)
                                    for (var i = 0; i < this._fileList.length; i++)
                                        if (this._fileList[i].type === t && this._fileList[i].key === e) return !0;
                                return !1
                            },
                            getAssetIndex: function(t, e) {
                                if (this._fileList.length > 0)
                                    for (var i = 0; i < this._fileList.length; i++)
                                        if (this._fileList[i].type === t && this._fileList[i].key === e) return i;
                                return -1
                            },
                            getAsset: function(t, e) {
                                if (this._fileList.length > 0)
                                    for (var i = 0; i < this._fileList.length; i++)
                                        if (this._fileList[i].type === t && this._fileList[i].key === e) return {
                                            index: i,
                                            file: this._fileList[i]
                                        };
                                return !1
                            },
                            reset: function() {
                                this.preloadSprite = null, this.isLoading = !1, this._packList.length = 0, this._packIndex = 0, this._fileList.length = 0, this._fileIndex = 0
                            },
                            addToFileList: function(t, e, i, s) {
                                var n = {
                                    type: t,
                                    key: e,
                                    url: i,
                                    data: null,
                                    error: !1,
                                    loaded: !1
                                };
                                if ("undefined" != typeof s)
                                    for (var r in s) n[r] = s[r];
                                this.checkKeyExists(t, e) === !1 && this._fileList.push(n)
                            },
                            replaceInFileList: function(t, e, i, s) {
                                var n = {
                                    type: t,
                                    key: e,
                                    url: i,
                                    data: null,
                                    error: !1,
                                    loaded: !1
                                };
                                if ("undefined" != typeof s)
                                    for (var r in s) n[r] = s[r];
                                var o = this.getAssetIndex(t, e); - 1 === o ? this._fileList.push(n) : this._fileList[o] = n
                            },
                            pack: function(t, e, i, s) {
                                return "undefined" == typeof e && (e = null), "undefined" == typeof i && (i = null), "undefined" == typeof s && (s = this), null === e && null === i ? (console.warn("Phaser.Loader.pack - Both url and data are null. One must be set."), this) : (i && "string" == typeof i && (i = JSON.parse(i)), this._packList.push({
                                    key: t,
                                    url: e,
                                    data: i,
                                    loaded: !1,
                                    error: !1,
                                    callbackContext: s
                                }), this)
                            },
                            image: function(t, e, i) {
                                return "undefined" == typeof i && (i = !1), i ? this.replaceInFileList("image", t, e) : this.addToFileList("image", t, e), this
                            },
                            text: function(t, e, i) {
                                return "undefined" == typeof i && (i = !1), i ? this.replaceInFileList("text", t, e) : this.addToFileList("text", t, e), this
                            },
                            json: function(t, e, i) {
                                return "undefined" == typeof i && (i = !1), i ? this.replaceInFileList("json", t, e) : this.addToFileList("json", t, e), this
                            },
                            script: function(t, e, i, s) {
                                return "undefined" == typeof i && (i = !1), i !== !1 && "undefined" == typeof s && (s = i), this.addToFileList("script", t, e, {
                                    callback: i,
                                    callbackContext: s
                                }), this
                            },
                            binary: function(t, e, i, s) {
                                return "undefined" == typeof i && (i = !1), i !== !1 && "undefined" == typeof s && (s = i), this.addToFileList("binary", t, e, {
                                    callback: i,
                                    callbackContext: s
                                }), this
                            },
                            spritesheet: function(t, e, i, s, n, r, o) {
                                return "undefined" == typeof n && (n = -1), "undefined" == typeof r && (r = 0), "undefined" == typeof o && (o = 0), this.addToFileList("spritesheet", t, e, {
                                    frameWidth: i,
                                    frameHeight: s,
                                    frameMax: n,
                                    margin: r,
                                    spacing: o
                                }), this
                            },
                            audio: function(t, e, i) {
                                return "undefined" == typeof i && (i = !0), this.addToFileList("audio", t, e, {
                                    buffer: null,
                                    autoDecode: i
                                }), this
                            },
                            tilemap: function(t, e, i, s) {
                                if ("undefined" == typeof e && (e = null), "undefined" == typeof i && (i = null), "undefined" == typeof s && (s = n.Tilemap.CSV), null == e && null == i) return console.warn("Phaser.Loader.tilemap - Both url and data are null. One must be set."), this;
                                if (i) {
                                    switch (s) {
                                        case n.Tilemap.CSV:
                                            break;
                                        case n.Tilemap.TILED_JSON:
                                            "string" == typeof i && (i = JSON.parse(i))
                                    }
                                    this.game.cache.addTilemap(t, null, i, s)
                                } else this.addToFileList("tilemap", t, e, {
                                    format: s
                                });
                                return this
                            },
                            physics: function(t, e, i, s) {
                                return "undefined" == typeof e && (e = null), "undefined" == typeof i && (i = null), "undefined" == typeof s && (s = n.Physics.LIME_CORONA_JSON), null == e && null == i ? (console.warn("Phaser.Loader.physics - Both url and data are null. One must be set."), this) : (i ? ("string" == typeof i && (i = JSON.parse(i)), this.game.cache.addPhysicsData(t, null, i, s)) : this.addToFileList("physics", t, e, {
                                    format: s
                                }), this)
                            },
                            bitmapFont: function(t, e, i, s, n, r) {
                                if ("undefined" == typeof i && (i = null), "undefined" == typeof s && (s = null), "undefined" == typeof n && (n = 0), "undefined" == typeof r && (r = 0), i) this.addToFileList("bitmapfont", t, e, {
                                    xmlURL: i,
                                    xSpacing: n,
                                    ySpacing: r
                                });
                                else if ("string" == typeof s) {
                                    var o;
                                    try {
                                        if (window.DOMParser) {
                                            var a = new DOMParser;
                                            o = a.parseFromString(s, "text/xml")
                                        } else o = new ActiveXObject("Microsoft.XMLDOM"), o.async = "false", o.loadXML(s)
                                    } catch (h) {
                                        o = void 0
                                    }
                                    if (!o || !o.documentElement || o.getElementsByTagName("parsererror").length) throw new Error("Phaser.Loader. Invalid Bitmap Font XML given");
                                    this.addToFileList("bitmapfont", t, e, {
                                        xmlURL: null,
                                        xmlData: o,
                                        xSpacing: n,
                                        ySpacing: r
                                    })
                                }
                                return this
                            },
                            atlasJSONArray: function(t, e, i, s) {
                                return this.atlas(t, e, i, s, n.Loader.TEXTURE_ATLAS_JSON_ARRAY)
                            },
                            atlasJSONHash: function(t, e, i, s) {
                                return this.atlas(t, e, i, s, n.Loader.TEXTURE_ATLAS_JSON_HASH)
                            },
                            atlasXML: function(t, e, i, s) {
                                return this.atlas(t, e, i, s, n.Loader.TEXTURE_ATLAS_XML_STARLING)
                            },
                            atlas: function(t, e, i, s, r) {
                                if ("undefined" == typeof i && (i = null), "undefined" == typeof s && (s = null), "undefined" == typeof r && (r = n.Loader.TEXTURE_ATLAS_JSON_ARRAY), i) this.addToFileList("textureatlas", t, e, {
                                    atlasURL: i,
                                    format: r
                                });
                                else {
                                    switch (r) {
                                        case n.Loader.TEXTURE_ATLAS_JSON_ARRAY:
                                            "string" == typeof s && (s = JSON.parse(s));
                                            break;
                                        case n.Loader.TEXTURE_ATLAS_XML_STARLING:
                                            if ("string" == typeof s) {
                                                var o;
                                                try {
                                                    if (window.DOMParser) {
                                                        var a = new DOMParser;
                                                        o = a.parseFromString(s, "text/xml")
                                                    } else o = new ActiveXObject("Microsoft.XMLDOM"), o.async = "false", o.loadXML(s)
                                                } catch (h) {
                                                    o = void 0
                                                }
                                                if (!o || !o.documentElement || o.getElementsByTagName("parsererror").length) throw new Error("Phaser.Loader. Invalid Texture Atlas XML given");
                                                s = o
                                            }
                                    }
                                    this.addToFileList("textureatlas", t, e, {
                                        atlasURL: null,
                                        atlasData: s,
                                        format: r
                                    })
                                }
                                return this
                            },
                            removeFile: function(t, e) {
                                var i = this.getAsset(t, e);
                                i !== !1 && this._fileList.splice(i.index, 1)
                            },
                            removeAll: function() {
                                this._fileList.length = 0
                            },
                            start: function() {
                                this.isLoading || (this._packList.length > 0 ? (this._packIndex = 0, this.loadPack()) : this.beginLoad())
                            },
                            beginLoad: function() {
                                this.progress = 0, this.progressFloat = 0, this.hasLoaded = !1, this.isLoading = !0, this.onLoadStart.dispatch(this._fileList.length), this._fileList.length > 0 ? (this._fileIndex = 0, this._progressChunk = 100 / this._fileList.length, this.loadFile()) : (this.progress = 100, this.progressFloat = 100, this.hasLoaded = !0, this.isLoading = !1, this.onLoadComplete.dispatch())
                            },
                            loadPack: function() {
                                if (!this._packList[this._packIndex]) return void console.warn("Phaser.Loader loadPackList invalid index " + this._packIndex);
                                var t = this._packList[this._packIndex];
                                null !== t.data ? this.packLoadComplete(this._packIndex, !1) : this.xhrLoad(this._packIndex, this.baseURL + t.url, "text", "packLoadComplete", "packLoadError")
                            },
                            packLoadComplete: function(t, e) {
                                if ("undefined" == typeof e && (e = !0), !this._packList[t]) return void console.warn("Phaser.Loader packLoadComplete invalid index " + t);
                                var i = this._packList[t];
                                if (i.loaded = !0, e) var s = JSON.parse(this._xhr.responseText);
                                else var s = this._packList[t].data;
                                if (s[i.key])
                                    for (var r, o = 0; o < s[i.key].length; o++) switch (r = s[i.key][o], r.type) {
                                        case "image":
                                            this.image(r.key, r.url, r.overwrite);
                                            break;
                                        case "text":
                                            this.text(r.key, r.url, r.overwrite);
                                            break;
                                        case "json":
                                            this.json(r.key, r.url, r.overwrite);
                                            break;
                                        case "script":
                                            this.script(r.key, r.url, r.callback, i.callbackContext);
                                            break;
                                        case "binary":
                                            this.binary(r.key, r.url, r.callback, i.callbackContext);
                                            break;
                                        case "spritesheet":
                                            this.spritesheet(r.key, r.url, r.frameWidth, r.frameHeight, r.frameMax, r.margin, r.spacing);
                                            break;
                                        case "audio":
                                            this.audio(r.key, r.urls, r.autoDecode);
                                            break;
                                        case "tilemap":
                                            this.tilemap(r.key, r.url, r.data, n.Tilemap[r.format]);
                                            break;
                                        case "physics":
                                            this.physics(r.key, r.url, r.data, n.Loader[r.format]);
                                            break;
                                        case "bitmapFont":
                                            this.bitmapFont(r.key, r.textureURL, r.xmlURL, r.xmlData, r.xSpacing, r.ySpacing);
                                            break;
                                        case "atlasJSONArray":
                                            this.atlasJSONArray(r.key, r.textureURL, r.atlasURL, r.atlasData);
                                            break;
                                        case "atlasJSONHash":
                                            this.atlasJSONHash(r.key, r.textureURL, r.atlasURL, r.atlasData);
                                            break;
                                        case "atlasXML":
                                            this.atlasXML(r.key, r.textureURL, r.atlasURL, r.atlasData);
                                            break;
                                        case "atlas":
                                            this.atlas(r.key, r.textureURL, r.atlasURL, r.atlasData, n.Loader[r.format])
                                    }
                                this.nextPack(t, !0)
                            },
                            packError: function(t) {
                                this._packList[t].loaded = !0, this._packList[t].error = !0, this.onFileError.dispatch(this._packList[t].key, this._packList[t]), console.warn("Phaser.Loader error loading pack file: " + this._packList[t].key + " from URL " + this._packList[t].url), this.nextPack(t, !1)
                            },
                            nextPack: function(t, e) {
                                this.onPackComplete.dispatch(this._packList[t].key, e, this.totalLoadedPacks(), this._packList.length), this._packIndex++, this._packIndex < this._packList.length ? this.loadPack() : this.beginLoad()
                            },
                            loadFile: function() {
                                if (!this._fileList[this._fileIndex]) return void console.warn("Phaser.Loader loadFile invalid index " + this._fileIndex);
                                var t = this._fileList[this._fileIndex],
                                    e = this;
                                switch (this.onFileStart.dispatch(this.progress, t.key), t.type) {
                                    case "image":
                                    case "spritesheet":
                                    case "textureatlas":
                                    case "bitmapfont":
                                        t.data = new Image, t.data.name = t.key, t.data.onload = function() {
                                            return e.fileComplete(e._fileIndex)
                                        }, t.data.onerror = function() {
                                            return e.fileError(e._fileIndex)
                                        }, this.crossOrigin && (t.data.crossOrigin = this.crossOrigin), t.data.src = this.baseURL + t.url;
                                        break;
                                    case "audio":
                                        t.url = this.getAudioURL(t.url), null !== t.url ? this.game.sound.usingWebAudio ? this.xhrLoad(this._fileIndex, this.baseURL + t.url, "arraybuffer", "fileComplete", "fileError") : this.game.sound.usingAudioTag && (this.game.sound.touchLocked ? (t.data = new Audio, t.data.name = t.key, t.data.preload = "auto", t.data.src = this.baseURL + t.url, this.fileComplete(this._fileIndex)) : (t.data = new Audio, t.data.name = t.key, t.data.onerror = function() {
                                            return e.fileError(e._fileIndex)
                                        }, t.data.preload = "auto", t.data.src = this.baseURL + t.url, t.data.addEventListener("canplaythrough", n.GAMES[this.game.id].load.fileComplete(this._fileIndex), !1), t.data.load())) : this.fileError(this._fileIndex);
                                        break;
                                    case "json":
                                        window.XDomainRequest ? (this._ajax = new window.XDomainRequest, this._ajax.timeout = 3e3, this._ajax.onerror = function() {
                                            return e.dataLoadError(e._fileIndex)
                                        }, this._ajax.ontimeout = function() {
                                            return e.dataLoadError(e._fileIndex)
                                        }, this._ajax.onprogress = function() {}, this._ajax.onload = function() {
                                            return e.jsonLoadComplete(e._fileIndex)
                                        }, this._ajax.open("GET", this.baseURL + t.url, !0), this._ajax.send()) : this.xhrLoad(this._fileIndex, this.baseURL + t.url, "text", "jsonLoadComplete", "dataLoadError");
                                        break;
                                    case "tilemap":
                                        if (t.format === n.Tilemap.TILED_JSON) this.xhrLoad(this._fileIndex, this.baseURL + t.url, "text", "jsonLoadComplete", "dataLoadError");
                                        else {
                                            if (t.format !== n.Tilemap.CSV) throw new Error("Phaser.Loader. Invalid Tilemap format: " + t.format);
                                            this.xhrLoad(this._fileIndex, this.baseURL + t.url, "text", "csvLoadComplete", "dataLoadError")
                                        }
                                        break;
                                    case "text":
                                    case "script":
                                    case "physics":
                                        this.xhrLoad(this._fileIndex, this.baseURL + t.url, "text", "fileComplete", "fileError");
                                        break;
                                    case "binary":
                                        this.xhrLoad(this._fileIndex, this.baseURL + t.url, "arraybuffer", "fileComplete", "fileError")
                                }
                            },
                            xhrLoad: function(t, e, i, s, n) {
                                this._xhr.open("GET", e, !0), this._xhr.responseType = i;
                                var r = this;
                                this._xhr.onload = function() {
                                    return r[s](t)
                                }, this._xhr.onerror = function() {
                                    return r[n](t)
                                }, this._xhr.send()
                            },
                            getAudioURL: function(t) {
                                var e;
                                "string" == typeof t && (t = [t]);
                                for (var i = 0; i < t.length; i++)
                                    if (e = t[i].toLowerCase(), e = e.substr((Math.max(0, e.lastIndexOf(".")) || 1 / 0) + 1), this.game.device.canPlayAudio(e)) return t[i];
                                return null
                            },
                            fileError: function(t) {
                                this._fileList[t].loaded = !0, this._fileList[t].error = !0, this.onFileError.dispatch(this._fileList[t].key, this._fileList[t]), console.warn("Phaser.Loader error loading file: " + this._fileList[t].key + " from URL " + this._fileList[t].url), this.nextFile(t, !1)
                            },
                            fileComplete: function(t) {
                                if (!this._fileList[t]) return void console.warn("Phaser.Loader fileComplete invalid index " + t);
                                var e = this._fileList[t];
                                e.loaded = !0;
                                var i = !0;
                                switch (e.type) {
                                    case "image":
                                        this.game.cache.addImage(e.key, e.url, e.data);
                                        break;
                                    case "spritesheet":
                                        this.game.cache.addSpriteSheet(e.key, e.url, e.data, e.frameWidth, e.frameHeight, e.frameMax, e.margin, e.spacing);
                                        break;
                                    case "textureatlas":
                                        if (null == e.atlasURL) this.game.cache.addTextureAtlas(e.key, e.url, e.data, e.atlasData, e.format);
                                        else if (i = !1, e.format == n.Loader.TEXTURE_ATLAS_JSON_ARRAY || e.format == n.Loader.TEXTURE_ATLAS_JSON_HASH) this.xhrLoad(this._fileIndex, this.baseURL + e.atlasURL, "text", "jsonLoadComplete", "dataLoadError");
                                        else {
                                            if (e.format != n.Loader.TEXTURE_ATLAS_XML_STARLING) throw new Error("Phaser.Loader. Invalid Texture Atlas format: " + e.format);
                                            this.xhrLoad(this._fileIndex, this.baseURL + e.atlasURL, "text", "xmlLoadComplete", "dataLoadError")
                                        }
                                        break;
                                    case "bitmapfont":
                                        null == e.xmlURL ? this.game.cache.addBitmapFont(e.key, e.url, e.data, e.xmlData, e.xSpacing, e.ySpacing) : (i = !1, this.xhrLoad(this._fileIndex, this.baseURL + e.xmlURL, "text", "xmlLoadComplete", "dataLoadError"));
                                        break;
                                    case "audio":
                                        if (this.game.sound.usingWebAudio) {
                                            if (e.data = this._xhr.response, this.game.cache.addSound(e.key, e.url, e.data, !0, !1), e.autoDecode) {
                                                var s = this,
                                                    r = e.key;
                                                this.game.cache.updateSound(r, "isDecoding", !0), this.game.sound.context.decodeAudioData(e.data, function(t) {
                                                    t && (s.game.cache.decodedSound(r, t), s.game.sound.onSoundDecode.dispatch(r, s.game.cache.getSound(r)))
                                                })
                                            }
                                        } else e.data.removeEventListener("canplaythrough", n.GAMES[this.game.id].load.fileComplete), this.game.cache.addSound(e.key, e.url, e.data, !1, !0);
                                        break;
                                    case "text":
                                        e.data = this._xhr.responseText, this.game.cache.addText(e.key, e.url, e.data);
                                        break;
                                    case "physics":
                                        var o = JSON.parse(this._xhr.responseText);
                                        this.game.cache.addPhysicsData(e.key, e.url, o, e.format);
                                        break;
                                    case "script":
                                        e.data = document.createElement("script"), e.data.language = "javascript", e.data.type = "text/javascript", e.data.defer = !1, e.data.text = this._xhr.responseText, document.head.appendChild(e.data), e.callback && (e.data = e.callback.call(e.callbackContext, e.key, this._xhr.responseText));
                                        break;
                                    case "binary":
                                        e.data = e.callback ? e.callback.call(e.callbackContext, e.key, this._xhr.response) : this._xhr.response, this.game.cache.addBinary(e.key, e.data)
                                }
                                i && this.nextFile(t, !0)
                            },
                            jsonLoadComplete: function(t) {
                                if (!this._fileList[t]) return void console.warn("Phaser.Loader jsonLoadComplete invalid index " + t);
                                var e = this._fileList[t],
                                    i = JSON.parse(this._xhr.responseText);
                                e.loaded = !0, "tilemap" === e.type ? this.game.cache.addTilemap(e.key, e.url, i, e.format) : "json" === e.type ? this.game.cache.addJSON(e.key, e.url, i) : this.game.cache.addTextureAtlas(e.key, e.url, e.data, i, e.format), this.nextFile(t, !0)
                            },
                            csvLoadComplete: function(t) {
                                if (!this._fileList[t]) return void console.warn("Phaser.Loader csvLoadComplete invalid index " + t);
                                var e = this._fileList[t],
                                    i = this._xhr.responseText;
                                e.loaded = !0, this.game.cache.addTilemap(e.key, e.url, i, e.format), this.nextFile(t, !0)
                            },
                            dataLoadError: function(t) {
                                var e = this._fileList[t];
                                e.loaded = !0, e.error = !0, console.warn("Phaser.Loader dataLoadError: " + e.key), this.nextFile(t, !0)
                            },
                            xmlLoadComplete: function(t) {
                                var e, i = this._xhr.responseText;
                                try {
                                    if (window.DOMParser) {
                                        var s = new DOMParser;
                                        e = s.parseFromString(i, "text/xml")
                                    } else e = new ActiveXObject("Microsoft.XMLDOM"), e.async = "false", e.loadXML(i)
                                } catch (n) {
                                    e = void 0
                                }
                                if (!e || !e.documentElement || e.getElementsByTagName("parsererror").length) throw new Error("Phaser.Loader. Invalid XML given");
                                var r = this._fileList[t];
                                r.loaded = !0, "bitmapfont" == r.type ? this.game.cache.addBitmapFont(r.key, r.url, r.data, e, r.xSpacing, r.ySpacing) : "textureatlas" == r.type && this.game.cache.addTextureAtlas(r.key, r.url, r.data, e, r.format), this.nextFile(t, !0)
                            },
                            nextFile: function(t, e) {
                                this.progressFloat += this._progressChunk, this.progress = Math.round(this.progressFloat), this.progress > 100 && (this.progress = 100), null !== this.preloadSprite && (0 === this.preloadSprite.direction ? (this.preloadSprite.rect.width = Math.floor(this.preloadSprite.width / 100 * this.progress), this.preloadSprite.sprite.crop(this.preloadSprite.rect)) : (this.preloadSprite.rect.height = Math.floor(this.preloadSprite.height / 100 * this.progress), this.preloadSprite.sprite.crop(this.preloadSprite.rect))), this.onFileComplete.dispatch(this.progress, this._fileList[t].key, e, this.totalLoadedFiles(), this._fileList.length), this.totalQueuedFiles() > 0 ? (this._fileIndex++, this.loadFile()) : (this.hasLoaded = !0, this.isLoading = !1, this.removeAll(), this.onLoadComplete.dispatch())
                            },
                            totalLoadedFiles: function() {
                                for (var t = 0, e = 0; e < this._fileList.length; e++) this._fileList[e].loaded && t++;
                                return t
                            },
                            totalQueuedFiles: function() {
                                for (var t = 0, e = 0; e < this._fileList.length; e++) this._fileList[e].loaded === !1 && t++;
                                return t
                            },
                            totalLoadedPacks: function() {
                                for (var t = 0, e = 0; e < this._packList.length; e++) this._packList[e].loaded && t++;
                                return t
                            },
                            totalQueuedPacks: function() {
                                for (var t = 0, e = 0; e < this._packList.length; e++) this._packList[e].loaded === !1 && t++;
                                return t
                            }
                        }, n.Loader.prototype.constructor = n.Loader, n.LoaderParser = {
                            bitmapFont: function(t, e, i, s, n) {
                                var r = {},
                                    o = e.getElementsByTagName("info")[0],
                                    a = e.getElementsByTagName("common")[0];
                                r.font = o.getAttribute("face"), r.size = parseInt(o.getAttribute("size"), 10), r.lineHeight = parseInt(a.getAttribute("lineHeight"), 10) + n, r.chars = {};
                                for (var h = e.getElementsByTagName("char"), l = 0; l < h.length; l++) {
                                    var c = parseInt(h[l].getAttribute("id"), 10),
                                        u = new PIXI.Rectangle(parseInt(h[l].getAttribute("x"), 10), parseInt(h[l].getAttribute("y"), 10), parseInt(h[l].getAttribute("width"), 10), parseInt(h[l].getAttribute("height"), 10));
                                    r.chars[c] = {
                                        xOffset: parseInt(h[l].getAttribute("xoffset"), 10),
                                        yOffset: parseInt(h[l].getAttribute("yoffset"), 10),
                                        xAdvance: parseInt(h[l].getAttribute("xadvance"), 10) + s,
                                        kerning: {},
                                        texture: PIXI.TextureCache[i] = new PIXI.Texture(PIXI.BaseTextureCache[i], u)
                                    }
                                }
                                var d = e.getElementsByTagName("kerning");
                                for (l = 0; l < d.length; l++) {
                                    var p = parseInt(d[l].getAttribute("first"), 10),
                                        f = parseInt(d[l].getAttribute("second"), 10),
                                        g = parseInt(d[l].getAttribute("amount"), 10);
                                    r.chars[f].kerning[p] = g
                                }
                                PIXI.BitmapText.fonts[i] = r
                            }
                        }, n.Sound = function(t, e, i, s, r) {
                            "undefined" == typeof i && (i = 1), "undefined" == typeof s && (s = !1), "undefined" == typeof r && (r = t.sound.connectToMaster), this.game = t, this.name = e, this.key = e, this.loop = s, this.volume = i, this.markers = {}, this.context = null, this.autoplay = !1, this.totalDuration = 0, this.startTime = 0, this.currentTime = 0, this.duration = 0, this.durationMS = 0, this.position = 0, this.stopTime = 0, this.paused = !1, this.pausedPosition = 0, this.pausedTime = 0, this.isPlaying = !1, this.currentMarker = "", this.pendingPlayback = !1, this.override = !1, this.usingWebAudio = this.game.sound.usingWebAudio, this.usingAudioTag = this.game.sound.usingAudioTag, this.externalNode = null, this.masterGainNode = null, this.gainNode = null, this.usingWebAudio ? (this.context = this.game.sound.context, this.masterGainNode = this.game.sound.masterGain, this.gainNode = "undefined" == typeof this.context.createGain ? this.context.createGainNode() : this.context.createGain(), this.gainNode.gain.value = i * this.game.sound.volume, r && this.gainNode.connect(this.masterGainNode)) : this.game.cache.getSound(e) && this.game.cache.isSoundReady(e) ? (this._sound = this.game.cache.getSoundData(e), this.totalDuration = 0, this._sound.duration && (this.totalDuration = this._sound.duration)) : this.game.cache.onSoundUnlock.add(this.soundHasUnlocked, this), this.onDecoded = new n.Signal, this.onPlay = new n.Signal, this.onPause = new n.Signal, this.onResume = new n.Signal, this.onLoop = new n.Signal, this.onStop = new n.Signal, this.onMute = new n.Signal, this.onMarkerComplete = new n.Signal, this._volume = i, this._buffer = null, this._muted = !1, this._tempMarker = 0, this._tempPosition = 0, this._tempVolume = 0, this._tempLoop = 0, this._paused = !1, this._onDecodedEventDispatched = !1
                        }, n.Sound.prototype = {
                            soundHasUnlocked: function(t) {
                                t == this.key && (this._sound = this.game.cache.getSoundData(this.key), this.totalDuration = this._sound.duration)
                            },
                            addMarker: function(t, e, i, s, n) {
                                "undefined" == typeof s && (s = 1), "undefined" == typeof n && (n = !1), this.markers[t] = {
                                    name: t,
                                    start: e,
                                    stop: e + i,
                                    volume: s,
                                    duration: i,
                                    durationMS: 1e3 * i,
                                    loop: n
                                }
                            },
                            removeMarker: function(t) {
                                delete this.markers[t]
                            },
                            update: function() {
                                this.isDecoded && !this._onDecodedEventDispatched && (this.onDecoded.dispatch(this), this._onDecodedEventDispatched = !0), this.pendingPlayback && this.game.cache.isSoundReady(this.key) && (this.pendingPlayback = !1, this.play(this._tempMarker, this._tempPosition, this._tempVolume, this._tempLoop)), this.isPlaying && (this.currentTime = this.game.time.now - this.startTime, this.currentTime >= this.durationMS && (this.usingWebAudio ? this.loop ? (this.onLoop.dispatch(this), "" === this.currentMarker ? (this.currentTime = 0, this.startTime = this.game.time.now) : (this.onMarkerComplete.dispatch(this.currentMarker, this), this.play(this.currentMarker, 0, this.volume, !0, !0))) : this.stop() : this.loop ? (this.onLoop.dispatch(this), this.play(this.currentMarker, 0, this.volume, !0, !0)) : this.stop()))
                            },
                            play: function(t, e, i, s, n) {
                                if ("undefined" == typeof t && (t = ""), "undefined" == typeof n && (n = !0), this.isPlaying === !0 && n === !1 && this.override === !1) return this;
                                if (this.isPlaying && this.override && (this.usingWebAudio ? "undefined" == typeof this._sound.stop ? this._sound.noteOff(0) : this._sound.stop(0) : this.usingAudioTag && (this._sound.pause(), this._sound.currentTime = 0)), this.currentMarker = t, "" !== t) {
                                    if (!this.markers[t]) return console.warn("Phaser.Sound.play: audio marker " + t + " doesn't exist"), this;
                                    this.position = this.markers[t].start, this.volume = this.markers[t].volume, this.loop = this.markers[t].loop, this.duration = this.markers[t].duration, this.durationMS = this.markers[t].durationMS, "undefined" != typeof i && (this.volume = i), "undefined" != typeof s && (this.loop = s), this._tempMarker = t, this._tempPosition = this.position, this._tempVolume = this.volume, this._tempLoop = this.loop
                                } else e = e || 0, "undefined" == typeof i && (i = this._volume), "undefined" == typeof s && (s = this.loop), this.position = e, this.volume = i, this.loop = s, this.duration = 0, this.durationMS = 0, this._tempMarker = t, this._tempPosition = e, this._tempVolume = i, this._tempLoop = s;
                                return this.usingWebAudio ? this.game.cache.isSoundDecoded(this.key) ? (null == this._buffer && (this._buffer = this.game.cache.getSoundData(this.key)), this._sound = this.context.createBufferSource(), this._sound.buffer = this._buffer, this._sound.connect(this.externalNode ? this.externalNode : this.gainNode), this.totalDuration = this._sound.buffer.duration, 0 === this.duration && (this.duration = this.totalDuration, this.durationMS = 1e3 * this.totalDuration), this.loop && "" === t && (this._sound.loop = !0), "undefined" == typeof this._sound.start ? this._sound.noteGrainOn(0, this.position, this.duration) : this._sound.start(0, this.position, this.duration), this.isPlaying = !0, this.startTime = this.game.time.now, this.currentTime = 0, this.stopTime = this.startTime + this.durationMS, this.onPlay.dispatch(this)) : (this.pendingPlayback = !0, this.game.cache.getSound(this.key) && this.game.cache.getSound(this.key).isDecoding === !1 && this.game.sound.decode(this.key, this)) : this.game.cache.getSound(this.key) && this.game.cache.getSound(this.key).locked ? (this.game.cache.reloadSound(this.key), this.pendingPlayback = !0) : this._sound && (this.game.device.cocoonJS || 4 === this._sound.readyState) ? (this._sound.play(), this.totalDuration = this._sound.duration, 0 === this.duration && (this.duration = this.totalDuration, this.durationMS = 1e3 * this.totalDuration), this._sound.currentTime = this.position, this._sound.muted = this._muted, this._sound.volume = this._muted ? 0 : this._volume, this.isPlaying = !0, this.startTime = this.game.time.now, this.currentTime = 0, this.stopTime = this.startTime + this.durationMS, this.onPlay.dispatch(this)) : this.pendingPlayback = !0, this
                            },
                            restart: function(t, e, i, s) {
                                t = t || "", e = e || 0, i = i || 1, "undefined" == typeof s && (s = !1), this.play(t, e, i, s, !0)
                            },
                            pause: function() {
                                this.isPlaying && this._sound && (this.paused = !0, this.pausedPosition = this.currentTime, this.pausedTime = this.game.time.now, this.onPause.dispatch(this), this.stop())
                            },
                            resume: function() {
                                if (this.paused && this._sound) {
                                    if (this.usingWebAudio) {
                                        var t = this.position + this.pausedPosition / 1e3;
                                        this._sound = this.context.createBufferSource(), this._sound.buffer = this._buffer, this._sound.connect(this.externalNode ? this.externalNode : this.gainNode), this.loop && (this._sound.loop = !0), "undefined" == typeof this._sound.start ? this._sound.noteGrainOn(0, t, this.duration) : this._sound.start(0, t, this.duration)
                                    } else this._sound.play();
                                    this.isPlaying = !0, this.paused = !1, this.startTime += this.game.time.now - this.pausedTime, this.onResume.dispatch(this)
                                }
                            },
                            stop: function() {
                                if (this.isPlaying && this._sound)
                                    if (this.usingWebAudio)
                                        if ("undefined" == typeof this._sound.stop) this._sound.noteOff(0);
                                        else try {
                                            this._sound.stop(0)
                                        } catch (t) {} else this.usingAudioTag && (this._sound.pause(), this._sound.currentTime = 0);
                                this.isPlaying = !1;
                                var e = this.currentMarker;
                                "" !== this.currentMarker && this.onMarkerComplete.dispatch(this.currentMarker, this), this.currentMarker = "", this.paused || this.onStop.dispatch(this, e)
                            },
                            destroy: function(t) {
                                "undefined" == typeof t && (t = !0), this.stop(), t ? this.game.sound.remove(this) : (this.markers = {}, this.context = null, this._buffer = null, this.externalNode = null, this.onDecoded.dispose(), this.onPlay.dispose(), this.onPause.dispose(), this.onResume.dispose(), this.onLoop.dispose(), this.onStop.dispose(), this.onMute.dispose(), this.onMarkerComplete.dispose())
                            }
                        }, n.Sound.prototype.constructor = n.Sound, Object.defineProperty(n.Sound.prototype, "isDecoding", {
                            get: function() {
                                return this.game.cache.getSound(this.key).isDecoding
                            }
                        }), Object.defineProperty(n.Sound.prototype, "isDecoded", {
                            get: function() {
                                return this.game.cache.isSoundDecoded(this.key)
                            }
                        }), Object.defineProperty(n.Sound.prototype, "mute", {
                            get: function() {
                                return this._muted || this.game.sound.mute
                            },
                            set: function(t) {
                                t = t || null, t ? (this._muted = !0, this.usingWebAudio ? (this._muteVolume = this.gainNode.gain.value, this.gainNode.gain.value = 0) : this.usingAudioTag && this._sound && (this._muteVolume = this._sound.volume, this._sound.volume = 0)) : (this._muted = !1, this.usingWebAudio ? this.gainNode.gain.value = this._muteVolume : this.usingAudioTag && this._sound && (this._sound.volume = this._muteVolume)), this.onMute.dispatch(this)
                            }
                        }), Object.defineProperty(n.Sound.prototype, "volume", {
                            get: function() {
                                return this._volume
                            },
                            set: function(t) {
                                this.usingWebAudio ? (this._volume = t, this.gainNode.gain.value = t) : this.usingAudioTag && this._sound && t >= 0 && 1 >= t && (this._volume = t, this._sound.volume = t)
                            }
                        }), n.SoundManager = function(t) {
                            this.game = t, this.onSoundDecode = new n.Signal, this._codeMuted = !1, this._muted = !1, this._unlockSource = null, this._volume = 1, this._sounds = [], this.context = null, this.usingWebAudio = !0, this.usingAudioTag = !1, this.noAudio = !1, this.connectToMaster = !0, this.touchLocked = !1, this.channels = 32
                        }, n.SoundManager.prototype = {
                            boot: function() {
                                if (this.game.device.iOS && this.game.device.webAudio === !1 && (this.channels = 1), !this.game.device.cocoonJS && this.game.device.iOS || window.PhaserGlobal && window.PhaserGlobal.fakeiOSTouchLock ? (this.game.input.touch.callbackContext = this, this.game.input.touch.touchStartCallback = this.unlock, this.game.input.mouse.callbackContext = this, this.game.input.mouse.mouseDownCallback = this.unlock, this.touchLocked = !0) : this.touchLocked = !1, window.PhaserGlobal) {
                                    if (window.PhaserGlobal.disableAudio === !0) return this.usingWebAudio = !1, void(this.noAudio = !0);
                                    if (window.PhaserGlobal.disableWebAudio === !0) return this.usingWebAudio = !1, this.usingAudioTag = !0, void(this.noAudio = !1)
                                }
                                if (window.AudioContext) try {
                                    this.context = new window.AudioContext
                                } catch (t) {
                                    this.context = null, this.usingWebAudio = !1, this.noAudio = !0
                                } else if (window.webkitAudioContext) try {
                                    this.context = new window.webkitAudioContext
                                } catch (t) {
                                    this.context = null, this.usingWebAudio = !1, this.noAudio = !0
                                }
                                window.Audio && null === this.context && (this.usingWebAudio = !1, this.usingAudioTag = !0, this.noAudio = !1), null !== this.context && (this.masterGain = "undefined" == typeof this.context.createGain ? this.context.createGainNode() : this.context.createGain(), this.masterGain.gain.value = 1, this.masterGain.connect(this.context.destination))
                            },
                            unlock: function() {
                                if (this.touchLocked !== !1)
                                    if (this.game.device.webAudio === !1 || window.PhaserGlobal && window.PhaserGlobal.disableWebAudio === !0) this.touchLocked = !1, this._unlockSource = null, this.game.input.touch.callbackContext = null, this.game.input.touch.touchStartCallback = null, this.game.input.mouse.callbackContext = null, this.game.input.mouse.mouseDownCallback = null;
                                    else {
                                        var t = this.context.createBuffer(1, 1, 22050);
                                        this._unlockSource = this.context.createBufferSource(), this._unlockSource.buffer = t, this._unlockSource.connect(this.context.destination), this._unlockSource.noteOn(0)
                                    }
                            },
                            stopAll: function() {
                                for (var t = 0; t < this._sounds.length; t++) this._sounds[t] && this._sounds[t].stop()
                            },
                            pauseAll: function() {
                                for (var t = 0; t < this._sounds.length; t++) this._sounds[t] && this._sounds[t].pause()
                            },
                            resumeAll: function() {
                                for (var t = 0; t < this._sounds.length; t++) this._sounds[t] && this._sounds[t].resume()
                            },
                            decode: function(t, e) {
                                e = e || null;
                                var i = this.game.cache.getSoundData(t);
                                if (i && this.game.cache.isSoundDecoded(t) === !1) {
                                    this.game.cache.updateSound(t, "isDecoding", !0);
                                    var s = this;
                                    this.context.decodeAudioData(i, function(i) {
                                        s.game.cache.decodedSound(t, i), e && s.onSoundDecode.dispatch(t, e)
                                    })
                                }
                            },
                            update: function() {
                                this.touchLocked && this.game.device.webAudio && null !== this._unlockSource && (this._unlockSource.playbackState === this._unlockSource.PLAYING_STATE || this._unlockSource.playbackState === this._unlockSource.FINISHED_STATE) && (this.touchLocked = !1, this._unlockSource = null, this.game.input.touch.callbackContext = null, this.game.input.touch.touchStartCallback = null);
                                for (var t = 0; t < this._sounds.length; t++) this._sounds[t].update()
                            },
                            add: function(t, e, i, s) {
                                "undefined" == typeof e && (e = 1), "undefined" == typeof i && (i = !1), "undefined" == typeof s && (s = this.connectToMaster);
                                var r = new n.Sound(this.game, t, e, i, s);
                                return this._sounds.push(r), r
                            },
                            remove: function(t) {
                                for (var e = this._sounds.length; e--;)
                                    if (this._sounds[e] === t) return this._sounds[e].destroy(!1), this._sounds.splice(e, 1), !0;
                                return !1
                            },
                            removeByKey: function(t) {
                                for (var e = this._sounds.length, i = 0; e--;) this._sounds[e].key === t && (this._sounds[e].destroy(!1), this._sounds.splice(e, 1), i++);
                                return i
                            },
                            play: function(t, e, i) {
                                var s = this.add(t, e, i);
                                return s.play(), s
                            },
                            setMute: function() {
                                if (!this._muted) {
                                    this._muted = !0, this.usingWebAudio && (this._muteVolume = this.masterGain.gain.value, this.masterGain.gain.value = 0);
                                    for (var t = 0; t < this._sounds.length; t++) this._sounds[t].usingAudioTag && (this._sounds[t].mute = !0)
                                }
                            },
                            unsetMute: function() {
                                if (this._muted && !this._codeMuted) {
                                    this._muted = !1, this.usingWebAudio && (this.masterGain.gain.value = this._muteVolume);
                                    for (var t = 0; t < this._sounds.length; t++) this._sounds[t].usingAudioTag && (this._sounds[t].mute = !1)
                                }
                            }
                        }, n.SoundManager.prototype.constructor = n.SoundManager, Object.defineProperty(n.SoundManager.prototype, "mute", {
                            get: function() {
                                return this._muted
                            },
                            set: function(t) {
                                if (t = t || null) {
                                    if (this._muted) return;
                                    this._codeMuted = !0, this.setMute()
                                } else {
                                    if (!this._muted) return;
                                    this._codeMuted = !1, this.unsetMute()
                                }
                            }
                        }), Object.defineProperty(n.SoundManager.prototype, "volume", {
                            get: function() {
                                return this.usingWebAudio ? this.masterGain.gain.value : this._volume
                            },
                            set: function(t) {
                                if (this._volume = t, this.usingWebAudio) this.masterGain.gain.value = t;
                                else
                                    for (var e = 0; e < this._sounds.length; e++) this._sounds[e].usingAudioTag && (this._sounds[e].volume = this._sounds[e].volume * t)
                            }
                        }), n.Utils.Debug = function(t) {
                            this.game = t, this.sprite = null, this.canvas = null, this.baseTexture = null, this.texture = null, this.textureFrame = null, this.context = null, this.font = "14px Courier", this.columnWidth = 100, this.lineHeight = 16, this.renderShadow = !0, this.currentX = 0, this.currentY = 0, this.currentAlpha = 1, this.dirty = !1
                        }, n.Utils.Debug.prototype = {
                            boot: function() {
                                this.game.renderType === n.CANVAS ? this.context = this.game.context : (this.canvas = n.Canvas.create(this.game.width, this.game.height, "", !0), this.context = this.canvas.getContext("2d"), this.baseTexture = new PIXI.BaseTexture(this.canvas), this.texture = new PIXI.Texture(this.baseTexture), this.textureFrame = new n.Frame(0, 0, 0, this.game.width, this.game.height, "debug", this.game.rnd.uuid()), this.sprite = this.game.make.image(0, 0, this.texture, this.textureFrame), this.game.stage.addChild(this.sprite))
                            },
                            preUpdate: function() {
                                this.dirty && this.sprite && (this.context.clearRect(0, 0, this.game.width, this.game.height), this.dirty = !1)
                            },
                            start: function(t, e, i, s) {
                                "number" != typeof t && (t = 0), "number" != typeof e && (e = 0), i = i || "rgb(255,255,255)", "undefined" == typeof s && (s = 0), this.currentX = t, this.currentY = e, this.currentColor = i, this.currentAlpha = this.context.globalAlpha, this.columnWidth = s, this.sprite && (this.dirty = !0), this.context.save(), this.context.setTransform(1, 0, 0, 1, 0, 0), this.context.strokeStyle = i, this.context.fillStyle = i, this.context.font = this.font, this.context.globalAlpha = 1
                            },
                            stop: function() {
                                this.context.restore(), this.context.globalAlpha = this.currentAlpha, this.sprite && PIXI.updateWebGLTexture(this.baseTexture, this.game.renderer.gl)
                            },
                            line: function() {
                                for (var t = this.currentX, e = 0; e < arguments.length; e++) this.renderShadow && (this.context.fillStyle = "rgb(0,0,0)", this.context.fillText(arguments[e], t + 1, this.currentY + 1), this.context.fillStyle = this.currentColor), this.context.fillText(arguments[e], t, this.currentY), t += this.columnWidth;
                                this.currentY += this.lineHeight
                            },
                            soundInfo: function(t, e, i, s) {
                                this.start(e, i, s), this.line("Sound: " + t.key + " Locked: " + t.game.sound.touchLocked), this.line("Is Ready?: " + this.game.cache.isSoundReady(t.key) + " Pending Playback: " + t.pendingPlayback), this.line("Decoded: " + t.isDecoded + " Decoding: " + t.isDecoding), this.line("Total Duration: " + t.totalDuration + " Playing: " + t.isPlaying), this.line("Time: " + t.currentTime), this.line("Volume: " + t.volume + " Muted: " + t.mute), this.line("WebAudio: " + t.usingWebAudio + " Audio: " + t.usingAudioTag), "" !== t.currentMarker && (this.line("Marker: " + t.currentMarker + " Duration: " + t.duration + " (ms: " + t.durationMS + ")"), this.line("Start: " + t.markers[t.currentMarker].start + " Stop: " + t.markers[t.currentMarker].stop), this.line("Position: " + t.position)), this.stop()
                            },
                            cameraInfo: function(t, e, i, s) {
                                this.start(e, i, s), this.line("Camera (" + t.width + " x " + t.height + ")"), this.line("X: " + t.x + " Y: " + t.y), this.line("Bounds x: " + t.bounds.x + " Y: " + t.bounds.y + " w: " + t.bounds.width + " h: " + t.bounds.height), this.line("View x: " + t.view.x + " Y: " + t.view.y + " w: " + t.view.width + " h: " + t.view.height), this.stop()
                            },
                            timer: function(t, e, i, s) {
                                this.start(e, i, s), this.line("Timer (running: " + t.running + " expired: " + t.expired + ")"), this.line("Next Tick: " + t.next + " Duration: " + t.duration), this.line("Paused: " + t.paused + " Length: " + t.length), this.stop()
                            },
                            pointer: function(t, e, i, s, n) {
                                null != t && ("undefined" == typeof e && (e = !1), i = i || "rgba(0,255,0,0.5)", s = s || "rgba(255,0,0,0.5)", (e !== !0 || t.isUp !== !0) && (this.start(t.x, t.y - 100, n), this.context.beginPath(), this.context.arc(t.x, t.y, t.circle.radius, 0, 2 * Math.PI), this.context.fillStyle = t.active ? i : s, this.context.fill(), this.context.closePath(), this.context.beginPath(), this.context.moveTo(t.positionDown.x, t.positionDown.y), this.context.lineTo(t.position.x, t.position.y), this.context.lineWidth = 2, this.context.stroke(), this.context.closePath(), this.line("ID: " + t.id + " Active: " + t.active), this.line("World X: " + t.worldX + " World Y: " + t.worldY), this.line("Screen X: " + t.x + " Screen Y: " + t.y), this.line("Duration: " + t.duration + " ms"), this.line("is Down: " + t.isDown + " is Up: " + t.isUp), this.stop()))
                            },
                            spriteInputInfo: function(t, e, i, s) {
                                this.start(e, i, s), this.line("Sprite Input: (" + t.width + " x " + t.height + ")"), this.line("x: " + t.input.pointerX().toFixed(1) + " y: " + t.input.pointerY().toFixed(1)), this.line("over: " + t.input.pointerOver() + " duration: " + t.input.overDuration().toFixed(0)), this.line("down: " + t.input.pointerDown() + " duration: " + t.input.downDuration().toFixed(0)), this.line("just over: " + t.input.justOver() + " just out: " + t.input.justOut()), this.stop()
                            },
                            key: function(t, e, i, s) {
                                this.start(e, i, s, 150), this.line("Key:", t.keyCode, "isDown:", t.isDown), this.line("justPressed:", t.justPressed(), "justReleased:", t.justReleased()), this.line("Time Down:", t.timeDown.toFixed(0), "duration:", t.duration.toFixed(0)), this.stop()
                            },
                            inputInfo: function(t, e, i) {
                                this.start(t, e, i), this.line("Input"), this.line("X: " + this.game.input.x + " Y: " + this.game.input.y), this.line("World X: " + this.game.input.worldX + " World Y: " + this.game.input.worldY), this.line("Scale X: " + this.game.input.scale.x.toFixed(1) + " Scale Y: " + this.game.input.scale.x.toFixed(1)), this.line("Screen X: " + this.game.input.activePointer.screenX + " Screen Y: " + this.game.input.activePointer.screenY), this.stop()
                            },
                            spriteBounds: function(t, e, i) {
                                var s = t.getBounds();
                                s.x += this.game.camera.x, s.y += this.game.camera.y, this.rectangle(s, e, i)
                            },
                            spriteInfo: function(t, e, i, s) {
                                this.start(e, i, s), this.line("Sprite:  (" + t.width + " x " + t.height + ") anchor: " + t.anchor.x + " x " + t.anchor.y), this.line("x: " + t.x.toFixed(1) + " y: " + t.y.toFixed(1)), this.line("angle: " + t.angle.toFixed(1) + " rotation: " + t.rotation.toFixed(1)), this.line("visible: " + t.visible + " in camera: " + t.inCamera), this.stop()
                            },
                            spriteCoords: function(t, e, i, s) {
                                this.start(e, i, s, 100), t.name && this.line(t.name), this.line("x:", t.x.toFixed(2), "y:", t.y.toFixed(2)), this.line("pos x:", t.position.x.toFixed(2), "pos y:", t.position.y.toFixed(2)), this.line("world x:", t.world.x.toFixed(2), "world y:", t.world.y.toFixed(2)), this.stop()
                            },
                            lineInfo: function(t, e, i, s) {
                                this.start(e, i, s, 80), this.line("start.x:", t.start.x.toFixed(2), "start.y:", t.start.y.toFixed(2)), this.line("end.x:", t.end.x.toFixed(2), "end.y:", t.end.y.toFixed(2)), this.line("length:", t.length.toFixed(2), "angle:", t.angle), this.stop()
                            },
                            pixel: function(t, e, i, s) {
                                s = s || 2, this.start(), this.context.fillStyle = i, this.context.fillRect(t, e, s, s), this.stop()
                            },
                            geom: function(t, e, i, s) {
                                "undefined" == typeof i && (i = !0), "undefined" == typeof s && (s = 0), e = e || "rgba(0,255,0,0.4)", this.start(), this.context.fillStyle = e, this.context.strokeStyle = e, t instanceof n.Rectangle || 1 === s ? i ? this.context.fillRect(t.x - this.game.camera.x, t.y - this.game.camera.y, t.width, t.height) : this.context.strokeRect(t.x - this.game.camera.x, t.y - this.game.camera.y, t.width, t.height) : t instanceof n.Circle || 2 === s ? (this.context.beginPath(), this.context.arc(t.x - this.game.camera.x, t.y - this.game.camera.y, t.radius, 0, 2 * Math.PI, !1), this.context.closePath(), i ? this.context.fill() : this.context.stroke()) : t instanceof n.Point || 3 === s ? this.context.fillRect(t.x - this.game.camera.x, t.y - this.game.camera.y, 4, 4) : (t instanceof n.Line || 4 === s) && (this.context.lineWidth = 1, this.context.beginPath(), this.context.moveTo(t.start.x + .5 - this.game.camera.x, t.start.y + .5 - this.game.camera.y), this.context.lineTo(t.end.x + .5 - this.game.camera.x, t.end.y + .5 - this.game.camera.y), this.context.closePath(), this.context.stroke()), this.stop()
                            },
                            rectangle: function(t, e, i) {
                                "undefined" == typeof i && (i = !0), e = e || "rgba(0, 255, 0, 0.4)", this.start(), i ? (this.context.fillStyle = e, this.context.fillRect(t.x - this.game.camera.x, t.y - this.game.camera.y, t.width, t.height)) : (this.context.strokeStyle = e, this.context.strokeRect(t.x - this.game.camera.x, t.y - this.game.camera.y, t.width, t.height)), this.stop()
                            },
                            text: function(t, e, i, s, n) {
                                s = s || "rgb(255,255,255)", n = n || "16px Courier", this.start(), this.context.font = n, this.renderShadow && (this.context.fillStyle = "rgb(0,0,0)", this.context.fillText(t, e + 1, i + 1)), this.context.fillStyle = s, this.context.fillText(t, e, i), this.stop()
                            },
                            quadTree: function(t, e) {
                                e = e || "rgba(255,0,0,0.3)", this.start();
                                var i = t.bounds;
                                if (0 === t.nodes.length) {
                                    this.context.strokeStyle = e, this.context.strokeRect(i.x, i.y, i.width, i.height), this.text("size: " + t.objects.length, i.x + 4, i.y + 16, "rgb(0,200,0)", "12px Courier"), this.context.strokeStyle = "rgb(0,255,0)";
                                    for (var s = 0; s < t.objects.length; s++) this.context.strokeRect(t.objects[s].x, t.objects[s].y, t.objects[s].width, t.objects[s].height)
                                } else
                                    for (var s = 0; s < t.nodes.length; s++) this.quadTree(t.nodes[s]);
                                this.stop()
                            },
                            body: function(t, e, i) {
                                t.body && (t.body.type === n.Physics.ARCADE ? (this.start(), n.Physics.Arcade.Body.render(this.context, t.body, e, i), this.stop()) : t.body.type === n.Physics.NINJA && (this.start(), n.Physics.Ninja.Body.render(this.context, t.body, e, i), this.stop()))
                            },
                            bodyInfo: function(t, e, i, s) {
                                t.body && t.body.type === n.Physics.ARCADE && (this.start(e, i, s, 210), n.Physics.Arcade.Body.renderBodyInfo(this, t.body), this.stop())
                            }
                        }, n.Utils.Debug.prototype.constructor = n.Utils.Debug, n.Color = {
                            packPixel: function(t, e, i, s) {
                                return n.Device.LITTLE_ENDIAN ? (s << 24 | i << 16 | e << 8 | t) >>> 0 : (t << 24 | e << 16 | i << 8 | s) >>> 0
                            },
                            unpackPixel: function(t, e, i, s) {
                                return ("undefined" == typeof e || null === e) && (e = n.Color.createColor()), ("undefined" == typeof i || null === i) && (i = !1), ("undefined" == typeof s || null === s) && (s = !1), n.Device.LITTLE_ENDIAN ? (e.a = (4278190080 & t) >>> 24, e.b = (16711680 & t) >>> 16, e.g = (65280 & t) >>> 8, e.r = 255 & t) : (e.r = (4278190080 & t) >>> 24, e.g = (16711680 & t) >>> 16, e.b = (65280 & t) >>> 8, e.a = 255 & t), e.color = t, e.rgba = "rgba(" + e.r + "," + e.g + "," + e.b + "," + e.a / 255 + ")", i && n.Color.RGBtoHSL(e.r, e.g, e.b, e), s && n.Color.RGBtoHSV(e.r, e.g, e.b, e), e
                            },
                            fromRGBA: function(t, e) {
                                return e || (e = n.Color.createColor()), e.r = (4278190080 & t) >>> 24, e.g = (16711680 & t) >>> 16, e.b = (65280 & t) >>> 8, e.a = 255 & t, e.rgba = "rgba(" + e.r + "," + e.g + "," + e.b + "," + e.a + ")", e
                            },
                            toRGBA: function(t, e, i, s) {
                                return t << 24 | e << 16 | i << 8 | s
                            },
                            RGBtoHSL: function(t, e, i, s) {
                                s || (s = n.Color.createColor(t, e, i, 1)), t /= 255, e /= 255, i /= 255;
                                var r = Math.min(t, e, i),
                                    o = Math.max(t, e, i);
                                if (s.h = 0, s.s = 0, s.l = (o + r) / 2, o !== r) {
                                    var a = o - r;
                                    s.s = s.l > .5 ? a / (2 - o - r) : a / (o + r), o === t ? s.h = (e - i) / a + (i > e ? 6 : 0) : o === e ? s.h = (i - t) / a + 2 : o === i && (s.h = (t - e) / a + 4), s.h /= 6
                                }
                                return s
                            },
                            HSLtoRGB: function(t, e, i, s) {
                                if (s ? (s.r = i, s.g = i, s.b = i) : s = n.Color.createColor(i, i, i), 0 !== e) {
                                    var r = .5 > i ? i * (1 + e) : i + e - i * e,
                                        o = 2 * i - r;
                                    s.r = n.Color.hueToColor(o, r, t + 1 / 3), s.g = n.Color.hueToColor(o, r, t), s.b = n.Color.hueToColor(o, r, t - 1 / 3)
                                }
                                return s.r = Math.floor(255 * s.r | 0), s.g = Math.floor(255 * s.g | 0), s.b = Math.floor(255 * s.b | 0), n.Color.updateColor(s), s
                            },
                            RGBtoHSV: function(t, e, i, s) {
                                s || (s = n.Color.createColor(t, e, i, 255)), t /= 255, e /= 255, i /= 255;
                                var r = Math.min(t, e, i),
                                    o = Math.max(t, e, i),
                                    a = o - r;
                                return s.h = 0, s.s = 0 === o ? 0 : a / o, s.v = o, o !== r && (o === t ? s.h = (e - i) / a + (i > e ? 6 : 0) : o === e ? s.h = (i - t) / a + 2 : o === i && (s.h = (t - e) / a + 4), s.h /= 6), s
                            },
                            HSVtoRGB: function(t, e, i, s) {
                                "undefined" == typeof s && (s = n.Color.createColor(0, 0, 0, 1, t, e, 0, i));
                                var r, o, a, h = Math.floor(6 * t),
                                    l = 6 * t - h,
                                    c = i * (1 - e),
                                    u = i * (1 - l * e),
                                    d = i * (1 - (1 - l) * e);
                                switch (h % 6) {
                                    case 0:
                                        r = i, o = d, a = c;
                                        break;
                                    case 1:
                                        r = u, o = i, a = c;
                                        break;
                                    case 2:
                                        r = c, o = i, a = d;
                                        break;
                                    case 3:
                                        r = c, o = u, a = i;
                                        break;
                                    case 4:
                                        r = d, o = c, a = i;
                                        break;
                                    case 5:
                                        r = i, o = c, a = u
                                }
                                return s.r = Math.floor(255 * r), s.g = Math.floor(255 * o), s.b = Math.floor(255 * a), n.Color.updateColor(s), s
                            },
                            hueToColor: function(t, e, i) {
                                return 0 > i && (i += 1), i > 1 && (i -= 1), 1 / 6 > i ? t + 6 * (e - t) * i : .5 > i ? e : 2 / 3 > i ? t + (e - t) * (2 / 3 - i) * 6 : t
                            },
                            createColor: function(t, e, i, s, n, r, o, a) {
                                var h = {
                                    r: t || 0,
                                    g: e || 0,
                                    b: i || 0,
                                    a: s || 1,
                                    h: n || 0,
                                    s: r || 0,
                                    l: o || 0,
                                    v: a || 0,
                                    color: 0
                                };
                                return h.rgba = "rgba(" + h.r + "," + h.g + "," + h.b + "," + h.a + ")", h
                            },
                            updateColor: function(t) {
                                return t.rgba = "rgba(" + t.r + "," + t.g + "," + t.b + "," + t.a + ")", t
                            },
                            getColor32: function(t, e, i, s) {
                                return t << 24 | e << 16 | i << 8 | s
                            },
                            getColor: function(t, e, i) {
                                return t << 16 | e << 8 | i
                            },
                            RGBtoString: function(t, e, i, s, r) {
                                return "undefined" == typeof s && (s = 255), "undefined" == typeof r && (r = "#"), "#" === r ? "#" + ((1 << 24) + (t << 16) + (e << 8) + i).toString(16).slice(1) : "0x" + n.Color.componentToHex(s) + n.Color.componentToHex(t) + n.Color.componentToHex(e) + n.Color.componentToHex(i)
                            },
                            hexToRGB: function(t) {
                                var e = n.Color.hexToColor(t);
                                return e ? n.Color.getColor32(e.a, e.r, e.g, e.b) : void 0
                            },
                            hexToColor: function(t, e) {
                                e || (e = n.Color.createColor());
                                var i = /^#?([a-f\d])([a-f\d])([a-f\d])$/i;
                                t = t.replace(i, function(t, e, i, s) {
                                    return e + e + i + i + s + s
                                });
                                var s = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(t);
                                return s && (e.r = parseInt(s[1], 16), e.g = parseInt(s[2], 16), e.b = parseInt(s[3], 16)), e
                            },
                            componentToHex: function(t) {
                                var e = t.toString(16);
                                return 1 == e.length ? "0" + e : e
                            },
                            HSVColorWheel: function(t, e) {
                                "undefined" == typeof t && (t = 1), "undefined" == typeof e && (e = 1);
                                for (var i = [], s = 0; 359 >= s; s++) i.push(n.Color.HSVtoRGB(s / 359, t, e));
                                return i
                            },
                            HSLColorWheel: function(t, e) {
                                "undefined" == typeof t && (t = .5), "undefined" == typeof e && (e = .5);
                                for (var i = [], s = 0; 359 >= s; s++) i.push(n.Color.HSLtoRGB(s / 359, t, e));
                                return i
                            },
                            interpolateColor: function(t, e, i, s, r) {
                                "undefined" == typeof r && (r = 255);
                                var o = n.Color.getRGB(t),
                                    a = n.Color.getRGB(e),
                                    h = (a.red - o.red) * s / i + o.red,
                                    l = (a.green - o.green) * s / i + o.green,
                                    c = (a.blue - o.blue) * s / i + o.blue;
                                return n.Color.getColor32(r, h, l, c)
                            },
                            interpolateColorWithRGB: function(t, e, i, s, r, o) {
                                var a = n.Color.getRGB(t),
                                    h = (e - a.red) * o / r + a.red,
                                    l = (i - a.green) * o / r + a.green,
                                    c = (s - a.blue) * o / r + a.blue;
                                return n.Color.getColor(h, l, c)
                            },
                            interpolateRGB: function(t, e, i, s, r, o, a, h) {
                                var l = (s - t) * h / a + t,
                                    c = (r - e) * h / a + e,
                                    u = (o - i) * h / a + i;
                                return n.Color.getColor(l, c, u)
                            },
                            getRandomColor: function(t, e, i) {
                                if ("undefined" == typeof t && (t = 0), "undefined" == typeof e && (e = 255), "undefined" == typeof i && (i = 255), e > 255 || t > e) return n.Color.getColor(255, 255, 255);
                                var s = t + Math.round(Math.random() * (e - t)),
                                    r = t + Math.round(Math.random() * (e - t)),
                                    o = t + Math.round(Math.random() * (e - t));
                                return n.Color.getColor32(i, s, r, o)
                            },
                            getRGB: function(t) {
                                return t > 16777215 ? {
                                    alpha: t >>> 24,
                                    red: t >> 16 & 255,
                                    green: t >> 8 & 255,
                                    blue: 255 & t,
                                    a: t >>> 24,
                                    r: t >> 16 & 255,
                                    g: t >> 8 & 255,
                                    b: 255 & t
                                } : {
                                    alpha: 255,
                                    red: t >> 16 & 255,
                                    green: t >> 8 & 255,
                                    blue: 255 & t,
                                    a: 255,
                                    r: t >> 16 & 255,
                                    g: t >> 8 & 255,
                                    b: 255 & t
                                }
                            },
                            getWebRGB: function(t) {
                                if ("object" == typeof t) return "rgba(" + t.r.toString() + "," + t.g.toString() + "," + t.b.toString() + "," + (t.a / 255).toString() + ")";
                                var e = n.Color.getRGB(t);
                                return "rgba(" + e.r.toString() + "," + e.g.toString() + "," + e.b.toString() + "," + (e.a / 255).toString() + ")"
                            },
                            getAlpha: function(t) {
                                return t >>> 24
                            },
                            getAlphaFloat: function(t) {
                                return (t >>> 24) / 255
                            },
                            getRed: function(t) {
                                return t >> 16 & 255
                            },
                            getGreen: function(t) {
                                return t >> 8 & 255
                            },
                            getBlue: function(t) {
                                return 255 & t
                            },
                            getColorInfo: function(t) {
                                var e = n.Color.getRGB(t),
                                    i = n.Color.RGBtoHexstring(t) + "\n";
                                return i = i.concat("Alpha: " + e.alpha + " Red: " + e.red + " Green: " + e.green + " Blue: " + e.blue) + "\n"
                            },
                            RGBtoHexstring: function(t) {
                                var e = n.Color.getRGB(t);
                                return "0x" + n.Color.colorToHexstring(e.alpha) + n.Color.colorToHexstring(e.red) + n.Color.colorToHexstring(e.green) + n.Color.colorToHexstring(e.blue)
                            },
                            RGBtoWebstring: function(t) {
                                var e = n.Color.getRGB(t);
                                return "#" + n.Color.colorToHexstring(e.red) + n.Color.colorToHexstring(e.green) + n.Color.colorToHexstring(e.blue)
                            },
                            colorToHexstring: function(t) {
                                var e = "0123456789ABCDEF",
                                    i = t % 16,
                                    s = (t - i) / 16,
                                    n = e.charAt(s) + e.charAt(i);
                                return n
                            }
                        }, n.Physics = function(t, e) {
                            e = e || {}, this.game = t, this.config = e, this.arcade = null, this.p2 = null, this.ninja = null, this.box2d = null, this.chipmunk = null, this.parseConfig()
                        }, n.Physics.ARCADE = 0, n.Physics.P2JS = 1, n.Physics.NINJA = 2, n.Physics.BOX2D = 3, n.Physics.CHIPMUNK = 5, n.Physics.prototype = {
                            parseConfig: function() {
                                this.config.hasOwnProperty("arcade") && this.config.arcade !== !0 || !n.Physics.hasOwnProperty("Arcade") || (this.arcade = new n.Physics.Arcade(this.game), this.game.time.deltaCap = .2), this.config.hasOwnProperty("ninja") && this.config.ninja === !0 && n.Physics.hasOwnProperty("Ninja") && (this.ninja = new n.Physics.Ninja(this.game)), this.config.hasOwnProperty("p2") && this.config.p2 === !0 && n.Physics.hasOwnProperty("P2") && (this.p2 = new n.Physics.P2(this.game, this.config))
                            },
                            startSystem: function(t) {
                                if (t === n.Physics.ARCADE ? this.arcade = new n.Physics.Arcade(this.game) : t === n.Physics.P2JS && (this.p2 = new n.Physics.P2(this.game, this.config)), t === n.Physics.NINJA) this.ninja = new n.Physics.Ninja(this.game);
                                else {
                                    if (t === n.Physics.BOX2D && null === this.box2d) throw new Error("The Box2D physics system has not been implemented yet.");
                                    if (t === n.Physics.CHIPMUNK && null === this.chipmunk) throw new Error("The Chipmunk physics system has not been implemented yet.")
                                }
                                this.setBoundsToWorld()
                            },
                            enable: function(t, e, i) {
                                "undefined" == typeof e && (e = n.Physics.ARCADE), "undefined" == typeof i && (i = !1), e === n.Physics.ARCADE ? this.arcade.enable(t) : e === n.Physics.P2JS && this.p2 ? this.p2.enable(t, i) : e === n.Physics.NINJA && this.ninja && this.ninja.enableAABB(t)
                            },
                            preUpdate: function() {
                                this.p2 && this.p2.preUpdate()
                            },
                            update: function() {
                                this.p2 && this.p2.update()
                            },
                            setBoundsToWorld: function() {
                                this.arcade && this.arcade.setBoundsToWorld(), this.ninja && this.ninja.setBoundsToWorld(), this.p2 && this.p2.setBoundsToWorld()
                            },
                            clear: function() {
                                this.p2 && this.p2.clear()
                            },
                            destroy: function() {
                                this.p2 && this.p2.destroy(), this.arcade = null, this.ninja = null, this.p2 = null
                            }
                        }, n.Physics.prototype.constructor = n.Physics, n.Physics.Arcade = function(t) {
                            this.game = t, this.gravity = new n.Point, this.bounds = new n.Rectangle(0, 0, t.world.width, t.world.height), this.checkCollision = {
                                up: !0,
                                down: !0,
                                left: !0,
                                right: !0
                            }, this.maxObjects = 10, this.maxLevels = 4, this.OVERLAP_BIAS = 4, this.TILE_BIAS = 16, this.forceX = !1, this.quadTree = new n.QuadTree(this.game.world.bounds.x, this.game.world.bounds.y, this.game.world.bounds.width, this.game.world.bounds.height, this.maxObjects, this.maxLevels), this._overlap = 0, this._maxOverlap = 0, this._velocity1 = 0, this._velocity2 = 0, this._newVelocity1 = 0, this._newVelocity2 = 0, this._average = 0, this._mapData = [], this._result = !1, this._total = 0, this._angle = 0, this._dx = 0, this._dy = 0
                        }, n.Physics.Arcade.prototype.constructor = n.Physics.Arcade, n.Physics.Arcade.prototype = {
                            setBounds: function(t, e, i, s) {
                                this.bounds.setTo(t, e, i, s)
                            },
                            setBoundsToWorld: function() {
                                this.bounds.setTo(this.game.world.bounds.x, this.game.world.bounds.y, this.game.world.bounds.width, this.game.world.bounds.height)
                            },
                            enable: function(t, e) {
                                "undefined" == typeof e && (e = !0);
                                var i = 1;
                                if (Array.isArray(t))
                                    for (i = t.length; i--;) t[i] instanceof n.Group ? this.enable(t[i].children, e) : (this.enableBody(t[i]), e && t[i].hasOwnProperty("children") && t[i].children.length > 0 && this.enable(t[i], !0));
                                else t instanceof n.Group ? this.enable(t.children, e) : (this.enableBody(t), e && t.hasOwnProperty("children") && t.children.length > 0 && this.enable(t.children, !0))
                            },
                            enableBody: function(t) {
                                t.hasOwnProperty("body") && null === t.body && (t.body = new n.Physics.Arcade.Body(t))
                            },
                            updateMotion: function(t) {
                                this._velocityDelta = this.computeVelocity(0, t, t.angularVelocity, t.angularAcceleration, t.angularDrag, t.maxAngular) - t.angularVelocity, t.angularVelocity += this._velocityDelta, t.rotation += t.angularVelocity * this.game.time.physicsElapsed, t.velocity.x = this.computeVelocity(1, t, t.velocity.x, t.acceleration.x, t.drag.x, t.maxVelocity.x), t.velocity.y = this.computeVelocity(2, t, t.velocity.y, t.acceleration.y, t.drag.y, t.maxVelocity.y)
                            },
                            computeVelocity: function(t, e, i, s, n, r) {
                                return r = r || 1e4, 1 == t && e.allowGravity ? i += (this.gravity.x + e.gravity.x) * this.game.time.physicsElapsed : 2 == t && e.allowGravity && (i += (this.gravity.y + e.gravity.y) * this.game.time.physicsElapsed), s ? i += s * this.game.time.physicsElapsed : n && (this._drag = n * this.game.time.physicsElapsed, i - this._drag > 0 ? i -= this._drag : i + this._drag < 0 ? i += this._drag : i = 0), i > r ? i = r : -r > i && (i = -r), i
                            },
                            overlap: function(t, e, i, s, n) {
                                if (i = i || null, s = s || null, n = n || i, this._result = !1, this._total = 0, Array.isArray(e))
                                    for (var r = 0, o = e.length; o > r; r++) this.collideHandler(t, e[r], i, s, n, !0);
                                else this.collideHandler(t, e, i, s, n, !0);
                                return this._total > 0
                            },
                            collide: function(t, e, i, s, n) {
                                if (i = i || null, s = s || null, n = n || i, this._result = !1, this._total = 0, Array.isArray(e))
                                    for (var r = 0, o = e.length; o > r; r++) this.collideHandler(t, e[r], i, s, n, !1);
                                else this.collideHandler(t, e, i, s, n, !1);
                                return this._total > 0
                            },
                            collideHandler: function(t, e, i, s, r, o) {
                                return "undefined" != typeof e || t.type !== n.GROUP && t.type !== n.EMITTER ? void(t && e && t.exists && e.exists && (t.type == n.SPRITE || t.type == n.TILESPRITE ? e.type == n.SPRITE || e.type == n.TILESPRITE ? this.collideSpriteVsSprite(t, e, i, s, r, o) : e.type == n.GROUP || e.type == n.EMITTER ? this.collideSpriteVsGroup(t, e, i, s, r, o) : e.type == n.TILEMAPLAYER && this.collideSpriteVsTilemapLayer(t, e, i, s, r) : t.type == n.GROUP ? e.type == n.SPRITE || e.type == n.TILESPRITE ? this.collideSpriteVsGroup(e, t, i, s, r, o) : e.type == n.GROUP || e.type == n.EMITTER ? this.collideGroupVsGroup(t, e, i, s, r, o) : e.type == n.TILEMAPLAYER && this.collideGroupVsTilemapLayer(t, e, i, s, r) : t.type == n.TILEMAPLAYER ? e.type == n.SPRITE || e.type == n.TILESPRITE ? this.collideSpriteVsTilemapLayer(e, t, i, s, r) : (e.type == n.GROUP || e.type == n.EMITTER) && this.collideGroupVsTilemapLayer(e, t, i, s, r) : t.type == n.EMITTER && (e.type == n.SPRITE || e.type == n.TILESPRITE ? this.collideSpriteVsGroup(e, t, i, s, r, o) : e.type == n.GROUP || e.type == n.EMITTER ? this.collideGroupVsGroup(t, e, i, s, r, o) : e.type == n.TILEMAPLAYER && this.collideGroupVsTilemapLayer(t, e, i, s, r)))) : void this.collideGroupVsSelf(t, i, s, r, o)
                            },
                            collideSpriteVsSprite: function(t, e, i, s, n, r) {
                                return t.body && e.body ? (this.separate(t.body, e.body, s, n, r) && (i && i.call(n, t, e), this._total++), !0) : !1
                            },
                            collideSpriteVsGroup: function(t, e, i, s, n, r) {
                                if (0 !== e.length && t.body) {
                                    this.quadTree.clear(), this.quadTree.reset(this.game.world.bounds.x, this.game.world.bounds.y, this.game.world.bounds.width, this.game.world.bounds.height, this.maxObjects, this.maxLevels), this.quadTree.populate(e), this._potentials = this.quadTree.retrieve(t);
                                    for (var o = 0, a = this._potentials.length; a > o; o++) this.separate(t.body, this._potentials[o], s, n, r) && (i && i.call(n, t, this._potentials[o].sprite), this._total++)
                                }
                            },
                            collideGroupVsSelf: function(t, e, i, s, n) {
                                if (0 !== t.length)
                                    for (var r = t.children.length, o = 0; r > o; o++)
                                        for (var a = o + 1; r >= a; a++) t.children[o] && t.children[a] && t.children[o].exists && t.children[a].exists && this.collideSpriteVsSprite(t.children[o], t.children[a], e, i, s, n)
                            },
                            collideGroupVsGroup: function(t, e, i, s, n, r) {
                                if (0 !== t.length && 0 !== e.length)
                                    for (var o = 0, a = t.children.length; a > o; o++) t.children[o].exists && this.collideSpriteVsGroup(t.children[o], e, i, s, n, r)
                            },
                            collideSpriteVsTilemapLayer: function(t, e, i, s, n) {
                                if (t.body && (this._mapData = e.getTiles(t.body.position.x - t.body.tilePadding.x, t.body.position.y - t.body.tilePadding.y, t.body.width + t.body.tilePadding.x, t.body.height + t.body.tilePadding.y, !1, !1), 0 !== this._mapData.length))
                                    for (var r = 0; r < this._mapData.length; r++) s ? s.call(n, t, this._mapData[r]) && this.separateTile(r, t.body, this._mapData[r]) && (this._total++, i && i.call(n, t, this._mapData[r])) : this.separateTile(r, t.body, this._mapData[r]) && (this._total++, i && i.call(n, t, this._mapData[r]))
                            },
                            collideGroupVsTilemapLayer: function(t, e, i, s, n) {
                                if (0 !== t.length)
                                    for (var r = 0, o = t.children.length; o > r; r++) t.children[r].exists && this.collideSpriteVsTilemapLayer(t.children[r], e, i, s, n)
                            },
                            separate: function(t, e, i, s, n) {
                                return t.enable && e.enable && this.intersects(t, e) ? i && i.call(s, t.sprite, e.sprite) === !1 ? !1 : n ? !0 : (this._result = this.forceX || Math.abs(this.gravity.y + t.gravity.y) < Math.abs(this.gravity.x + t.gravity.x) ? this.separateX(t, e, n) || this.separateY(t, e, n) : this.separateY(t, e, n) || this.separateX(t, e, n), this._result) : !1
                            },
                            intersects: function(t, e) {
                                return t.right <= e.position.x ? !1 : t.bottom <= e.position.y ? !1 : t.position.x >= e.right ? !1 : t.position.y >= e.bottom ? !1 : !0
                            },
                            separateX: function(t, e, i) {
                                return t.immovable && e.immovable ? !1 : (this._overlap = 0, this.intersects(t, e) && (this._maxOverlap = t.deltaAbsX() + e.deltaAbsX() + this.OVERLAP_BIAS, 0 === t.deltaX() && 0 === e.deltaX() ? (t.embedded = !0, e.embedded = !0) : t.deltaX() > e.deltaX() ? (this._overlap = t.right - e.x, this._overlap > this._maxOverlap || t.checkCollision.right === !1 || e.checkCollision.left === !1 ? this._overlap = 0 : (t.touching.none = !1, t.touching.right = !0, e.touching.none = !1, e.touching.left = !0)) : t.deltaX() < e.deltaX() && (this._overlap = t.x - e.width - e.x, -this._overlap > this._maxOverlap || t.checkCollision.left === !1 || e.checkCollision.right === !1 ? this._overlap = 0 : (t.touching.none = !1, t.touching.left = !0, e.touching.none = !1, e.touching.right = !0)), 0 !== this._overlap) ? (t.overlapX = this._overlap, e.overlapX = this._overlap, i || t.customSeparateX || e.customSeparateX ? !0 : (this._velocity1 = t.velocity.x, this._velocity2 = e.velocity.x, t.immovable || e.immovable ? t.immovable ? e.immovable || (e.x += this._overlap, e.velocity.x = this._velocity1 - this._velocity2 * e.bounce.x) : (t.x = t.x - this._overlap, t.velocity.x = this._velocity2 - this._velocity1 * t.bounce.x) : (this._overlap *= .5, t.x = t.x - this._overlap, e.x += this._overlap, this._newVelocity1 = Math.sqrt(this._velocity2 * this._velocity2 * e.mass / t.mass) * (this._velocity2 > 0 ? 1 : -1), this._newVelocity2 = Math.sqrt(this._velocity1 * this._velocity1 * t.mass / e.mass) * (this._velocity1 > 0 ? 1 : -1), this._average = .5 * (this._newVelocity1 + this._newVelocity2), this._newVelocity1 -= this._average, this._newVelocity2 -= this._average, t.velocity.x = this._average + this._newVelocity1 * t.bounce.x, e.velocity.x = this._average + this._newVelocity2 * e.bounce.x), !0)) : !1)
                            },
                            separateY: function(t, e, i) {
                                return t.immovable && e.immovable ? !1 : (this._overlap = 0, this.intersects(t, e) && (this._maxOverlap = t.deltaAbsY() + e.deltaAbsY() + this.OVERLAP_BIAS, 0 === t.deltaY() && 0 === e.deltaY() ? (t.embedded = !0, e.embedded = !0) : t.deltaY() > e.deltaY() ? (this._overlap = t.bottom - e.y, this._overlap > this._maxOverlap || t.checkCollision.down === !1 || e.checkCollision.up === !1 ? this._overlap = 0 : (t.touching.none = !1, t.touching.down = !0, e.touching.none = !1, e.touching.up = !0)) : t.deltaY() < e.deltaY() && (this._overlap = t.y - e.bottom, -this._overlap > this._maxOverlap || t.checkCollision.up === !1 || e.checkCollision.down === !1 ? this._overlap = 0 : (t.touching.none = !1, t.touching.up = !0, e.touching.none = !1, e.touching.down = !0)), 0 !== this._overlap) ? (t.overlapY = this._overlap, e.overlapY = this._overlap, i || t.customSeparateY || e.customSeparateY ? !0 : (this._velocity1 = t.velocity.y, this._velocity2 = e.velocity.y, t.immovable || e.immovable ? t.immovable ? e.immovable || (e.y += this._overlap, e.velocity.y = this._velocity1 - this._velocity2 * e.bounce.y, t.moves && (e.x += t.x - t.prev.x)) : (t.y = t.y - this._overlap, t.velocity.y = this._velocity2 - this._velocity1 * t.bounce.y, e.moves && (t.x += e.x - e.prev.x)) : (this._overlap *= .5, t.y = t.y - this._overlap, e.y += this._overlap, this._newVelocity1 = Math.sqrt(this._velocity2 * this._velocity2 * e.mass / t.mass) * (this._velocity2 > 0 ? 1 : -1), this._newVelocity2 = Math.sqrt(this._velocity1 * this._velocity1 * t.mass / e.mass) * (this._velocity1 > 0 ? 1 : -1), this._average = .5 * (this._newVelocity1 + this._newVelocity2), this._newVelocity1 -= this._average, this._newVelocity2 -= this._average, t.velocity.y = this._average + this._newVelocity1 * t.bounce.y, e.velocity.y = this._average + this._newVelocity2 * e.bounce.y), !0)) : !1)
                            },
                            separateTile: function(t, e, i) {
                                if (!e.enable || !i.intersects(e.position.x, e.position.y, e.right, e.bottom)) return !1;
                                if (i.collisionCallback && !i.collisionCallback.call(i.collisionCallbackContext, e.sprite, i)) return !1;
                                if (i.layer.callbacks[i.index] && !i.layer.callbacks[i.index].callback.call(i.layer.callbacks[i.index].callbackContext, e.sprite, i)) return !1;
                                if (!(i.faceLeft || i.faceRight || i.faceTop || i.faceBottom)) return !1;
                                var s = 0,
                                    n = 0,
                                    r = 0,
                                    o = 1;
                                if (e.deltaAbsX() > e.deltaAbsY() ? r = -1 : e.deltaAbsX() < e.deltaAbsY() && (o = -1), 0 !== e.deltaX() && 0 !== e.deltaY() && (i.faceLeft || i.faceRight) && (i.faceTop || i.faceBottom) && (r = Math.min(Math.abs(e.position.x - i.right), Math.abs(e.right - i.left)), o = Math.min(Math.abs(e.position.y - i.bottom), Math.abs(e.bottom - i.top))), o > r) {
                                    if ((i.faceLeft || i.faceRight) && (s = this.tileCheckX(e, i), 0 !== s && !i.intersects(e.position.x, e.position.y, e.right, e.bottom))) return !0;
                                    (i.faceTop || i.faceBottom) && (n = this.tileCheckY(e, i))
                                } else {
                                    if ((i.faceTop || i.faceBottom) && (n = this.tileCheckY(e, i), 0 !== n && !i.intersects(e.position.x, e.position.y, e.right, e.bottom))) return !0;
                                    (i.faceLeft || i.faceRight) && (s = this.tileCheckX(e, i))
                                }
                                return 0 !== s || 0 !== n
                            },
                            tileCheckX: function(t, e) {
                                var i = 0;
                                return t.deltaX() < 0 && !t.blocked.left && e.collideRight && t.checkCollision.left ? e.faceRight && t.x < e.right && (i = t.x - e.right, i < -this.TILE_BIAS && (i = 0)) : t.deltaX() > 0 && !t.blocked.right && e.collideLeft && t.checkCollision.right && e.faceLeft && t.right > e.left && (i = t.right - e.left, i > this.TILE_BIAS && (i = 0)), 0 !== i && this.processTileSeparationX(t, i), i
                            },
                            tileCheckY: function(t, e) {
                                var i = 0;
                                return t.deltaY() < 0 && !t.blocked.up && e.collideDown && t.checkCollision.up ? e.faceBottom && t.y < e.bottom && (i = t.y - e.bottom, i < -this.TILE_BIAS && (i = 0)) : t.deltaY() > 0 && !t.blocked.down && e.collideUp && t.checkCollision.down && e.faceTop && t.bottom > e.top && (i = t.bottom - e.top, i > this.TILE_BIAS && (i = 0)), 0 !== i && this.processTileSeparationY(t, i), i
                            },
                            processTileSeparationX: function(t, e) {
                                0 > e ? t.blocked.left = !0 : e > 0 && (t.blocked.right = !0), t.position.x -= e, t.velocity.x = 0 === t.bounce.x ? 0 : -t.velocity.x * t.bounce.x
                            },
                            processTileSeparationY: function(t, e) {
                                0 > e ? t.blocked.up = !0 : e > 0 && (t.blocked.down = !0), t.position.y -= e, t.velocity.y = 0 === t.bounce.y ? 0 : -t.velocity.y * t.bounce.y
                            },
                            getObjectsUnderPointer: function(t, e, i, s) {
                                if (0 !== e.length && t.exists) {
                                    this.quadTree.clear(), this.quadTree.reset(this.game.world.bounds.x, this.game.world.bounds.y, this.game.world.bounds.width, this.game.world.bounds.height, this.maxObjects, this.maxLevels), this.quadTree.populate(e);
                                    var r = new n.Rectangle(t.x, t.y, 1, 1),
                                        o = [];
                                    this._potentials = this.quadTree.retrieve(r);
                                    for (var a = 0, h = this._potentials.length; h > a; a++) this._potentials[a].hitTest(t.x, t.y) && (i && i.call(s, t, this._potentials[a].sprite), o.push(this._potentials[a].sprite));
                                    return o
                                }
                            },
                            moveToObject: function(t, e, i, s) {
                                return "undefined" == typeof i && (i = 60), "undefined" == typeof s && (s = 0), this._angle = Math.atan2(e.y - t.y, e.x - t.x), s > 0 && (i = this.distanceBetween(t, e) / (s / 1e3)), t.body.velocity.x = Math.cos(this._angle) * i, t.body.velocity.y = Math.sin(this._angle) * i, this._angle
                            },
                            moveToPointer: function(t, e, i, s) {
                                return "undefined" == typeof e && (e = 60), i = i || this.game.input.activePointer, "undefined" == typeof s && (s = 0), this._angle = this.angleToPointer(t, i), s > 0 && (e = this.distanceToPointer(t, i) / (s / 1e3)), t.body.velocity.x = Math.cos(this._angle) * e, t.body.velocity.y = Math.sin(this._angle) * e, this._angle
                            },
                            moveToXY: function(t, e, i, s, n) {
                                return "undefined" == typeof s && (s = 60), "undefined" == typeof n && (n = 0), this._angle = Math.atan2(i - t.y, e - t.x), n > 0 && (s = this.distanceToXY(t, e, i) / (n / 1e3)), t.body.velocity.x = Math.cos(this._angle) * s, t.body.velocity.y = Math.sin(this._angle) * s, this._angle
                            },
                            velocityFromAngle: function(t, e, i) {
                                return "undefined" == typeof e && (e = 60), i = i || new n.Point, i.setTo(Math.cos(this.game.math.degToRad(t)) * e, Math.sin(this.game.math.degToRad(t)) * e)
                            },
                            velocityFromRotation: function(t, e, i) {
                                return "undefined" == typeof e && (e = 60), i = i || new n.Point, i.setTo(Math.cos(t) * e, Math.sin(t) * e)
                            },
                            accelerationFromRotation: function(t, e, i) {
                                return "undefined" == typeof e && (e = 60), i = i || new n.Point, i.setTo(Math.cos(t) * e, Math.sin(t) * e)
                            },
                            accelerateToObject: function(t, e, i, s, n) {
                                return "undefined" == typeof i && (i = 60), "undefined" == typeof s && (s = 1e3), "undefined" == typeof n && (n = 1e3), this._angle = this.angleBetween(t, e), t.body.acceleration.setTo(Math.cos(this._angle) * i, Math.sin(this._angle) * i), t.body.maxVelocity.setTo(s, n), this._angle
                            },
                            accelerateToPointer: function(t, e, i, s, n) {
                                return "undefined" == typeof i && (i = 60), "undefined" == typeof e && (e = this.game.input.activePointer), "undefined" == typeof s && (s = 1e3), "undefined" == typeof n && (n = 1e3), this._angle = this.angleToPointer(t, e), t.body.acceleration.setTo(Math.cos(this._angle) * i, Math.sin(this._angle) * i), t.body.maxVelocity.setTo(s, n), this._angle
                            },
                            accelerateToXY: function(t, e, i, s, n, r) {
                                return "undefined" == typeof s && (s = 60), "undefined" == typeof n && (n = 1e3), "undefined" == typeof r && (r = 1e3), this._angle = this.angleToXY(t, e, i), t.body.acceleration.setTo(Math.cos(this._angle) * s, Math.sin(this._angle) * s), t.body.maxVelocity.setTo(n, r), this._angle
                            },
                            distanceBetween: function(t, e) {
                                return this._dx = t.x - e.x, this._dy = t.y - e.y, Math.sqrt(this._dx * this._dx + this._dy * this._dy)
                            },
                            distanceToXY: function(t, e, i) {
                                return this._dx = t.x - e, this._dy = t.y - i, Math.sqrt(this._dx * this._dx + this._dy * this._dy)
                            },
                            distanceToPointer: function(t, e) {
                                return e = e || this.game.input.activePointer, this._dx = t.x - e.x, this._dy = t.y - e.y, Math.sqrt(this._dx * this._dx + this._dy * this._dy)
                            },
                            angleBetween: function(t, e) {
                                return this._dx = e.x - t.x, this._dy = e.y - t.y, Math.atan2(this._dy, this._dx)
                            },
                            angleToXY: function(t, e, i) {
                                return this._dx = e - t.x, this._dy = i - t.y, Math.atan2(this._dy, this._dx)
                            },
                            angleToPointer: function(t, e) {
                                return e = e || this.game.input.activePointer, this._dx = e.worldX - t.x, this._dy = e.worldY - t.y, Math.atan2(this._dy, this._dx)
                            }
                        }, n.Physics.Arcade.Body = function(t) {
                            this.sprite = t, this.game = t.game, this.type = n.Physics.ARCADE, this.enable = !0, this.offset = new n.Point, this.position = new n.Point(t.x, t.y), this.prev = new n.Point(this.position.x, this.position.y), this.allowRotation = !0, this.rotation = t.rotation, this.preRotation = t.rotation, this.sourceWidth = t.texture.frame.width, this.sourceHeight = t.texture.frame.height, this.width = t.width, this.height = t.height, this.halfWidth = Math.abs(t.width / 2), this.halfHeight = Math.abs(t.height / 2), this.center = new n.Point(t.x + this.halfWidth, t.y + this.halfHeight), this.velocity = new n.Point, this.newVelocity = new n.Point(0, 0), this.deltaMax = new n.Point(0, 0), this.acceleration = new n.Point, this.drag = new n.Point, this.allowGravity = !0, this.gravity = new n.Point(0, 0), this.bounce = new n.Point, this.maxVelocity = new n.Point(1e4, 1e4), this.angularVelocity = 0, this.angularAcceleration = 0, this.angularDrag = 0, this.maxAngular = 1e3, this.mass = 1, this.angle = 0, this.speed = 0, this.facing = n.NONE, this.immovable = !1, this.moves = !0, this.customSeparateX = !1, this.customSeparateY = !1, this.overlapX = 0, this.overlapY = 0, this.embedded = !1, this.collideWorldBounds = !1, this.checkCollision = {
                                none: !1,
                                any: !0,
                                up: !0,
                                down: !0,
                                left: !0,
                                right: !0
                            }, this.touching = {
                                none: !0,
                                up: !1,
                                down: !1,
                                left: !1,
                                right: !1
                            }, this.wasTouching = {
                                none: !0,
                                up: !1,
                                down: !1,
                                left: !1,
                                right: !1
                            }, this.blocked = {
                                up: !1,
                                down: !1,
                                left: !1,
                                right: !1
                            }, this.tilePadding = new n.Point, this.phase = 0, this._reset = !0, this._sx = t.scale.x, this._sy = t.scale.y, this._dx = 0, this._dy = 0
                        }, n.Physics.Arcade.Body.prototype = {
                            updateBounds: function() {
                                var t = Math.abs(this.sprite.scale.x),
                                    e = Math.abs(this.sprite.scale.y);
                                (t !== this._sx || e !== this._sy) && (this.width = this.sourceWidth * t, this.height = this.sourceHeight * e, this.halfWidth = Math.floor(this.width / 2), this.halfHeight = Math.floor(this.height / 2), this._sx = t, this._sy = e, this.center.setTo(this.position.x + this.halfWidth, this.position.y + this.halfHeight), this._reset = !0)
                            },
                            preUpdate: function() {
                                this.enable && (this.phase = 1, this.wasTouching.none = this.touching.none, this.wasTouching.up = this.touching.up, this.wasTouching.down = this.touching.down, this.wasTouching.left = this.touching.left, this.wasTouching.right = this.touching.right, this.touching.none = !0, this.touching.up = !1, this.touching.down = !1, this.touching.left = !1, this.touching.right = !1, this.blocked.up = !1, this.blocked.down = !1, this.blocked.left = !1, this.blocked.right = !1, this.embedded = !1, this.updateBounds(), this.position.x = this.sprite.world.x - this.sprite.anchor.x * this.width + this.offset.x, this.position.y = this.sprite.world.y - this.sprite.anchor.y * this.height + this.offset.y, this.rotation = this.sprite.angle, this.preRotation = this.rotation, (this._reset || 1 === this.sprite._cache[4]) && (this.prev.x = this.position.x, this.prev.y = this.position.y), this.moves && (this.game.physics.arcade.updateMotion(this), this.newVelocity.set(this.velocity.x * this.game.time.physicsElapsed, this.velocity.y * this.game.time.physicsElapsed), this.position.x += this.newVelocity.x, this.position.y += this.newVelocity.y, (this.position.x !== this.prev.x || this.position.y !== this.prev.y) && (this.speed = Math.sqrt(this.velocity.x * this.velocity.x + this.velocity.y * this.velocity.y), this.angle = Math.atan2(this.velocity.y, this.velocity.x)), this.collideWorldBounds && this.checkWorldBounds()), this._dx = this.deltaX(), this._dy = this.deltaY(), this._reset = !1)
                            },
                            postUpdate: function() {
                                this.enable && 2 !== this.phase && (this.phase = 2, this.deltaX() < 0 ? this.facing = n.LEFT : this.deltaX() > 0 && (this.facing = n.RIGHT), this.deltaY() < 0 ? this.facing = n.UP : this.deltaY() > 0 && (this.facing = n.DOWN), this.moves && (this._dx = this.deltaX(), this._dy = this.deltaY(), 0 !== this.deltaMax.x && 0 !== this._dx && (this._dx < 0 && this._dx < -this.deltaMax.x ? this._dx = -this.deltaMax.x : this._dx > 0 && this._dx > this.deltaMax.x && (this._dx = this.deltaMax.x)), 0 !== this.deltaMax.y && 0 !== this._dy && (this._dy < 0 && this._dy < -this.deltaMax.y ? this._dy = -this.deltaMax.y : this._dy > 0 && this._dy > this.deltaMax.y && (this._dy = this.deltaMax.y)), this.sprite.x += this._dx, this.sprite.y += this._dy), this.center.setTo(this.position.x + this.halfWidth, this.position.y + this.halfHeight), this.allowRotation && (this.sprite.angle += this.deltaZ()), this.prev.x = this.position.x, this.prev.y = this.position.y)
                            },
                            destroy: function() {
                                this.sprite = null
                            },
                            checkWorldBounds: function() {
                                this.position.x < this.game.physics.arcade.bounds.x && this.game.physics.arcade.checkCollision.left ? (this.position.x = this.game.physics.arcade.bounds.x, this.velocity.x *= -this.bounce.x, this.blocked.left = !0) : this.right > this.game.physics.arcade.bounds.right && this.game.physics.arcade.checkCollision.right && (this.position.x = this.game.physics.arcade.bounds.right - this.width, this.velocity.x *= -this.bounce.x, this.blocked.right = !0), this.position.y < this.game.physics.arcade.bounds.y && this.game.physics.arcade.checkCollision.up ? (this.position.y = this.game.physics.arcade.bounds.y, this.velocity.y *= -this.bounce.y, this.blocked.up = !0) : this.bottom > this.game.physics.arcade.bounds.bottom && this.game.physics.arcade.checkCollision.down && (this.position.y = this.game.physics.arcade.bounds.bottom - this.height, this.velocity.y *= -this.bounce.y, this.blocked.down = !0)
                            },
                            setSize: function(t, e, i, s) {
                                "undefined" == typeof i && (i = this.offset.x), "undefined" == typeof s && (s = this.offset.y), this.sourceWidth = t, this.sourceHeight = e, this.width = this.sourceWidth * this._sx, this.height = this.sourceHeight * this._sy, this.halfWidth = Math.floor(this.width / 2), this.halfHeight = Math.floor(this.height / 2), this.offset.setTo(i, s), this.center.setTo(this.position.x + this.halfWidth, this.position.y + this.halfHeight)
                            },
                            reset: function(t, e) {
                                this.velocity.set(0), this.acceleration.set(0), this.angularVelocity = 0, this.angularAcceleration = 0, this.position.x = t - this.sprite.anchor.x * this.width + this.offset.x, this.position.y = e - this.sprite.anchor.y * this.height + this.offset.y, this.prev.x = this.position.x, this.prev.y = this.position.y, this.rotation = this.sprite.angle, this.preRotation = this.rotation, this._sx = this.sprite.scale.x, this._sy = this.sprite.scale.y, this.center.setTo(this.position.x + this.halfWidth, this.position.y + this.halfHeight)
                            },
                            hitTest: function(t, e) {
                                return n.Rectangle.contains(this, t, e)
                            },
                            onFloor: function() {
                                return this.blocked.down
                            },
                            onWall: function() {
                                return this.blocked.left || this.blocked.right
                            },
                            deltaAbsX: function() {
                                return this.deltaX() > 0 ? this.deltaX() : -this.deltaX()
                            },
                            deltaAbsY: function() {
                                return this.deltaY() > 0 ? this.deltaY() : -this.deltaY()
                            },
                            deltaX: function() {
                                return this.position.x - this.prev.x
                            },
                            deltaY: function() {
                                return this.position.y - this.prev.y
                            },
                            deltaZ: function() {
                                return this.rotation - this.preRotation
                            }
                        }, Object.defineProperty(n.Physics.Arcade.Body.prototype, "bottom", {
                            get: function() {
                                return this.position.y + this.height
                            }
                        }), Object.defineProperty(n.Physics.Arcade.Body.prototype, "right", {
                            get: function() {
                                return this.position.x + this.width
                            }
                        }), Object.defineProperty(n.Physics.Arcade.Body.prototype, "x", {
                            get: function() {
                                return this.position.x
                            },
                            set: function(t) {
                                this.position.x = t
                            }
                        }), Object.defineProperty(n.Physics.Arcade.Body.prototype, "y", {
                            get: function() {
                                return this.position.y
                            },
                            set: function(t) {
                                this.position.y = t
                            }
                        }), n.Physics.Arcade.Body.render = function(t, e, i, s) {
                            "undefined" == typeof s && (s = !0), i = i || "rgba(0,255,0,0.4)", s ? (t.fillStyle = i, t.fillRect(e.position.x - e.game.camera.x, e.position.y - e.game.camera.y, e.width, e.height)) : (t.strokeStyle = i, t.strokeRect(e.position.x - e.game.camera.x, e.position.y - e.game.camera.y, e.width, e.height))
                        }, n.Physics.Arcade.Body.renderBodyInfo = function(t, e) {
                            t.line("x: " + e.x.toFixed(2), "y: " + e.y.toFixed(2), "width: " + e.width, "height: " + e.height), t.line("velocity x: " + e.velocity.x.toFixed(2), "y: " + e.velocity.y.toFixed(2), "deltaX: " + e._dx.toFixed(2), "deltaY: " + e._dy.toFixed(2)), t.line("acceleration x: " + e.acceleration.x.toFixed(2), "y: " + e.acceleration.y.toFixed(2), "speed: " + e.speed.toFixed(2), "angle: " + e.angle.toFixed(2)), t.line("gravity x: " + e.gravity.x, "y: " + e.gravity.y, "bounce x: " + e.bounce.x.toFixed(2), "y: " + e.bounce.y.toFixed(2)), t.line("touching left: " + e.touching.left, "right: " + e.touching.right, "up: " + e.touching.up, "down: " + e.touching.down), t.line("blocked left: " + e.blocked.left, "right: " + e.blocked.right, "up: " + e.blocked.up, "down: " + e.blocked.down)
                        }, n.Physics.Arcade.Body.prototype.constructor = n.Physics.Arcade.Body, n.Particles = function(t) {
                            this.game = t, this.emitters = {}, this.ID = 0
                        }, n.Particles.prototype = {
                            add: function(t) {
                                return this.emitters[t.name] = t, t
                            },
                            remove: function(t) {
                                delete this.emitters[t.name]
                            },
                            update: function() {
                                for (var t in this.emitters) this.emitters[t].exists && this.emitters[t].update()
                            }
                        }, n.Particles.prototype.constructor = n.Particles, n.Particles.Arcade = {}, n.Particles.Arcade.Emitter = function(t, e, i, s) {
                            this.maxParticles = s || 50, n.Group.call(this, t), this.name = "emitter" + this.game.particles.ID++, this.type = n.EMITTER, this.area = new n.Rectangle(e, i, 1, 1), this.minParticleSpeed = new n.Point(-100, -100), this.maxParticleSpeed = new n.Point(100, 100), this.minParticleScale = 1, this.maxParticleScale = 1, this.scaleData = null, this.minRotation = -360, this.maxRotation = 360, this.minParticleAlpha = 1, this.maxParticleAlpha = 1, this.alphaData = null, this.gravity = 100, this.particleClass = n.Particle, this.particleDrag = new n.Point, this.angularDrag = 0, this.frequency = 100, this.lifespan = 2e3, this.bounce = new n.Point, this.on = !1, this.particleAnchor = new n.Point(.5, .5), this.blendMode = n.blendModes.NORMAL, this.emitX = e, this.emitY = i, this.autoScale = !1, this.autoAlpha = !1, this.particleBringToTop = !1, this.particleSendToBack = !1, this._minParticleScale = new n.Point(1, 1), this._maxParticleScale = new n.Point(1, 1), this._quantity = 0, this._timer = 0, this._counter = 0, this._explode = !0, this._frames = null
                        }, n.Particles.Arcade.Emitter.prototype = Object.create(n.Group.prototype), n.Particles.Arcade.Emitter.prototype.constructor = n.Particles.Arcade.Emitter, n.Particles.Arcade.Emitter.prototype.update = function() {
                            if (this.on)
                                if (this._explode) {
                                    this._counter = 0;
                                    do this.emitParticle(), this._counter++; while (this._counter < this._quantity);
                                    this.on = !1
                                } else this.game.time.now >= this._timer && (this.emitParticle(), this._counter++, this._quantity > 0 && this._counter >= this._quantity && (this.on = !1), this._timer = this.game.time.now + this.frequency);
                            for (var t = this.children.length; t--;) this.children[t].exists && this.children[t].update()
                        }, n.Particles.Arcade.Emitter.prototype.makeParticles = function(t, e, i, s, n) {
                            "undefined" == typeof e && (e = 0), "undefined" == typeof i && (i = this.maxParticles), "undefined" == typeof s && (s = !1), "undefined" == typeof n && (n = !1);
                            var r, o = 0,
                                a = t,
                                h = e;
                            for (this._frames = e; i > o;) Array.isArray(t) && (a = this.game.rnd.pick(t)), Array.isArray(e) && (h = this.game.rnd.pick(e)), r = new this.particleClass(this.game, 0, 0, a, h), this.game.physics.arcade.enable(r, !1), s ? (r.body.checkCollision.any = !0, r.body.checkCollision.none = !1) : r.body.checkCollision.none = !0, r.body.collideWorldBounds = n, r.exists = !1, r.visible = !1, r.anchor.copyFrom(this.particleAnchor), this.add(r), o++;
                            return this
                        }, n.Particles.Arcade.Emitter.prototype.kill = function() {
                            this.on = !1, this.alive = !1, this.exists = !1
                        }, n.Particles.Arcade.Emitter.prototype.revive = function() {
                            this.alive = !0, this.exists = !0
                        }, n.Particles.Arcade.Emitter.prototype.explode = function(t, e) {
                            this.start(!0, t, 0, e, !1)
                        }, n.Particles.Arcade.Emitter.prototype.flow = function(t, e, i) {
                            this.start(!1, t, e, i, !0)
                        }, n.Particles.Arcade.Emitter.prototype.start = function(t, e, i, s, n) {
                            "undefined" == typeof t && (t = !0), "undefined" == typeof e && (e = 0), ("undefined" == typeof i || null === i) && (i = 250), "undefined" == typeof s && (s = 0), "undefined" == typeof n && (n = !1), this.revive(), this.visible = !0, this.on = !0, this._explode = t, this.lifespan = e, this.frequency = i, t || n ? this._quantity = s : this._quantity += s, this._counter = 0, this._timer = this.game.time.now + i
                        }, n.Particles.Arcade.Emitter.prototype.emitParticle = function() {
                            var t = this.getFirstExists(!1);
                            null !== t && (this.width > 1 || this.height > 1 ? t.reset(this.game.rnd.integerInRange(this.left, this.right), this.game.rnd.integerInRange(this.top, this.bottom)) : t.reset(this.emitX, this.emitY), t.angle = 0, t.lifespan = this.lifespan, this.particleBringToTop ? this.bringToTop(t) : this.particleSendToBack && this.sendToBack(t), this.autoScale ? t.setScaleData(this.scaleData) : 1 !== this.minParticleScale || 1 !== this.maxParticleScale ? t.scale.set(this.game.rnd.realInRange(this.minParticleScale, this.maxParticleScale)) : (this._minParticleScale.x !== this._maxParticleScale.x || this._minParticleScale.y !== this._maxParticleScale.y) && t.scale.set(this.game.rnd.realInRange(this._minParticleScale.x, this._maxParticleScale.x), this.game.rnd.realInRange(this._minParticleScale.y, this._maxParticleScale.y)), t.frame = Array.isArray("object" === this._frames) ? this.game.rnd.pick(this._frames) : this._frames, this.autoAlpha ? t.setAlphaData(this.alphaData) : t.alpha = this.game.rnd.realInRange(this.minParticleAlpha, this.maxParticleAlpha), t.blendMode = this.blendMode, t.body.updateBounds(), t.body.bounce.setTo(this.bounce.x, this.bounce.y), t.body.velocity.x = this.game.rnd.integerInRange(this.minParticleSpeed.x, this.maxParticleSpeed.x), t.body.velocity.y = this.game.rnd.integerInRange(this.minParticleSpeed.y, this.maxParticleSpeed.y), t.body.angularVelocity = this.game.rnd.integerInRange(this.minRotation, this.maxRotation), t.body.gravity.y = this.gravity, t.body.drag.x = this.particleDrag.x, t.body.drag.y = this.particleDrag.y, t.body.angularDrag = this.angularDrag, t.onEmit())
                        }, n.Particles.Arcade.Emitter.prototype.setSize = function(t, e) {
                            this.area.width = t, this.area.height = e
                        }, n.Particles.Arcade.Emitter.prototype.setXSpeed = function(t, e) {
                            t = t || 0, e = e || 0, this.minParticleSpeed.x = t, this.maxParticleSpeed.x = e
                        }, n.Particles.Arcade.Emitter.prototype.setYSpeed = function(t, e) {
                            t = t || 0, e = e || 0, this.minParticleSpeed.y = t, this.maxParticleSpeed.y = e
                        }, n.Particles.Arcade.Emitter.prototype.setRotation = function(t, e) {
                            t = t || 0, e = e || 0, this.minRotation = t, this.maxRotation = e
                        }, n.Particles.Arcade.Emitter.prototype.setAlpha = function(t, e, i, s, r) {
                            if ("undefined" == typeof t && (t = 1), "undefined" == typeof e && (e = 1), "undefined" == typeof i && (i = 0), "undefined" == typeof s && (s = n.Easing.Linear.None), "undefined" == typeof r && (r = !1), this.minParticleAlpha = t, this.maxParticleAlpha = e, this.autoAlpha = !1, i > 0 && t !== e) {
                                var o = {
                                        v: t
                                    },
                                    a = this.game.make.tween(o).to({
                                        v: e
                                    }, i, s);
                                a.yoyo(r), this.alphaData = a.generateData(60), this.alphaData.reverse(), this.autoAlpha = !0
                            }
                        }, n.Particles.Arcade.Emitter.prototype.setScale = function(t, e, i, s, r, o, a) {
                            if ("undefined" == typeof t && (t = 1), "undefined" == typeof e && (e = 1), "undefined" == typeof i && (i = 1), "undefined" == typeof s && (s = 1), "undefined" == typeof r && (r = 0), "undefined" == typeof o && (o = n.Easing.Linear.None), "undefined" == typeof a && (a = !1), this.minParticleScale = 1, this.maxParticleScale = 1, this._minParticleScale.set(t, i), this._maxParticleScale.set(e, s), this.autoScale = !1, r > 0 && t !== e || i !== s) {
                                var h = {
                                        x: t,
                                        y: i
                                    },
                                    l = this.game.make.tween(h).to({
                                        x: e,
                                        y: s
                                    }, r, o);
                                l.yoyo(a), this.scaleData = l.generateData(60), this.scaleData.reverse(), this.autoScale = !0
                            }
                        }, n.Particles.Arcade.Emitter.prototype.at = function(t) {
                            t.center ? (this.emitX = t.center.x, this.emitY = t.center.y) : (this.emitX = t.world.x + t.anchor.x * t.width, this.emitY = t.world.y + t.anchor.y * t.height)
                        }, Object.defineProperty(n.Particles.Arcade.Emitter.prototype, "width", {
                            get: function() {
                                return this.area.width
                            },
                            set: function(t) {
                                this.area.width = t
                            }
                        }), Object.defineProperty(n.Particles.Arcade.Emitter.prototype, "height", {
                            get: function() {
                                return this.area.height
                            },
                            set: function(t) {
                                this.area.height = t
                            }
                        }), Object.defineProperty(n.Particles.Arcade.Emitter.prototype, "x", {
                            get: function() {
                                return this.emitX
                            },
                            set: function(t) {
                                this.emitX = t
                            }
                        }), Object.defineProperty(n.Particles.Arcade.Emitter.prototype, "y", {
                            get: function() {
                                return this.emitY
                            },
                            set: function(t) {
                                this.emitY = t
                            }
                        }), Object.defineProperty(n.Particles.Arcade.Emitter.prototype, "left", {
                            get: function() {
                                return Math.floor(this.x - this.area.width / 2)
                            }
                        }), Object.defineProperty(n.Particles.Arcade.Emitter.prototype, "right", {
                            get: function() {
                                return Math.floor(this.x + this.area.width / 2)
                            }
                        }), Object.defineProperty(n.Particles.Arcade.Emitter.prototype, "top", {
                            get: function() {
                                return Math.floor(this.y - this.area.height / 2)
                            }
                        }), Object.defineProperty(n.Particles.Arcade.Emitter.prototype, "bottom", {
                            get: function() {
                                return Math.floor(this.y + this.area.height / 2)
                            }
                        }), n.Tile = function(t, e, i, s, n, r) {
                            this.layer = t, this.index = e, this.x = i, this.y = s, this.worldX = i * n, this.worldY = s * r, this.width = n, this.height = r, this.centerX = Math.abs(n / 2), this.centerY = Math.abs(r / 2), this.alpha = 1, this.properties = {}, this.scanned = !1, this.faceTop = !1, this.faceBottom = !1, this.faceLeft = !1, this.faceRight = !1, this.collideLeft = !1, this.collideRight = !1, this.collideUp = !1, this.collideDown = !1, this.collisionCallback = null, this.collisionCallbackContext = this
                        }, n.Tile.prototype = {
                            containsPoint: function(t, e) {
                                return !(t < this.worldX || e < this.worldY || t > this.right || e > this.bottom)
                            },
                            intersects: function(t, e, i, s) {
                                return i <= this.worldX ? !1 : s <= this.worldY ? !1 : t >= this.worldX + this.width ? !1 : e >= this.worldY + this.height ? !1 : !0
                            },
                            setCollisionCallback: function(t, e) {
                                this.collisionCallback = t, this.collisionCallbackContext = e
                            },
                            destroy: function() {
                                this.collisionCallback = null, this.collisionCallbackContext = null, this.properties = null
                            },
                            setCollision: function(t, e, i, s) {
                                this.collideLeft = t, this.collideRight = e, this.collideUp = i, this.collideDown = s
                            },
                            resetCollision: function() {
                                this.collideLeft = !1, this.collideRight = !1, this.collideUp = !1, this.collideDown = !1, this.faceTop = !1, this.faceBottom = !1, this.faceLeft = !1, this.faceRight = !1
                            },
                            isInteresting: function(t, e) {
                                return t && e ? this.collideLeft || this.collideRight || this.collideUp || this.collideDown || this.faceTop || this.faceBottom || this.faceLeft || this.faceRight || this.collisionCallback : t ? this.collideLeft || this.collideRight || this.collideUp || this.collideDown : e ? this.faceTop || this.faceBottom || this.faceLeft || this.faceRight : !1
                            },
                            copy: function(t) {
                                this.index = t.index, this.alpha = t.alpha, this.properties = t.properties, this.collideUp = t.collideUp, this.collideDown = t.collideDown, this.collideLeft = t.collideLeft, this.collideRight = t.collideRight, this.collisionCallback = t.collisionCallback, this.collisionCallbackContext = t.collisionCallbackContext
                            }
                        }, n.Tile.prototype.constructor = n.Tile, Object.defineProperty(n.Tile.prototype, "collides", {
                            get: function() {
                                return this.collideLeft || this.collideRight || this.collideUp || this.collideDown
                            }
                        }), Object.defineProperty(n.Tile.prototype, "canCollide", {
                            get: function() {
                                return this.collideLeft || this.collideRight || this.collideUp || this.collideDown || this.collisionCallback
                            }
                        }), Object.defineProperty(n.Tile.prototype, "left", {
                            get: function() {
                                return this.worldX
                            }
                        }), Object.defineProperty(n.Tile.prototype, "right", {
                            get: function() {
                                return this.worldX + this.width
                            }
                        }), Object.defineProperty(n.Tile.prototype, "top", {
                            get: function() {
                                return this.worldY
                            }
                        }), Object.defineProperty(n.Tile.prototype, "bottom", {
                            get: function() {
                                return this.worldY + this.height
                            }
                        }), n.Tilemap = function(t, e, i, s, r, o) {
                            this.game = t, this.key = e;
                            var a = n.TilemapParser.parse(this.game, e, i, s, r, o);
                            null !== a && (this.width = a.width, this.height = a.height, this.tileWidth = a.tileWidth, this.tileHeight = a.tileHeight, this.orientation = a.orientation, this.format = a.format, this.version = a.version, this.properties = a.properties, this.widthInPixels = a.widthInPixels, this.heightInPixels = a.heightInPixels, this.layers = a.layers, this.tilesets = a.tilesets, this.tiles = a.tiles, this.objects = a.objects, this.collideIndexes = [], this.collision = a.collision, this.images = a.images, this.currentLayer = 0, this.debugMap = [], this._results = [], this._tempA = 0, this._tempB = 0)
                        }, n.Tilemap.CSV = 0, n.Tilemap.TILED_JSON = 1, n.Tilemap.NORTH = 0, n.Tilemap.EAST = 1, n.Tilemap.SOUTH = 2, n.Tilemap.WEST = 3, n.Tilemap.prototype = {
                            create: function(t, e, i, s, n, r) {
                                return "undefined" == typeof r && (r = this.game.world), this.width = e, this.height = i, this.setTileSize(s, n), this.layers.length = 0, this.createBlankLayer(t, e, i, s, n, r)
                            },
                            setTileSize: function(t, e) {
                                this.tileWidth = t, this.tileHeight = e, this.widthInPixels = this.width * t, this.heightInPixels = this.height * e
                            },
                            addTilesetImage: function(t, e, i, s, r, o, a) {
                                if ("undefined" == typeof i && (i = this.tileWidth), "undefined" == typeof s && (s = this.tileHeight), "undefined" == typeof r && (r = 0), "undefined" == typeof o && (o = 0), "undefined" == typeof a && (a = 0), 0 === i && (i = 32), 0 === s && (s = 32), "undefined" == typeof e) {
                                    if ("string" != typeof t) return null;
                                    if (e = t, !this.game.cache.checkImageKey(e)) return console.warn('Phaser.Tilemap.addTilesetImage: Invalid image key given: "' + e + '"'), null
                                }
                                if ("string" == typeof t && (t = this.getTilesetIndex(t), null === t && this.format === n.Tilemap.TILED_JSON)) return console.warn('Phaser.Tilemap.addTilesetImage: No data found in the JSON matching the tileset name: "' + e + '"'), null;
                                if (this.tilesets[t]) return this.tilesets[t].setImage(this.game.cache.getImage(e)), this.tilesets[t];
                                var h = new n.Tileset(e, a, i, s, r, o, {});
                                h.setImage(this.game.cache.getImage(e)), this.tilesets.push(h);
                                for (var l = this.tilesets.length - 1, c = r, u = r, d = 0, p = 0, f = 0, g = a; g < a + h.total && (this.tiles[g] = [c, u, l], c += i + o, d++, d !== h.total) && (p++, p !== h.columns || (c = r, u += s + o, p = 0, f++, f !== h.rows)); g++);
                                return h
                            },
                            createFromObjects: function(t, e, i, s, r, o, a, h, l) {
                                if ("undefined" == typeof r && (r = !0), "undefined" == typeof o && (o = !1), "undefined" == typeof a && (a = this.game.world), "undefined" == typeof h && (h = n.Sprite), "undefined" == typeof l && (l = !0), !this.objects[t]) return void console.warn("Tilemap.createFromObjects: Invalid objectgroup name given: " + t);
                                for (var c, u = 0, d = this.objects[t].length; d > u; u++)
                                    if (this.objects[t][u].gid === e) {
                                        c = new h(this.game, this.objects[t][u].x, this.objects[t][u].y, i, s), c.name = this.objects[t][u].name, c.visible = this.objects[t][u].visible, c.autoCull = o, c.exists = r, l && (c.y -= c.height), a.add(c);
                                        for (var p in this.objects[t][u].properties) a.set(c, p, this.objects[t][u].properties[p], !1, !1, 0, !0)
                                    }
                            },
                            createLayer: function(t, e, i, s) {
                                "undefined" == typeof e && (e = this.game.width), "undefined" == typeof i && (i = this.game.height), "undefined" == typeof s && (s = this.game.world);
                                var r = t;
                                return "string" == typeof t && (r = this.getLayerIndex(t)), null === r || r > this.layers.length ? void console.warn("Tilemap.createLayer: Invalid layer ID given: " + r) : s.add(new n.TilemapLayer(this.game, this, r, e, i))
                            },
                            createBlankLayer: function(t, e, i, s, r, o) {
                                if ("undefined" == typeof o && (o = this.game.world), null !== this.getLayerIndex(t)) return void console.warn("Tilemap.createBlankLayer: Layer with matching name already exists");
                                for (var a, h = {
                                        name: t,
                                        x: 0,
                                        y: 0,
                                        width: e,
                                        height: i,
                                        widthInPixels: e * s,
                                        heightInPixels: i * r,
                                        alpha: 1,
                                        visible: !0,
                                        properties: {},
                                        indexes: [],
                                        callbacks: [],
                                        bodies: [],
                                        data: null
                                    }, l = [], c = 0; i > c; c++) {
                                    a = [];
                                    for (var u = 0; e > u; u++) a.push(new n.Tile(h, -1, u, c, s, r));
                                    l.push(a)
                                }
                                h.data = l, this.layers.push(h), this.currentLayer = this.layers.length - 1;
                                var d = h.widthInPixels,
                                    p = h.heightInPixels;
                                d > this.game.width && (d = this.game.width), p > this.game.height && (p = this.game.height);
                                var l = new n.TilemapLayer(this.game, this, this.layers.length - 1, d, p);
                                return l.name = t, o.add(l)
                            },
                            getIndex: function(t, e) {
                                for (var i = 0; i < t.length; i++)
                                    if (t[i].name === e) return i;
                                return null
                            },
                            getLayerIndex: function(t) {
                                return this.getIndex(this.layers, t)
                            },
                            getTilesetIndex: function(t) {
                                return this.getIndex(this.tilesets, t)
                            },
                            getImageIndex: function(t) {
                                return this.getIndex(this.images, t)
                            },
                            getObjectIndex: function(t) {
                                return this.getIndex(this.objects, t)
                            },
                            setTileIndexCallback: function(t, e, i, s) {
                                if (s = this.getLayer(s), "number" == typeof t) this.layers[s].callbacks[t] = {
                                    callback: e,
                                    callbackContext: i
                                };
                                else
                                    for (var n = 0, r = t.length; r > n; n++) this.layers[s].callbacks[t[n]] = {
                                        callback: e,
                                        callbackContext: i
                                    }
                            },
                            setTileLocationCallback: function(t, e, i, s, n, r, o) {
                                if (o = this.getLayer(o), this.copy(t, e, i, s, o), !(this._results.length < 2))
                                    for (var a = 1; a < this._results.length; a++) this._results[a].setCollisionCallback(n, r)
                            },
                            setCollision: function(t, e, i, s) {
                                if ("undefined" == typeof e && (e = !0), "undefined" == typeof s && (s = !0), i = this.getLayer(i), "number" == typeof t) return this.setCollisionByIndex(t, e, i, !0);
                                for (var n = 0, r = t.length; r > n; n++) this.setCollisionByIndex(t[n], e, i, !1);
                                s && this.calculateFaces(i)
                            },
                            setCollisionBetween: function(t, e, i, s, n) {
                                if ("undefined" == typeof i && (i = !0), "undefined" == typeof n && (n = !0), s = this.getLayer(s), !(t > e)) {
                                    for (var r = t; e >= r; r++) this.setCollisionByIndex(r, i, s, !1);
                                    n && this.calculateFaces(s)
                                }
                            },
                            setCollisionByExclusion: function(t, e, i, s) {
                                "undefined" == typeof e && (e = !0), "undefined" == typeof s && (s = !0), i = this.getLayer(i);
                                for (var n = 0, r = this.tiles.length; r > n; n++) - 1 === t.indexOf(n) && this.setCollisionByIndex(n, e, i, !1);
                                s && this.calculateFaces(i)
                            },
                            setCollisionByIndex: function(t, e, i, s) {
                                if ("undefined" == typeof e && (e = !0), "undefined" == typeof i && (i = this.currentLayer), "undefined" == typeof s && (s = !0), e) this.collideIndexes.push(t);
                                else {
                                    var n = this.collideIndexes.indexOf(t);
                                    n > -1 && this.collideIndexes.splice(n, 1)
                                }
                                for (var r = 0; r < this.layers[i].height; r++)
                                    for (var o = 0; o < this.layers[i].width; o++) {
                                        var a = this.layers[i].data[r][o];
                                        a && a.index === t && (e ? a.setCollision(!0, !0, !0, !0) : a.resetCollision(), a.faceTop = e, a.faceBottom = e, a.faceLeft = e, a.faceRight = e)
                                    }
                                return s && this.calculateFaces(i), i
                            },
                            getLayer: function(t) {
                                return "undefined" == typeof t ? t = this.currentLayer : "string" == typeof t ? t = this.getLayerIndex(t) : t instanceof n.TilemapLayer && (t = t.index), t
                            },
                            setPreventRecalculate: function(t) {
                                if (t === !0 && this.preventingRecalculate !== !0 && (this.preventingRecalculate = !0, this.needToRecalculate = {}), t === !1 && this.preventingRecalculate === !0) {
                                    this.preventingRecalculate = !1;
                                    for (var e in this.needToRecalculate) this.calculateFaces(e);
                                    this.needToRecalculate = !1
                                }
                            },
                            calculateFaces: function(t) {
                                if (this.preventingRecalculate === !0) return void(this.needToRecalculate[t] = !0);
                                for (var e = null, i = null, s = null, n = null, r = 0, o = this.layers[t].height; o > r; r++)
                                    for (var a = 0, h = this.layers[t].width; h > a; a++) {
                                        var l = this.layers[t].data[r][a];
                                        l && (e = this.getTileAbove(t, a, r), i = this.getTileBelow(t, a, r), s = this.getTileLeft(t, a, r), n = this.getTileRight(t, a, r), l.collides && (l.faceTop = !0, l.faceBottom = !0, l.faceLeft = !0, l.faceRight = !0), e && e.collides && (l.faceTop = !1), i && i.collides && (l.faceBottom = !1), s && s.collides && (l.faceLeft = !1), n && n.collides && (l.faceRight = !1))
                                    }
                            },
                            getTileAbove: function(t, e, i) {
                                return i > 0 ? this.layers[t].data[i - 1][e] : null
                            },
                            getTileBelow: function(t, e, i) {
                                return i < this.layers[t].height - 1 ? this.layers[t].data[i + 1][e] : null
                            },
                            getTileLeft: function(t, e, i) {
                                return e > 0 ? this.layers[t].data[i][e - 1] : null
                            },
                            getTileRight: function(t, e, i) {
                                return e < this.layers[t].width - 1 ? this.layers[t].data[i][e + 1] : null
                            },
                            setLayer: function(t) {
                                t = this.getLayer(t), this.layers[t] && (this.currentLayer = t)
                            },
                            hasTile: function(t, e, i) {
                                return i = this.getLayer(i), null !== this.layers[i].data[e] && null !== this.layers[i].data[e][t]
                            },
                            removeTile: function(t, e, i) {
                                if (i = this.getLayer(i), t >= 0 && t < this.layers[i].width && e >= 0 && e < this.layers[i].height && this.hasTile(t, e, i)) {
                                    var s = this.layers[i].data[e][t];
                                    return this.layers[i].data[e][t] = new n.Tile(this.layers[i], -1, t, e, this.tileWidth, this.tileHeight), this.layers[i].dirty = !0, this.calculateFaces(i), s
                                }
                            },
                            removeTileWorldXY: function(t, e, i, s, n) {
                                return n = this.getLayer(n), t = this.game.math.snapToFloor(t, i) / i, e = this.game.math.snapToFloor(e, s) / s, this.removeTile(t, e, n)
                            },
                            putTile: function(t, e, i, s) {
                                if (null === t) return this.removeTile(e, i, s);
                                if (s = this.getLayer(s), e >= 0 && e < this.layers[s].width && i >= 0 && i < this.layers[s].height) {
                                    var r;
                                    return t instanceof n.Tile ? (r = t.index, this.hasTile(e, i, s) ? this.layers[s].data[i][e].copy(t) : this.layers[s].data[i][e] = new n.Tile(s, r, e, i, t.width, t.height)) : (r = t, this.hasTile(e, i, s) ? this.layers[s].data[i][e].index = r : this.layers[s].data[i][e] = new n.Tile(this.layers[s], r, e, i, this.tileWidth, this.tileHeight)), this.collideIndexes.indexOf(r) > -1 ? this.layers[s].data[i][e].setCollision(!0, !0, !0, !0) : this.layers[s].data[i][e].resetCollision(), this.layers[s].dirty = !0, this.calculateFaces(s), this.layers[s].data[i][e]
                                }
                                return null
                            },
                            putTileWorldXY: function(t, e, i, s, n, r) {
                                return r = this.getLayer(r), e = this.game.math.snapToFloor(e, s) / s, i = this.game.math.snapToFloor(i, n) / n, this.putTile(t, e, i, r)
                            },
                            searchTileIndex: function(t, e, i, s) {
                                "undefined" == typeof e && (e = 0), "undefined" == typeof i && (i = !1), s = this.getLayer(s);
                                var n = 0;
                                if (i) {
                                    for (var r = this.layers[s].height - 1; r >= 0; r--)
                                        for (var o = this.layers[s].width - 1; o >= 0; o--)
                                            if (this.layers[s].data[r][o].index === t) {
                                                if (n === e) return this.layers[s].data[r][o];
                                                n++
                                            }
                                } else
                                    for (var r = 0; r < this.layers[s].height; r++)
                                        for (var o = 0; o < this.layers[s].width; o++)
                                            if (this.layers[s].data[r][o].index === t) {
                                                if (n === e) return this.layers[s].data[r][o];
                                                n++
                                            } return null
                            },
                            getTile: function(t, e, i, s) {
                                return "undefined" == typeof s && (s = !1), i = this.getLayer(i), t >= 0 && t < this.layers[i].width && e >= 0 && e < this.layers[i].height ? -1 === this.layers[i].data[e][t].index ? s ? this.layers[i].data[e][t] : null : this.layers[i].data[e][t] : null
                            },
                            getTileWorldXY: function(t, e, i, s, n) {
                                return "undefined" == typeof i && (i = this.tileWidth), "undefined" == typeof s && (s = this.tileHeight), n = this.getLayer(n), t = this.game.math.snapToFloor(t, i) / i, e = this.game.math.snapToFloor(e, s) / s, this.getTile(t, e, n)
                            },
                            copy: function(t, e, i, s, n) {
                                if (n = this.getLayer(n), !this.layers[n]) return void(this._results.length = 0);
                                "undefined" == typeof t && (t = 0), "undefined" == typeof e && (e = 0), "undefined" == typeof i && (i = this.layers[n].width), "undefined" == typeof s && (s = this.layers[n].height), 0 > t && (t = 0), 0 > e && (e = 0), i > this.layers[n].width && (i = this.layers[n].width), s > this.layers[n].height && (s = this.layers[n].height), this._results.length = 0, this._results.push({
                                    x: t,
                                    y: e,
                                    width: i,
                                    height: s,
                                    layer: n
                                });
                                for (var r = e; e + s > r; r++)
                                    for (var o = t; t + i > o; o++) this._results.push(this.layers[n].data[r][o]);
                                return this._results
                            },
                            paste: function(t, e, i, s) {
                                if ("undefined" == typeof t && (t = 0), "undefined" == typeof e && (e = 0), s = this.getLayer(s), i && !(i.length < 2)) {
                                    for (var n = i[1].x - t, r = i[1].y - e, o = 1; o < i.length; o++) this.layers[s].data[r + i[o].y][n + i[o].x].copy(i[o]);
                                    this.layers[s].dirty = !0, this.calculateFaces(s)
                                }
                            },
                            swap: function(t, e, i, s, n, r, o) {
                                o = this.getLayer(o), this.copy(i, s, n, r, o), this._results.length < 2 || (this._tempA = t, this._tempB = e, this._results.forEach(this.swapHandler, this), this.paste(i, s, this._results, o))
                            },
                            swapHandler: function(t) {
                                t.index === this._tempA ? t.index = this._tempB : t.index === this._tempB && (t.index = this._tempA)
                            },
                            forEach: function(t, e, i, s, n, r, o) {
                                o = this.getLayer(o), this.copy(i, s, n, r, o), this._results.length < 2 || (this._results.forEach(t, e), this.paste(i, s, this._results, o))
                            },
                            replace: function(t, e, i, s, n, r, o) {
                                if (o = this.getLayer(o), this.copy(i, s, n, r, o), !(this._results.length < 2)) {
                                    for (var a = 1; a < this._results.length; a++) this._results[a].index === t && (this._results[a].index = e);
                                    this.paste(i, s, this._results, o)
                                }
                            },
                            random: function(t, e, i, s, n) {
                                if (n = this.getLayer(n), this.copy(t, e, i, s, n), !(this._results.length < 2)) {
                                    for (var r = [], o = 1; o < this._results.length; o++)
                                        if (this._results[o].index) {
                                            var a = this._results[o].index; - 1 === r.indexOf(a) && r.push(a)
                                        }
                                    for (var h = 1; h < this._results.length; h++) this._results[h].index = this.game.rnd.pick(r);
                                    this.paste(t, e, this._results, n)
                                }
                            },
                            shuffle: function(t, e, i, s, r) {
                                if (r = this.getLayer(r), this.copy(t, e, i, s, r), !(this._results.length < 2)) {
                                    for (var o = [], a = 1; a < this._results.length; a++) this._results[a].index && o.push(this._results[a].index);
                                    n.Utils.shuffle(o);
                                    for (var h = 1; h < this._results.length; h++) this._results[h].index = o[h - 1];
                                    this.paste(t, e, this._results, r)
                                }
                            },
                            fill: function(t, e, i, s, n, r) {
                                if (r = this.getLayer(r), this.copy(e, i, s, n, r), !(this._results.length < 2)) {
                                    for (var o = 1; o < this._results.length; o++) this._results[o].index = t;
                                    this.paste(e, i, this._results, r)
                                }
                            },
                            removeAllLayers: function() {
                                this.layers.length = 0, this.currentLayer = 0
                            },
                            dump: function() {
                                for (var t = "", e = [""], i = 0; i < this.layers[this.currentLayer].height; i++) {
                                    for (var s = 0; s < this.layers[this.currentLayer].width; s++) t += "%c  ", e.push(this.layers[this.currentLayer].data[i][s] > 1 ? this.debugMap[this.layers[this.currentLayer].data[i][s]] ? "background: " + this.debugMap[this.layers[this.currentLayer].data[i][s]] : "background: #ffffff" : "background: rgb(0, 0, 0)");
                                    t += "\n"
                                }
                                e[0] = t, console.log.apply(console, e)
                            },
                            destroy: function() {
                                this.removeAllLayers(), this.data = [], this.game = null
                            }
                        }, n.Tilemap.prototype.constructor = n.Tilemap, Object.defineProperty(n.Tilemap.prototype, "layer", {
                            get: function() {
                                return this.layers[this.currentLayer]
                            },
                            set: function(t) {
                                t !== this.currentLayer && this.setLayer(t)
                            }
                        }), n.TilemapLayer = function(t, e, i, s, r) {
                            this.game = t, this.map = e, this.index = i, this.layer = e.layers[i], this.canvas = n.Canvas.create(s, r, "", !0), this.context = this.canvas.getContext("2d"), this.baseTexture = new PIXI.BaseTexture(this.canvas), this.texture = new PIXI.Texture(this.baseTexture), this.textureFrame = new n.Frame(0, 0, 0, s, r, "tilemapLayer", t.rnd.uuid()), n.Image.call(this, this.game, 0, 0, this.texture, this.textureFrame), this.name = "", this.type = n.TILEMAPLAYER, this.fixedToCamera = !0, this.cameraOffset = new n.Point(0, 0), this.tileColor = "rgb(255, 255, 255)", this.debug = !1, this.debugAlpha = .5, this.debugColor = "rgba(0, 255, 0, 1)", this.debugFill = !1, this.debugFillColor = "rgba(0, 255, 0, 0.2)", this.debugCallbackColor = "rgba(255, 0, 0, 1)", this.scrollFactorX = 1, this.scrollFactorY = 1, this.dirty = !0, this.rayStepRate = 4, this.wrap = !1, this._mc = {
                                cw: e.tileWidth,
                                ch: e.tileHeight,
                                ga: 1,
                                dx: 0,
                                dy: 0,
                                dw: 0,
                                dh: 0,
                                tx: 0,
                                ty: 0,
                                tw: 0,
                                th: 0,
                                tl: 0,
                                maxX: 0,
                                maxY: 0,
                                startX: 0,
                                startY: 0,
                                x: 0,
                                y: 0,
                                prevX: 0,
                                prevY: 0
                            }, this._results = [], this.updateMax()
                        }, n.TilemapLayer.prototype = Object.create(n.Image.prototype), n.TilemapLayer.prototype.constructor = n.TilemapLayer, n.TilemapLayer.prototype.postUpdate = function() {
                            n.Image.prototype.postUpdate.call(this), this.scrollX = this.game.camera.x * this.scrollFactorX, this.scrollY = this.game.camera.y * this.scrollFactorY, this.render(), 1 === this._cache[7] && (this.position.x = (this.game.camera.view.x + this.cameraOffset.x) / this.game.camera.scale.x, this.position.y = (this.game.camera.view.y + this.cameraOffset.y) / this.game.camera.scale.y)
                        }, n.TilemapLayer.prototype.resizeWorld = function() {
                            this.game.world.setBounds(0, 0, this.layer.widthInPixels, this.layer.heightInPixels)
                        }, n.TilemapLayer.prototype._fixX = function(t) {
                            return 0 > t && (t = 0), 1 === this.scrollFactorX ? t : this._mc.x + (t - this._mc.x / this.scrollFactorX)
                        }, n.TilemapLayer.prototype._unfixX = function(t) {
                            return 1 === this.scrollFactorX ? t : this._mc.x / this.scrollFactorX + (t - this._mc.x)
                        }, n.TilemapLayer.prototype._fixY = function(t) {
                            return 0 > t && (t = 0), 1 === this.scrollFactorY ? t : this._mc.y + (t - this._mc.y / this.scrollFactorY)
                        }, n.TilemapLayer.prototype._unfixY = function(t) {
                            return 1 === this.scrollFactorY ? t : this._mc.y / this.scrollFactorY + (t - this._mc.y)
                        }, n.TilemapLayer.prototype.getTileX = function(t) {
                            return this.game.math.snapToFloor(this._fixX(t), this.map.tileWidth) / this.map.tileWidth
                        }, n.TilemapLayer.prototype.getTileY = function(t) {
                            return this.game.math.snapToFloor(this._fixY(t), this.map.tileHeight) / this.map.tileHeight
                        }, n.TilemapLayer.prototype.getTileXY = function(t, e, i) {
                            return i.x = this.getTileX(t), i.y = this.getTileY(e), i
                        }, n.TilemapLayer.prototype.getRayCastTiles = function(t, e, i, s) {
                            ("undefined" == typeof e || null === e) && (e = this.rayStepRate), "undefined" == typeof i && (i = !1), "undefined" == typeof s && (s = !1);
                            var n = this.getTiles(t.x, t.y, t.width, t.height, i, s);
                            if (0 === n.length) return [];
                            for (var r = t.coordinatesOnLine(e), o = r.length, a = [], h = 0; h < n.length; h++)
                                for (var l = 0; o > l; l++)
                                    if (n[h].containsPoint(r[l][0], r[l][1])) {
                                        a.push(n[h]);
                                        break
                                    }
                            return a
                        }, n.TilemapLayer.prototype.getTiles = function(t, e, i, s, n, r) {
                            "undefined" == typeof n && (n = !1), "undefined" == typeof r && (r = !1), t = this._fixX(t), e = this._fixY(e), i > this.layer.widthInPixels && (i = this.layer.widthInPixels), s > this.layer.heightInPixels && (s = this.layer.heightInPixels), this._mc.tx = this.game.math.snapToFloor(t, this._mc.cw) / this._mc.cw, this._mc.ty = this.game.math.snapToFloor(e, this._mc.ch) / this._mc.ch, this._mc.tw = (this.game.math.snapToCeil(i, this._mc.cw) + this._mc.cw) / this._mc.cw, this._mc.th = (this.game.math.snapToCeil(s, this._mc.ch) + this._mc.ch) / this._mc.ch, this._results.length = 0;
                            for (var o = this._mc.ty; o < this._mc.ty + this._mc.th; o++)
                                for (var a = this._mc.tx; a < this._mc.tx + this._mc.tw; a++) this.layer.data[o] && this.layer.data[o][a] && (!n && !r || this.layer.data[o][a].isInteresting(n, r)) && this._results.push(this.layer.data[o][a]);
                            return this._results
                        }, n.TilemapLayer.prototype.updateMax = function() {
                            this._mc.maxX = this.game.math.ceil(this.canvas.width / this.map.tileWidth) + 1, this._mc.maxY = this.game.math.ceil(this.canvas.height / this.map.tileHeight) + 1, this.dirty = !0
                        }, n.TilemapLayer.prototype.render = function() {
                            if (this.layer.dirty && (this.dirty = !0), this.dirty && this.visible) {
                                this._mc.prevX = this._mc.dx, this._mc.prevY = this._mc.dy, this._mc.dx = -(this._mc.x - this._mc.startX * this.map.tileWidth), this._mc.dy = -(this._mc.y - this._mc.startY * this.map.tileHeight), this._mc.tx = this._mc.dx, this._mc.ty = this._mc.dy, this.context.clearRect(0, 0, this.canvas.width, this.canvas.height), this.context.fillStyle = this.tileColor;
                                var t, e;
                                this.debug && (this.context.globalAlpha = this.debugAlpha);
                                for (var i = this._mc.startY, s = this._mc.startY + this._mc.maxY; s > i; i++) {
                                    if (this._column = null, 0 > i && this.wrap ? this._column = this.layer.data[i + this.map.height] : i >= this.map.height && this.wrap ? this._column = this.layer.data[i - this.map.height] : this.layer.data[i] && (this._column = this.layer.data[i]), this._column)
                                        for (var r = this._mc.startX, o = this._mc.startX + this._mc.maxX; o > r; r++) {
                                            var t = null;
                                            0 > r && this.wrap ? t = this._column[r + this.map.width] : r >= this.map.width && this.wrap ? t = this._column[r - this.map.width] : this._column[r] && (t = this._column[r]), t && t.index > -1 && (e = this.map.tilesets[this.map.tiles[t.index][2]], this.debug === !1 && t.alpha !== this.context.globalAlpha && (this.context.globalAlpha = t.alpha), e.draw(this.context, Math.floor(this._mc.tx), Math.floor(this._mc.ty), t.index), t.debug && (this.context.fillStyle = "rgba(0, 255, 0, 0.4)", this.context.fillRect(Math.floor(this._mc.tx), Math.floor(this._mc.ty), this.map.tileWidth, this.map.tileHeight))), this._mc.tx += this.map.tileWidth
                                        }
                                    this._mc.tx = this._mc.dx, this._mc.ty += this.map.tileHeight
                                }
                                return this.debug && (this.context.globalAlpha = 1, this.renderDebug()), this.game.renderType === n.WEBGL && PIXI.updateWebGLTexture(this.baseTexture, this.game.renderer.gl), this.dirty = !1, this.layer.dirty = !1, !0
                            }
                        }, n.TilemapLayer.prototype.renderDebug = function() {
                            this._mc.tx = this._mc.dx, this._mc.ty = this._mc.dy, this.context.strokeStyle = this.debugColor, this.context.fillStyle = this.debugFillColor;
                            for (var t = this._mc.startY, e = this._mc.startY + this._mc.maxY; e > t; t++) {
                                if (this._column = null, 0 > t && this.wrap ? this._column = this.layer.data[t + this.map.height] : t >= this.map.height && this.wrap ? this._column = this.layer.data[t - this.map.height] : this.layer.data[t] && (this._column = this.layer.data[t]), this._column)
                                    for (var i = this._mc.startX, s = this._mc.startX + this._mc.maxX; s > i; i++) {
                                        var n = null;
                                        0 > i && this.wrap ? n = this._column[i + this.map.width] : i >= this.map.width && this.wrap ? n = this._column[i - this.map.width] : this._column[i] && (n = this._column[i]), n && (n.faceTop || n.faceBottom || n.faceLeft || n.faceRight) && (this._mc.tx = Math.floor(this._mc.tx), this.debugFill && this.context.fillRect(this._mc.tx, this._mc.ty, this._mc.cw, this._mc.ch), this.context.beginPath(), n.faceTop && (this.context.moveTo(this._mc.tx, this._mc.ty), this.context.lineTo(this._mc.tx + this._mc.cw, this._mc.ty)), n.faceBottom && (this.context.moveTo(this._mc.tx, this._mc.ty + this._mc.ch), this.context.lineTo(this._mc.tx + this._mc.cw, this._mc.ty + this._mc.ch)), n.faceLeft && (this.context.moveTo(this._mc.tx, this._mc.ty), this.context.lineTo(this._mc.tx, this._mc.ty + this._mc.ch)), n.faceRight && (this.context.moveTo(this._mc.tx + this._mc.cw, this._mc.ty), this.context.lineTo(this._mc.tx + this._mc.cw, this._mc.ty + this._mc.ch)), this.context.stroke()), this._mc.tx += this.map.tileWidth
                                    }
                                this._mc.tx = this._mc.dx, this._mc.ty += this.map.tileHeight
                            }
                        }, Object.defineProperty(n.TilemapLayer.prototype, "scrollX", {
                            get: function() {
                                return this._mc.x
                            },
                            set: function(t) {
                                t !== this._mc.x && (this._mc.x = t, this._mc.startX = this.game.math.floor(this._mc.x / this.map.tileWidth), this.dirty = !0)
                            }
                        }), Object.defineProperty(n.TilemapLayer.prototype, "scrollY", {
                            get: function() {
                                return this._mc.y
                            },
                            set: function(t) {
                                t !== this._mc.y && (this._mc.y = t, this._mc.startY = this.game.math.floor(this._mc.y / this.map.tileHeight), this.dirty = !0)
                            }
                        }), Object.defineProperty(n.TilemapLayer.prototype, "collisionWidth", {
                            get: function() {
                                return this._mc.cw
                            },
                            set: function(t) {
                                this._mc.cw = t, this.dirty = !0
                            }
                        }), Object.defineProperty(n.TilemapLayer.prototype, "collisionHeight", {
                            get: function() {
                                return this._mc.ch
                            },
                            set: function(t) {
                                this._mc.ch = t, this.dirty = !0
                            }
                        }), n.TilemapParser = {
                            parse: function(t, e, i, s, r, o) {
                                if ("undefined" == typeof i && (i = 32), "undefined" == typeof s && (s = 32), "undefined" == typeof r && (r = 10), "undefined" == typeof o && (o = 10), "undefined" == typeof e) return this.getEmptyData();
                                if (null === e) return this.getEmptyData(i, s, r, o);
                                var a = t.cache.getTilemapData(e);
                                if (a) {
                                    if (a.format === n.Tilemap.CSV) return this.parseCSV(e, a.data, i, s);
                                    if (!a.format || a.format === n.Tilemap.TILED_JSON) return this.parseTiledJSON(a.data)
                                } else console.warn("Phaser.TilemapParser.parse - No map data found for key " + e)
                            },
                            parseCSV: function(t, e, i, s) {
                                var r = this.getEmptyData();
                                e = e.trim();
                                for (var o = [], a = e.split("\n"), h = a.length, l = 0, c = 0; c < a.length; c++) {
                                    o[c] = [];
                                    for (var u = a[c].split(","), d = 0; d < u.length; d++) o[c][d] = new n.Tile(r.layers[0], parseInt(u[d], 10), d, c, i, s);
                                    0 === l && (l = u.length)
                                }
                                return r.format = n.Tilemap.CSV, r.name = t, r.width = l, r.height = h, r.tileWidth = i, r.tileHeight = s, r.widthInPixels = l * i, r.heightInPixels = h * s, r.layers[0].width = l, r.layers[0].height = h, r.layers[0].widthInPixels = r.widthInPixels, r.layers[0].heightInPixels = r.heightInPixels, r.layers[0].data = o, r
                            },
                            getEmptyData: function(t, e, i, s) {
                                var n = {};
                                n.width = 0, n.height = 0, n.tileWidth = 0, n.tileHeight = 0, "undefined" != typeof t && null !== t && (n.tileWidth = t), "undefined" != typeof e && null !== e && (n.tileHeight = e), "undefined" != typeof i && null !== i && (n.width = i), "undefined" != typeof s && null !== s && (n.height = s), n.orientation = "orthogonal", n.version = "1", n.properties = {}, n.widthInPixels = 0, n.heightInPixels = 0;
                                var r = [],
                                    o = {
                                        name: "layer",
                                        x: 0,
                                        y: 0,
                                        width: 0,
                                        height: 0,
                                        widthInPixels: 0,
                                        heightInPixels: 0,
                                        alpha: 1,
                                        visible: !0,
                                        properties: {},
                                        indexes: [],
                                        callbacks: [],
                                        data: []
                                    };
                                return r.push(o), n.layers = r, n.images = [], n.objects = {}, n.collision = {}, n.tilesets = [], n.tiles = [], n
                            },
                            parseTiledJSON: function(t) {
                                function e(t, e) {
                                    var i = {};
                                    for (var s in e) {
                                        var n = e[s];
                                        i[n] = t[n]
                                    }
                                    return i
                                }
                                if ("orthogonal" !== t.orientation) return console.warn("TilemapParser.parseTiledJSON: Only orthogonal map types are supported in this version of Phaser"), null;
                                var i = {};
                                i.width = t.width, i.height = t.height, i.tileWidth = t.tilewidth, i.tileHeight = t.tileheight, i.orientation = t.orientation, i.format = n.Tilemap.TILED_JSON, i.version = t.version, i.properties = t.properties, i.widthInPixels = i.width * i.tileWidth, i.heightInPixels = i.height * i.tileHeight;
                                for (var s = [], r = 0; r < t.layers.length; r++)
                                    if ("tilelayer" === t.layers[r].type) {
                                        var o = {
                                            name: t.layers[r].name,
                                            x: t.layers[r].x,
                                            y: t.layers[r].y,
                                            width: t.layers[r].width,
                                            height: t.layers[r].height,
                                            widthInPixels: t.layers[r].width * t.tilewidth,
                                            heightInPixels: t.layers[r].height * t.tileheight,
                                            alpha: t.layers[r].opacity,
                                            visible: t.layers[r].visible,
                                            properties: {},
                                            indexes: [],
                                            callbacks: [],
                                            bodies: []
                                        };
                                        t.layers[r].properties && (o.properties = t.layers[r].properties);
                                        for (var a = 0, h = [], l = [], c = 0, u = t.layers[r].data.length; u > c; c++) h.push(t.layers[r].data[c] > 0 ? new n.Tile(o, t.layers[r].data[c], a, l.length, t.tilewidth, t.tileheight) : new n.Tile(o, -1, a, l.length, t.tilewidth, t.tileheight)), a++, a === t.layers[r].width && (l.push(h), a = 0, h = []);
                                        o.data = l, s.push(o)
                                    }
                                i.layers = s;
                                for (var d = [], r = 0; r < t.layers.length; r++)
                                    if ("imagelayer" === t.layers[r].type) {
                                        var p = {
                                            name: t.layers[r].name,
                                            image: t.layers[r].image,
                                            x: t.layers[r].x,
                                            y: t.layers[r].y,
                                            alpha: t.layers[r].opacity,
                                            visible: t.layers[r].visible,
                                            properties: {}
                                        };
                                        t.layers[r].properties && (p.properties = t.layers[r].properties), d.push(p)
                                    }
                                i.images = d;
                                for (var f = [], r = 0; r < t.tilesets.length; r++) {
                                    var g = t.tilesets[r],
                                        m = new n.Tileset(g.name, g.firstgid, g.tilewidth, g.tileheight, g.margin, g.spacing, g.properties);
                                    g.tileproperties && (m.tileProperties = g.tileproperties), m.rows = Math.round((g.imageheight - g.margin) / (g.tileheight + g.spacing)), m.columns = Math.round((g.imagewidth - g.margin) / (g.tilewidth + g.spacing)), m.total = m.rows * m.columns, m.rows % 1 !== 0 || m.columns % 1 !== 0 ? console.warn("TileSet image dimensions do not match expected dimensions. Tileset width/height must be evenly divisible by Tilemap tile width/height.") : f.push(m)
                                }
                                i.tilesets = f;
                                for (var y = {}, v = {}, r = 0; r < t.layers.length; r++)
                                    if ("objectgroup" === t.layers[r].type) {
                                        y[t.layers[r].name] = [], v[t.layers[r].name] = [];
                                        for (var x = 0, u = t.layers[r].objects.length; u > x; x++)
                                            if (t.layers[r].objects[x].gid) {
                                                var b = {
                                                    gid: t.layers[r].objects[x].gid,
                                                    name: t.layers[r].objects[x].name,
                                                    x: t.layers[r].objects[x].x,
                                                    y: t.layers[r].objects[x].y,
                                                    visible: t.layers[r].objects[x].visible,
                                                    properties: t.layers[r].objects[x].properties
                                                };
                                                y[t.layers[r].name].push(b)
                                            } else if (t.layers[r].objects[x].polyline) {
                                            var b = {
                                                name: t.layers[r].objects[x].name,
                                                x: t.layers[r].objects[x].x,
                                                y: t.layers[r].objects[x].y,
                                                width: t.layers[r].objects[x].width,
                                                height: t.layers[r].objects[x].height,
                                                visible: t.layers[r].objects[x].visible,
                                                properties: t.layers[r].objects[x].properties
                                            };
                                            b.polyline = [];
                                            for (var _ = 0; _ < t.layers[r].objects[x].polyline.length; _++) b.polyline.push([t.layers[r].objects[x].polyline[_].x, t.layers[r].objects[x].polyline[_].y]);
                                            v[t.layers[r].name].push(b)
                                        } else if (t.layers[r].objects[x].polygon) {
                                            var b = e(t.layers[r].objects[x], ["name", "x", "y", "visible", "properties"]);
                                            b.polygon = [];
                                            for (var _ = 0; _ < t.layers[r].objects[x].polygon.length; _++) b.polygon.push([t.layers[r].objects[x].polygon[_].x, t.layers[r].objects[x].polygon[_].y]);
                                            y[t.layers[r].name].push(b)
                                        } else if (t.layers[r].objects[x].ellipse) {
                                            var b = e(t.layers[r].objects[x], ["name", "ellipse", "x", "y", "width", "height", "visible", "properties"]);
                                            y[t.layers[r].name].push(b)
                                        } else {
                                            var b = e(t.layers[r].objects[x], ["name", "x", "y", "width", "height", "visible", "properties"]);
                                            b.rectangle = !0, y[t.layers[r].name].push(b)
                                        }
                                    }
                                i.objects = y, i.collision = v, i.tiles = [];
                                for (var r = 0; r < i.tilesets.length; r++)
                                    for (var g = i.tilesets[r], a = g.tileMargin, w = g.tileMargin, P = 0, T = 0, S = 0, c = g.firstgid; c < g.firstgid + g.total && (i.tiles[c] = [a, w, r], a += g.tileWidth + g.tileSpacing, P++, P !== g.total) && (T++, T !== g.columns || (a = g.tileMargin, w += g.tileHeight + g.tileSpacing, T = 0, S++, S !== g.rows)); c++);
                                return i
                            }
                        }, n.Tileset = function(t, e, i, s, n, r, o) {
                            ("undefined" == typeof i || 0 >= i) && (i = 32), ("undefined" == typeof s || 0 >= s) && (s = 32), "undefined" == typeof n && (n = 0), "undefined" == typeof r && (r = 0), this.name = t, this.firstgid = e, this.tileWidth = i, this.tileHeight = s, this.tileMargin = n, this.tileSpacing = r, this.properties = o, this.image = null, this.rows = 0, this.columns = 0, this.total = 0, this.drawCoords = []
                        }, n.Tileset.prototype = {
                            draw: function(t, e, i, s) {
                                this.image && this.drawCoords[s] && t.drawImage(this.image, this.drawCoords[s][0], this.drawCoords[s][1], this.tileWidth, this.tileHeight, e, i, this.tileWidth, this.tileHeight)
                            },
                            setImage: function(t) {
                                this.image = t, this.rows = Math.round((t.height - this.tileMargin) / (this.tileHeight + this.tileSpacing)), this.columns = Math.round((t.width - this.tileMargin) / (this.tileWidth + this.tileSpacing)), this.total = this.rows * this.columns, this.drawCoords.length = 0;
                                for (var e = this.tileMargin, i = this.tileMargin, s = this.firstgid, n = 0; n < this.rows; n++) {
                                    for (var r = 0; r < this.columns; r++) this.drawCoords[s] = [e, i], e += this.tileWidth + this.tileSpacing, s++;
                                    e = this.tileMargin, i += this.tileHeight + this.tileSpacing
                                }
                            },
                            setSpacing: function(t, e) {
                                this.tileMargin = t, this.tileSpacing = e, this.setImage(this.image)
                            }
                        }, n.Tileset.prototype.constructor = n.Tileset, "undefined" != typeof e ? ("undefined" != typeof t && t.exports && (e = t.exports = n), e.Phaser = n) : "undefined" != typeof i && i.amd ? i("Phaser", function() {
                            return s.Phaser = n
                        }()) : s.Phaser = n
                    }.call(this), s("undefined" != typeof Phaser ? Phaser : window.Phaser)
            }).call(t, void 0, void 0, void 0, function(t) {
                e.exports = t
            })
        }).call(this, "undefined" != typeof self ? self : "undefined" != typeof window ? window : {})
    }, {}],
    phaser: [function(t, e) {
        e.exports = t("AqMBDX")
    }, {}],
    5: [function(t, e) {
        (function(t) {
            function i() {
                for (; n.next;) {
                    n = n.next;
                    var t = n.task;
                    n.task = void 0;
                    var e = n.domain;
                    e && (n.domain = void 0, e.enter());
                    try {
                        t()
                    } catch (s) {
                        if (h) throw e && e.exit(), setTimeout(i, 0), e && e.enter(), s;
                        setTimeout(function() {
                            throw s
                        }, 0)
                    }
                    e && e.exit()
                }
                o = !1
            }

            function s(e) {
                r = r.next = {
                    task: e,
                    domain: h && t.domain,
                    next: null
                }, o || (o = !0, a())
            }
            var n = {
                    task: void 0,
                    next: null
                },
                r = n,
                o = !1,
                a = void 0,
                h = !1;
            if ("undefined" != typeof t && t.nextTick) h = !0, a = function() {
                t.nextTick(i)
            };
            else if ("function" == typeof setImmediate) a = "undefined" != typeof window ? setImmediate.bind(window, i) : function() {
                setImmediate(i)
            };
            else if ("undefined" != typeof MessageChannel) {
                var l = new MessageChannel;
                l.port1.onmessage = i, a = function() {
                    l.port2.postMessage(0)
                }
            } else a = function() {
                setTimeout(i, 0)
            };
            e.exports = s
        }).call(this, t("rH1JPG"))
    }, {
        rH1JPG: 8
    }],
    6: [function(t, e) {
        function i() {
            this._events = this._events || {}, this._maxListeners = this._maxListeners || void 0
        }

        function s(t) {
            return "function" == typeof t
        }

        function n(t) {
            return "number" == typeof t
        }

        function r(t) {
            return "object" == typeof t && null !== t
        }

        function o(t) {
            return void 0 === t
        }
        e.exports = i, i.EventEmitter = i, i.prototype._events = void 0, i.prototype._maxListeners = void 0, i.defaultMaxListeners = 10, i.prototype.setMaxListeners = function(t) {
            if (!n(t) || 0 > t || isNaN(t)) throw TypeError("n must be a positive number");
            return this._maxListeners = t, this
        }, i.prototype.emit = function(t) {
            var e, i, n, a, h, l;
            if (this._events || (this._events = {}), "error" === t && (!this._events.error || r(this._events.error) && !this._events.error.length)) {
                if (e = arguments[1], e instanceof Error) throw e;
                throw TypeError('Uncaught, unspecified "error" event.')
            }
            if (i = this._events[t], o(i)) return !1;
            if (s(i)) switch (arguments.length) {
                case 1:
                    i.call(this);
                    break;
                case 2:
                    i.call(this, arguments[1]);
                    break;
                case 3:
                    i.call(this, arguments[1], arguments[2]);
                    break;
                default:
                    for (n = arguments.length, a = new Array(n - 1), h = 1; n > h; h++) a[h - 1] = arguments[h];
                    i.apply(this, a)
            } else if (r(i)) {
                for (n = arguments.length, a = new Array(n - 1), h = 1; n > h; h++) a[h - 1] = arguments[h];
                for (l = i.slice(), n = l.length, h = 0; n > h; h++) l[h].apply(this, a)
            }
            return !0
        }, i.prototype.addListener = function(t, e) {
            var n;
            if (!s(e)) throw TypeError("listener must be a function");
            if (this._events || (this._events = {}), this._events.newListener && this.emit("newListener", t, s(e.listener) ? e.listener : e), this._events[t] ? r(this._events[t]) ? this._events[t].push(e) : this._events[t] = [this._events[t], e] : this._events[t] = e, r(this._events[t]) && !this._events[t].warned) {
                var n;
                n = o(this._maxListeners) ? i.defaultMaxListeners : this._maxListeners, n && n > 0 && this._events[t].length > n && (this._events[t].warned = !0, console.error("(node) warning: possible EventEmitter memory leak detected. %d listeners added. Use emitter.setMaxListeners() to increase limit.", this._events[t].length), "function" == typeof console.trace && console.trace())
            }
            return this
        }, i.prototype.on = i.prototype.addListener, i.prototype.once = function(t, e) {
            function i() {
                this.removeListener(t, i), n || (n = !0, e.apply(this, arguments))
            }
            if (!s(e)) throw TypeError("listener must be a function");
            var n = !1;
            return i.listener = e, this.on(t, i), this
        }, i.prototype.removeListener = function(t, e) {
            var i, n, o, a;
            if (!s(e)) throw TypeError("listener must be a function");
            if (!this._events || !this._events[t]) return this;
            if (i = this._events[t], o = i.length, n = -1, i === e || s(i.listener) && i.listener === e) delete this._events[t], this._events.removeListener && this.emit("removeListener", t, e);
            else if (r(i)) {
                for (a = o; a-- > 0;)
                    if (i[a] === e || i[a].listener && i[a].listener === e) {
                        n = a;
                        break
                    }
                if (0 > n) return this;
                1 === i.length ? (i.length = 0, delete this._events[t]) : i.splice(n, 1), this._events.removeListener && this.emit("removeListener", t, e)
            }
            return this
        }, i.prototype.removeAllListeners = function(t) {
            var e, i;
            if (!this._events) return this;
            if (!this._events.removeListener) return 0 === arguments.length ? this._events = {} : this._events[t] && delete this._events[t], this;
            if (0 === arguments.length) {
                for (e in this._events) "removeListener" !== e && this.removeAllListeners(e);
                return this.removeAllListeners("removeListener"), this._events = {}, this
            }
            if (i = this._events[t], s(i)) this.removeListener(t, i);
            else
                for (; i.length;) this.removeListener(t, i[i.length - 1]);
            return delete this._events[t], this
        }, i.prototype.listeners = function(t) {
            var e;
            return e = this._events && this._events[t] ? s(this._events[t]) ? [this._events[t]] : this._events[t].slice() : []
        }, i.listenerCount = function(t, e) {
            var i;
            return i = t._events && t._events[e] ? s(t._events[e]) ? 1 : t._events[e].length : 0
        }
    }, {}],
    7: [function(t, e) {
        e.exports = "function" == typeof Object.create ? function(t, e) {
            t.super_ = e, t.prototype = Object.create(e.prototype, {
                constructor: {
                    value: t,
                    enumerable: !1,
                    writable: !0,
                    configurable: !0
                }
            })
        } : function(t, e) {
            t.super_ = e;
            var i = function() {};
            i.prototype = e.prototype, t.prototype = new i, t.prototype.constructor = t
        }
    }, {}],
    8: [function(t, e) {
        function i() {}
        var s = e.exports = {};
        s.nextTick = function() {
            var t = "undefined" != typeof window && window.setImmediate,
                e = "undefined" != typeof window && window.postMessage && window.addEventListener;
            if (t) return function(t) {
                return window.setImmediate(t)
            };
            if (e) {
                var i = [];
                return window.addEventListener("message", function(t) {
                        var e = t.source;
                        if ((e === window || null === e) && "process-tick" === t.data && (t.stopPropagation(), i.length > 0)) {
                            var s = i.shift();
                            s()
                        }
                    }, !0),
                    function(t) {
                        i.push(t), window.postMessage("process-tick", "*")
                    }
            }
            return function(t) {
                setTimeout(t, 0)
            }
        }(), s.title = "browser", s.browser = !0, s.env = {}, s.argv = [], s.on = i, s.addListener = i, s.once = i, s.off = i, s.removeListener = i, s.removeAllListeners = i, s.emit = i, s.binding = function() {
            throw new Error("process.binding is not supported")
        }, s.cwd = function() {
            return "/"
        }, s.chdir = function() {
            throw new Error("process.chdir is not supported")
        }
    }, {}],
    9: [function(t, e) {
        "use strict";

        function i(t) {
            function e(t) {
                return null === l ? (u.push(t), void 0) : (r(function() {
                    var e = l ? t.onFulfilled : t.onRejected;
                    if (null === e) return (l ? t.resolve : t.reject)(c), void 0;
                    var i;
                    try {
                        i = e(c)
                    } catch (s) {
                        return t.reject(s), void 0
                    }
                    t.resolve(i)
                }), void 0)
            }

            function o(t) {
                try {
                    if (t === d) throw new TypeError("A promise cannot be resolved with itself.");
                    if (t && ("object" == typeof t || "function" == typeof t)) {
                        var e = t.then;
                        if ("function" == typeof e) return n(e.bind(t), o, a), void 0
                    }
                    l = !0, c = t, h()
                } catch (i) {
                    a(i)
                }
            }

            function a(t) {
                l = !1, c = t, h()
            }

            function h() {
                for (var t = 0, i = u.length; i > t; t++) e(u[t]);
                u = null
            }
            if ("object" != typeof this) throw new TypeError("Promises must be constructed via new");
            if ("function" != typeof t) throw new TypeError("not a function");
            var l = null,
                c = null,
                u = [],
                d = this;
            this.then = function(t, n) {
                return new i(function(i, r) {
                    e(new s(t, n, i, r))
                })
            }, n(t, o, a)
        }

        function s(t, e, i, s) {
            this.onFulfilled = "function" == typeof t ? t : null, this.onRejected = "function" == typeof e ? e : null, this.resolve = i, this.reject = s
        }

        function n(t, e, i) {
            var s = !1;
            try {
                t(function(t) {
                    s || (s = !0, e(t))
                }, function(t) {
                    s || (s = !0, i(t))
                })
            } catch (n) {
                if (s) return;
                s = !0, i(n)
            }
        }
        var r = t("asap");
        e.exports = i
    }, {
        asap: 5
    }],
    10: [function(t, e) {
        "use strict";

        function i(t) {
            this.then = function(e) {
                return "function" != typeof e ? this : new s(function(i, s) {
                    n(function() {
                        try {
                            i(e(t))
                        } catch (n) {
                            s(n)
                        }
                    })
                })
            }
        }
        var s = t("./core.js"),
            n = t("asap");
        e.exports = s, i.prototype = Object.create(s.prototype);
        var r = new i(!0),
            o = new i(!1),
            a = new i(null),
            h = new i(void 0),
            l = new i(0),
            c = new i("");
        s.resolve = function(t) {
            if (t instanceof s) return t;
            if (null === t) return a;
            if (void 0 === t) return h;
            if (t === !0) return r;
            if (t === !1) return o;
            if (0 === t) return l;
            if ("" === t) return c;
            if ("object" == typeof t || "function" == typeof t) try {
                var e = t.then;
                if ("function" == typeof e) return new s(e.bind(t))
            } catch (n) {
                return new s(function(t, e) {
                    e(n)
                })
            }
            return new i(t)
        }, s.from = s.cast = function(t) {
            var e = new Error("Promise.from and Promise.cast are deprecated, use Promise.resolve instead");
            return e.name = "Warning", console.warn(e.stack), s.resolve(t)
        }, s.denodeify = function(t, e) {
            return e = e || 1 / 0,
                function() {
                    var i = this,
                        n = Array.prototype.slice.call(arguments);
                    return new s(function(s, r) {
                        for (; n.length && n.length > e;) n.pop();
                        n.push(function(t, e) {
                            t ? r(t) : s(e)
                        }), t.apply(i, n)
                    })
                }
        }, s.nodeify = function(t) {
            return function() {
                var e = Array.prototype.slice.call(arguments),
                    i = "function" == typeof e[e.length - 1] ? e.pop() : null;
                try {
                    return t.apply(this, arguments).nodeify(i)
                } catch (r) {
                    if (null === i || "undefined" == typeof i) return new s(function(t, e) {
                        e(r)
                    });
                    n(function() {
                        i(r)
                    })
                }
            }
        }, s.all = function() {
            var t = 1 === arguments.length && Array.isArray(arguments[0]),
                e = Array.prototype.slice.call(t ? arguments[0] : arguments);
            if (!t) {
                var i = new Error("Promise.all should be called with a single array, calling it with multiple arguments is deprecated");
                i.name = "Warning", console.warn(i.stack)
            }
            return new s(function(t, i) {
                function s(r, o) {
                    try {
                        if (o && ("object" == typeof o || "function" == typeof o)) {
                            var a = o.then;
                            if ("function" == typeof a) return a.call(o, function(t) {
                                s(r, t)
                            }, i), void 0
                        }
                        e[r] = o, 0 === --n && t(e)
                    } catch (h) {
                        i(h)
                    }
                }
                if (0 === e.length) return t([]);
                for (var n = e.length, r = 0; r < e.length; r++) s(r, e[r])
            })
        }, s.reject = function(t) {
            return new s(function(e, i) {
                i(t)
            })
        }, s.race = function(t) {
            return new s(function(e, i) {
                t.forEach(function(t) {
                    s.resolve(t).then(e, i)
                })
            })
        }, s.prototype.done = function() {
            var t = arguments.length ? this.then.apply(this, arguments) : this;
            t.then(null, function(t) {
                n(function() {
                    throw t
                })
            })
        }, s.prototype.nodeify = function(t) {
            return "function" != typeof t ? this : (this.then(function(e) {
                n(function() {
                    t(null, e)
                })
            }, function(e) {
                n(function() {
                    t(e)
                })
            }), void 0)
        }, s.prototype["catch"] = function(t) {
            return this.then(null, t)
        }
    }, {
        "./core.js": 9,
        asap: 5
    }],
    11: [function(t, e, i) {
        (function() {
            var t = this,
                s = t._,
                n = {},
                r = Array.prototype,
                o = Object.prototype,
                a = Function.prototype,
                h = r.push,
                l = r.slice,
                c = r.concat,
                u = o.toString,
                d = o.hasOwnProperty,
                p = r.forEach,
                f = r.map,
                g = r.reduce,
                m = r.reduceRight,
                y = r.filter,
                v = r.every,
                x = r.some,
                b = r.indexOf,
                _ = r.lastIndexOf,
                w = Array.isArray,
                P = Object.keys,
                T = a.bind,
                S = function(t) {
                    return t instanceof S ? t : this instanceof S ? (this._wrapped = t, void 0) : new S(t)
                };
            "undefined" != typeof i ? ("undefined" != typeof e && e.exports && (i = e.exports = S), i._ = S) : t._ = S, S.VERSION = "1.6.0";
            var C = S.each = S.forEach = function(t, e, i) {
                if (null == t) return t;
                if (p && t.forEach === p) t.forEach(e, i);
                else if (t.length === +t.length) {
                    for (var s = 0, r = t.length; r > s; s++)
                        if (e.call(i, t[s], s, t) === n) return
                } else
                    for (var o = S.keys(t), s = 0, r = o.length; r > s; s++)
                        if (e.call(i, t[o[s]], o[s], t) === n) return;
                return t
            };
            S.map = S.collect = function(t, e, i) {
                var s = [];
                return null == t ? s : f && t.map === f ? t.map(e, i) : (C(t, function(t, n, r) {
                    s.push(e.call(i, t, n, r))
                }), s)
            };
            var A = "Reduce of empty array with no initial value";
            S.reduce = S.foldl = S.inject = function(t, e, i, s) {
                var n = arguments.length > 2;
                if (null == t && (t = []), g && t.reduce === g) return s && (e = S.bind(e, s)), n ? t.reduce(e, i) : t.reduce(e);
                if (C(t, function(t, r, o) {
                        n ? i = e.call(s, i, t, r, o) : (i = t, n = !0)
                    }), !n) throw new TypeError(A);
                return i
            }, S.reduceRight = S.foldr = function(t, e, i, s) {
                var n = arguments.length > 2;
                if (null == t && (t = []), m && t.reduceRight === m) return s && (e = S.bind(e, s)), n ? t.reduceRight(e, i) : t.reduceRight(e);
                var r = t.length;
                if (r !== +r) {
                    var o = S.keys(t);
                    r = o.length
                }
                if (C(t, function(a, h, l) {
                        h = o ? o[--r] : --r, n ? i = e.call(s, i, t[h], h, l) : (i = t[h], n = !0)
                    }), !n) throw new TypeError(A);
                return i
            }, S.find = S.detect = function(t, e, i) {
                var s;
                return E(t, function(t, n, r) {
                    return e.call(i, t, n, r) ? (s = t, !0) : void 0
                }), s
            }, S.filter = S.select = function(t, e, i) {
                var s = [];
                return null == t ? s : y && t.filter === y ? t.filter(e, i) : (C(t, function(t, n, r) {
                    e.call(i, t, n, r) && s.push(t)
                }), s)
            }, S.reject = function(t, e, i) {
                return S.filter(t, function(t, s, n) {
                    return !e.call(i, t, s, n)
                }, i)
            }, S.every = S.all = function(t, e, i) {
                e || (e = S.identity);
                var s = !0;
                return null == t ? s : v && t.every === v ? t.every(e, i) : (C(t, function(t, r, o) {
                    return (s = s && e.call(i, t, r, o)) ? void 0 : n
                }), !!s)
            };
            var E = S.some = S.any = function(t, e, i) {
                e || (e = S.identity);
                var s = !1;
                return null == t ? s : x && t.some === x ? t.some(e, i) : (C(t, function(t, r, o) {
                    return s || (s = e.call(i, t, r, o)) ? n : void 0
                }), !!s)
            };
            S.contains = S.include = function(t, e) {
                return null == t ? !1 : b && t.indexOf === b ? -1 != t.indexOf(e) : E(t, function(t) {
                    return t === e
                })
            }, S.invoke = function(t, e) {
                var i = l.call(arguments, 2),
                    s = S.isFunction(e);
                return S.map(t, function(t) {
                    return (s ? e : t[e]).apply(t, i)
                })
            }, S.pluck = function(t, e) {
                return S.map(t, S.property(e))
            }, S.where = function(t, e) {
                return S.filter(t, S.matches(e))
            }, S.findWhere = function(t, e) {
                return S.find(t, S.matches(e))
            }, S.max = function(t, e, i) {
                if (!e && S.isArray(t) && t[0] === +t[0] && t.length < 65535) return Math.max.apply(Math, t);
                var s = -1 / 0,
                    n = -1 / 0;
                return C(t, function(t, r, o) {
                    var a = e ? e.call(i, t, r, o) : t;
                    a > n && (s = t, n = a)
                }), s
            }, S.min = function(t, e, i) {
                if (!e && S.isArray(t) && t[0] === +t[0] && t.length < 65535) return Math.min.apply(Math, t);
                var s = 1 / 0,
                    n = 1 / 0;
                return C(t, function(t, r, o) {
                    var a = e ? e.call(i, t, r, o) : t;
                    n > a && (s = t, n = a)
                }), s
            }, S.shuffle = function(t) {
                var e, i = 0,
                    s = [];
                return C(t, function(t) {
                    e = S.random(i++), s[i - 1] = s[e], s[e] = t
                }), s
            }, S.sample = function(t, e, i) {
                return null == e || i ? (t.length !== +t.length && (t = S.values(t)), t[S.random(t.length - 1)]) : S.shuffle(t).slice(0, Math.max(0, e))
            };
            var M = function(t) {
                return null == t ? S.identity : S.isFunction(t) ? t : S.property(t)
            };
            S.sortBy = function(t, e, i) {
                return e = M(e), S.pluck(S.map(t, function(t, s, n) {
                    return {
                        value: t,
                        index: s,
                        criteria: e.call(i, t, s, n)
                    }
                }).sort(function(t, e) {
                    var i = t.criteria,
                        s = e.criteria;
                    if (i !== s) {
                        if (i > s || void 0 === i) return 1;
                        if (s > i || void 0 === s) return -1
                    }
                    return t.index - e.index
                }), "value")
            };
            var L = function(t) {
                return function(e, i, s) {
                    var n = {};
                    return i = M(i), C(e, function(r, o) {
                        var a = i.call(s, r, o, e);
                        t(n, a, r)
                    }), n
                }
            };
            S.groupBy = L(function(t, e, i) {
                S.has(t, e) ? t[e].push(i) : t[e] = [i]
            }), S.indexBy = L(function(t, e, i) {
                t[e] = i
            }), S.countBy = L(function(t, e) {
                S.has(t, e) ? t[e]++ : t[e] = 1
            }), S.sortedIndex = function(t, e, i, s) {
                i = M(i);
                for (var n = i.call(s, e), r = 0, o = t.length; o > r;) {
                    var a = r + o >>> 1;
                    i.call(s, t[a]) < n ? r = a + 1 : o = a
                }
                return r
            }, S.toArray = function(t) {
                return t ? S.isArray(t) ? l.call(t) : t.length === +t.length ? S.map(t, S.identity) : S.values(t) : []
            }, S.size = function(t) {
                return null == t ? 0 : t.length === +t.length ? t.length : S.keys(t).length
            }, S.first = S.head = S.take = function(t, e, i) {
                return null == t ? void 0 : null == e || i ? t[0] : 0 > e ? [] : l.call(t, 0, e)
            }, S.initial = function(t, e, i) {
                return l.call(t, 0, t.length - (null == e || i ? 1 : e))
            }, S.last = function(t, e, i) {
                return null == t ? void 0 : null == e || i ? t[t.length - 1] : l.call(t, Math.max(t.length - e, 0))
            }, S.rest = S.tail = S.drop = function(t, e, i) {
                return l.call(t, null == e || i ? 1 : e)
            }, S.compact = function(t) {
                return S.filter(t, S.identity)
            };
            var R = function(t, e, i) {
                return e && S.every(t, S.isArray) ? c.apply(i, t) : (C(t, function(t) {
                    S.isArray(t) || S.isArguments(t) ? e ? h.apply(i, t) : R(t, e, i) : i.push(t)
                }), i)
            };
            S.flatten = function(t, e) {
                return R(t, e, [])
            }, S.without = function(t) {
                return S.difference(t, l.call(arguments, 1))
            }, S.partition = function(t, e) {
                var i = [],
                    s = [];
                return C(t, function(t) {
                    (e(t) ? i : s).push(t)
                }), [i, s]
            }, S.uniq = S.unique = function(t, e, i, s) {
                S.isFunction(e) && (s = i, i = e, e = !1);
                var n = i ? S.map(t, i, s) : t,
                    r = [],
                    o = [];
                return C(n, function(i, s) {
                    (e ? s && o[o.length - 1] === i : S.contains(o, i)) || (o.push(i), r.push(t[s]))
                }), r
            }, S.union = function() {
                return S.uniq(S.flatten(arguments, !0))
            }, S.intersection = function(t) {
                var e = l.call(arguments, 1);
                return S.filter(S.uniq(t), function(t) {
                    return S.every(e, function(e) {
                        return S.contains(e, t)
                    })
                })
            }, S.difference = function(t) {
                var e = c.apply(r, l.call(arguments, 1));
                return S.filter(t, function(t) {
                    return !S.contains(e, t)
                })
            }, S.zip = function() {
                for (var t = S.max(S.pluck(arguments, "length").concat(0)), e = new Array(t), i = 0; t > i; i++) e[i] = S.pluck(arguments, "" + i);
                return e
            }, S.object = function(t, e) {
                if (null == t) return {};
                for (var i = {}, s = 0, n = t.length; n > s; s++) e ? i[t[s]] = e[s] : i[t[s][0]] = t[s][1];
                return i
            }, S.indexOf = function(t, e, i) {
                if (null == t) return -1;
                var s = 0,
                    n = t.length;
                if (i) {
                    if ("number" != typeof i) return s = S.sortedIndex(t, e), t[s] === e ? s : -1;
                    s = 0 > i ? Math.max(0, n + i) : i
                }
                if (b && t.indexOf === b) return t.indexOf(e, i);
                for (; n > s; s++)
                    if (t[s] === e) return s;
                return -1
            }, S.lastIndexOf = function(t, e, i) {
                if (null == t) return -1;
                var s = null != i;
                if (_ && t.lastIndexOf === _) return s ? t.lastIndexOf(e, i) : t.lastIndexOf(e);
                for (var n = s ? i : t.length; n--;)
                    if (t[n] === e) return n;
                return -1
            }, S.range = function(t, e, i) {
                arguments.length <= 1 && (e = t || 0, t = 0), i = arguments[2] || 1;
                for (var s = Math.max(Math.ceil((e - t) / i), 0), n = 0, r = new Array(s); s > n;) r[n++] = t, t += i;
                return r
            };
            var B = function() {};
            S.bind = function(t, e) {
                var i, s;
                if (T && t.bind === T) return T.apply(t, l.call(arguments, 1));
                if (!S.isFunction(t)) throw new TypeError;
                return i = l.call(arguments, 2), s = function() {
                    if (!(this instanceof s)) return t.apply(e, i.concat(l.call(arguments)));
                    B.prototype = t.prototype;
                    var n = new B;
                    B.prototype = null;
                    var r = t.apply(n, i.concat(l.call(arguments)));
                    return Object(r) === r ? r : n
                }
            }, S.partial = function(t) {
                var e = l.call(arguments, 1);
                return function() {
                    for (var i = 0, s = e.slice(), n = 0, r = s.length; r > n; n++) s[n] === S && (s[n] = arguments[i++]);
                    for (; i < arguments.length;) s.push(arguments[i++]);
                    return t.apply(this, s)
                }
            }, S.bindAll = function(t) {
                var e = l.call(arguments, 1);
                if (0 === e.length) throw new Error("bindAll must be passed function names");
                return C(e, function(e) {
                    t[e] = S.bind(t[e], t)
                }), t
            }, S.memoize = function(t, e) {
                var i = {};
                return e || (e = S.identity),
                    function() {
                        var s = e.apply(this, arguments);
                        return S.has(i, s) ? i[s] : i[s] = t.apply(this, arguments)
                    }
            }, S.delay = function(t, e) {
                var i = l.call(arguments, 2);
                return setTimeout(function() {
                    return t.apply(null, i)
                }, e)
            }, S.defer = function(t) {
                return S.delay.apply(S, [t, 1].concat(l.call(arguments, 1)))
            }, S.throttle = function(t, e, i) {
                var s, n, r, o = null,
                    a = 0;
                i || (i = {});
                var h = function() {
                    a = i.leading === !1 ? 0 : S.now(), o = null, r = t.apply(s, n), s = n = null
                };
                return function() {
                    var l = S.now();
                    a || i.leading !== !1 || (a = l);
                    var c = e - (l - a);
                    return s = this, n = arguments, 0 >= c ? (clearTimeout(o), o = null, a = l, r = t.apply(s, n), s = n = null) : o || i.trailing === !1 || (o = setTimeout(h, c)), r
                }
            }, S.debounce = function(t, e, i) {
                var s, n, r, o, a, h = function() {
                    var l = S.now() - o;
                    e > l ? s = setTimeout(h, e - l) : (s = null, i || (a = t.apply(r, n), r = n = null))
                };
                return function() {
                    r = this, n = arguments, o = S.now();
                    var l = i && !s;
                    return s || (s = setTimeout(h, e)), l && (a = t.apply(r, n), r = n = null), a
                }
            }, S.once = function(t) {
                var e, i = !1;
                return function() {
                    return i ? e : (i = !0, e = t.apply(this, arguments), t = null, e)
                }
            }, S.wrap = function(t, e) {
                return S.partial(e, t)
            }, S.compose = function() {
                var t = arguments;
                return function() {
                    for (var e = arguments, i = t.length - 1; i >= 0; i--) e = [t[i].apply(this, e)];
                    return e[0]
                }
            }, S.after = function(t, e) {
                return function() {
                    return --t < 1 ? e.apply(this, arguments) : void 0
                }
            }, S.keys = function(t) {
                if (!S.isObject(t)) return [];
                if (P) return P(t);
                var e = [];
                for (var i in t) S.has(t, i) && e.push(i);
                return e
            }, S.values = function(t) {
                for (var e = S.keys(t), i = e.length, s = new Array(i), n = 0; i > n; n++) s[n] = t[e[n]];
                return s
            }, S.pairs = function(t) {
                for (var e = S.keys(t), i = e.length, s = new Array(i), n = 0; i > n; n++) s[n] = [e[n], t[e[n]]];
                return s
            }, S.invert = function(t) {
                for (var e = {}, i = S.keys(t), s = 0, n = i.length; n > s; s++) e[t[i[s]]] = i[s];
                return e
            }, S.functions = S.methods = function(t) {
                var e = [];
                for (var i in t) S.isFunction(t[i]) && e.push(i);
                return e.sort()
            }, S.extend = function(t) {
                return C(l.call(arguments, 1), function(e) {
                    if (e)
                        for (var i in e) t[i] = e[i]
                }), t
            }, S.pick = function(t) {
                var e = {},
                    i = c.apply(r, l.call(arguments, 1));
                return C(i, function(i) {
                    i in t && (e[i] = t[i])
                }), e
            }, S.omit = function(t) {
                var e = {},
                    i = c.apply(r, l.call(arguments, 1));
                for (var s in t) S.contains(i, s) || (e[s] = t[s]);
                return e
            }, S.defaults = function(t) {
                return C(l.call(arguments, 1), function(e) {
                    if (e)
                        for (var i in e) void 0 === t[i] && (t[i] = e[i])
                }), t
            }, S.clone = function(t) {
                return S.isObject(t) ? S.isArray(t) ? t.slice() : S.extend({}, t) : t
            }, S.tap = function(t, e) {
                return e(t), t
            };
            var O = function(t, e, i, s) {
                if (t === e) return 0 !== t || 1 / t == 1 / e;
                if (null == t || null == e) return t === e;
                t instanceof S && (t = t._wrapped), e instanceof S && (e = e._wrapped);
                var n = u.call(t);
                if (n != u.call(e)) return !1;
                switch (n) {
                    case "[object String]":
                        return t == String(e);
                    case "[object Number]":
                        return t != +t ? e != +e : 0 == t ? 1 / t == 1 / e : t == +e;
                    case "[object Date]":
                    case "[object Boolean]":
                        return +t == +e;
                    case "[object RegExp]":
                        return t.source == e.source && t.global == e.global && t.multiline == e.multiline && t.ignoreCase == e.ignoreCase
                }
                if ("object" != typeof t || "object" != typeof e) return !1;
                for (var r = i.length; r--;)
                    if (i[r] == t) return s[r] == e;
                var o = t.constructor,
                    a = e.constructor;
                if (o !== a && !(S.isFunction(o) && o instanceof o && S.isFunction(a) && a instanceof a) && "constructor" in t && "constructor" in e) return !1;
                i.push(t), s.push(e);
                var h = 0,
                    l = !0;
                if ("[object Array]" == n) {
                    if (h = t.length, l = h == e.length)
                        for (; h-- && (l = O(t[h], e[h], i, s)););
                } else {
                    for (var c in t)
                        if (S.has(t, c) && (h++, !(l = S.has(e, c) && O(t[c], e[c], i, s)))) break;
                    if (l) {
                        for (c in e)
                            if (S.has(e, c) && !h--) break;
                        l = !h
                    }
                }
                return i.pop(), s.pop(), l
            };
            S.isEqual = function(t, e) {
                return O(t, e, [], [])
            }, S.isEmpty = function(t) {
                if (null == t) return !0;
                if (S.isArray(t) || S.isString(t)) return 0 === t.length;
                for (var e in t)
                    if (S.has(t, e)) return !1;
                return !0
            }, S.isElement = function(t) {
                return !(!t || 1 !== t.nodeType)
            }, S.isArray = w || function(t) {
                return "[object Array]" == u.call(t)
            }, S.isObject = function(t) {
                return t === Object(t)
            }, C(["Arguments", "Function", "String", "Number", "Date", "RegExp"], function(t) {
                S["is" + t] = function(e) {
                    return u.call(e) == "[object " + t + "]"
                }
            }), S.isArguments(arguments) || (S.isArguments = function(t) {
                return !(!t || !S.has(t, "callee"))
            }), "function" != typeof /./ && (S.isFunction = function(t) {
                return "function" == typeof t
            }), S.isFinite = function(t) {
                return isFinite(t) && !isNaN(parseFloat(t))
            }, S.isNaN = function(t) {
                return S.isNumber(t) && t != +t
            }, S.isBoolean = function(t) {
                return t === !0 || t === !1 || "[object Boolean]" == u.call(t)
            }, S.isNull = function(t) {
                return null === t
            }, S.isUndefined = function(t) {
                return void 0 === t
            }, S.has = function(t, e) {
                return d.call(t, e)
            }, S.noConflict = function() {
                return t._ = s, this
            }, S.identity = function(t) {
                return t
            }, S.constant = function(t) {
                return function() {
                    return t
                }
            }, S.property = function(t) {
                return function(e) {
                    return e[t]
                }
            }, S.matches = function(t) {
                return function(e) {
                    if (e === t) return !0;
                    for (var i in t)
                        if (t[i] !== e[i]) return !1;
                    return !0
                }
            }, S.times = function(t, e, i) {
                for (var s = Array(Math.max(0, t)), n = 0; t > n; n++) s[n] = e.call(i, n);
                return s
            }, S.random = function(t, e) {
                return null == e && (e = t, t = 0), t + Math.floor(Math.random() * (e - t + 1))
            }, S.now = Date.now || function() {
                return (new Date).getTime()
            };
            var I = {
                escape: {
                    "&": "&amp;",
                    "<": "&lt;",
                    ">": "&gt;",
                    '"': "&quot;",
                    "'": "&#x27;"
                }
            };
            I.unescape = S.invert(I.escape);
            var k = {
                escape: new RegExp("[" + S.keys(I.escape).join("") + "]", "g"),
                unescape: new RegExp("(" + S.keys(I.unescape).join("|") + ")", "g")
            };
            S.each(["escape", "unescape"], function(t) {
                S[t] = function(e) {
                    return null == e ? "" : ("" + e).replace(k[t], function(e) {
                        return I[t][e]
                    })
                }
            }), S.result = function(t, e) {
                if (null == t) return void 0;
                var i = t[e];
                return S.isFunction(i) ? i.call(t) : i
            }, S.mixin = function(t) {
                C(S.functions(t), function(e) {
                    var i = S[e] = t[e];
                    S.prototype[e] = function() {
                        var t = [this._wrapped];
                        return h.apply(t, arguments), N.call(this, i.apply(S, t))
                    }
                })
            };
            var D = 0;
            S.uniqueId = function(t) {
                var e = ++D + "";
                return t ? t + e : e
            }, S.templateSettings = {
                evaluate: /<%([\s\S]+?)%>/g,
                interpolate: /<%=([\s\S]+?)%>/g,
                escape: /<%-([\s\S]+?)%>/g
            };
            var F = /(.)^/,
                G = {
                    "'": "'",
                    "\\": "\\",
                    "\r": "r",
                    "\n": "n",
                    "	": "t",
                    "\u2028": "u2028",
                    "\u2029": "u2029"
                },
                U = /\\|'|\r|\n|\t|\u2028|\u2029/g;
            S.template = function(t, e, i) {
                var s;
                i = S.defaults({}, i, S.templateSettings);
                var n = new RegExp([(i.escape || F).source, (i.interpolate || F).source, (i.evaluate || F).source].join("|") + "|$", "g"),
                    r = 0,
                    o = "__p+='";
                t.replace(n, function(e, i, s, n, a) {
                    return o += t.slice(r, a).replace(U, function(t) {
                        return "\\" + G[t]
                    }), i && (o += "'+\n((__t=(" + i + "))==null?'':_.escape(__t))+\n'"), s && (o += "'+\n((__t=(" + s + "))==null?'':__t)+\n'"), n && (o += "';\n" + n + "\n__p+='"), r = a + e.length, e
                }), o += "';\n", i.variable || (o = "with(obj||{}){\n" + o + "}\n"), o = "var __t,__p='',__j=Array.prototype.join,print=function(){__p+=__j.call(arguments,'');};\n" + o + "return __p;\n";
                try {
                    s = new Function(i.variable || "obj", "_", o)
                } catch (a) {
                    throw a.source = o, a
                }
                if (e) return s(e, S);
                var h = function(t) {
                    return s.call(this, t, S)
                };
                return h.source = "function(" + (i.variable || "obj") + "){\n" + o + "}", h
            }, S.chain = function(t) {
                return S(t).chain()
            };
            var N = function(t) {
                return this._chain ? S(t).chain() : t
            };
            S.mixin(S), C(["pop", "push", "reverse", "shift", "sort", "splice", "unshift"], function(t) {
                var e = r[t];
                S.prototype[t] = function() {
                    var i = this._wrapped;
                    return e.apply(i, arguments), "shift" != t && "splice" != t || 0 !== i.length || delete i[0], N.call(this, i)
                }
            }), C(["concat", "join", "slice"], function(t) {
                var e = r[t];
                S.prototype[t] = function() {
                    return N.call(this, e.apply(this._wrapped, arguments))
                }
            }), S.extend(S.prototype, {
                chain: function() {
                    return this._chain = !0, this
                },
                value: function() {
                    return this._wrapped
                }
            }), "function" == typeof define && define.amd && define("underscore", [], function() {
                return S
            })
        }).call(this)
    }, {}],
    12: [function(t, e) {
        e.exports = function(t) {
            return t && "object" == typeof t && "function" == typeof t.copy && "function" == typeof t.fill && "function" == typeof t.readUInt8
        }
    }, {}],
    13: [function(t, e, i) {
        (function(e, s) {
            function n(t, e) {
                var s = {
                    seen: [],
                    stylize: o
                };
                return arguments.length >= 3 && (s.depth = arguments[2]), arguments.length >= 4 && (s.colors = arguments[3]), g(e) ? s.showHidden = e : e && i._extend(s, e), _(s.showHidden) && (s.showHidden = !1), _(s.depth) && (s.depth = 2), _(s.colors) && (s.colors = !1), _(s.customInspect) && (s.customInspect = !0), s.colors && (s.stylize = r), h(s, t, s.depth)
            }

            function r(t, e) {
                var i = n.styles[e];
                return i ? "[" + n.colors[i][0] + "m" + t + "[" + n.colors[i][1] + "m" : t
            }

            function o(t) {
                return t
            }

            function a(t) {
                var e = {};
                return t.forEach(function(t) {
                    e[t] = !0
                }), e
            }

            function h(t, e, s) {
                if (t.customInspect && e && C(e.inspect) && e.inspect !== i.inspect && (!e.constructor || e.constructor.prototype !== e)) {
                    var n = e.inspect(s, t);
                    return x(n) || (n = h(t, n, s)), n
                }
                var r = l(t, e);
                if (r) return r;
                var o = Object.keys(e),
                    g = a(o);
                if (t.showHidden && (o = Object.getOwnPropertyNames(e)), S(e) && (o.indexOf("message") >= 0 || o.indexOf("description") >= 0)) return c(e);
                if (0 === o.length) {
                    if (C(e)) {
                        var m = e.name ? ": " + e.name : "";
                        return t.stylize("[Function" + m + "]", "special")
                    }
                    if (w(e)) return t.stylize(RegExp.prototype.toString.call(e), "regexp");
                    if (T(e)) return t.stylize(Date.prototype.toString.call(e), "date");
                    if (S(e)) return c(e)
                }
                var y = "",
                    v = !1,
                    b = ["{", "}"];
                if (f(e) && (v = !0, b = ["[", "]"]), C(e)) {
                    var _ = e.name ? ": " + e.name : "";
                    y = " [Function" + _ + "]"
                }
                if (w(e) && (y = " " + RegExp.prototype.toString.call(e)), T(e) && (y = " " + Date.prototype.toUTCString.call(e)), S(e) && (y = " " + c(e)), 0 === o.length && (!v || 0 == e.length)) return b[0] + y + b[1];
                if (0 > s) return w(e) ? t.stylize(RegExp.prototype.toString.call(e), "regexp") : t.stylize("[Object]", "special");
                t.seen.push(e);
                var P;
                return P = v ? u(t, e, s, g, o) : o.map(function(i) {
                    return d(t, e, s, g, i, v)
                }), t.seen.pop(), p(P, y, b)
            }

            function l(t, e) {
                if (_(e)) return t.stylize("undefined", "undefined");
                if (x(e)) {
                    var i = "'" + JSON.stringify(e).replace(/^"|"$/g, "").replace(/'/g, "\\'").replace(/\\"/g, '"') + "'";
                    return t.stylize(i, "string")
                }
                return v(e) ? t.stylize("" + e, "number") : g(e) ? t.stylize("" + e, "boolean") : m(e) ? t.stylize("null", "null") : void 0
            }

            function c(t) {
                return "[" + Error.prototype.toString.call(t) + "]"
            }

            function u(t, e, i, s, n) {
                for (var r = [], o = 0, a = e.length; a > o; ++o) R(e, String(o)) ? r.push(d(t, e, i, s, String(o), !0)) : r.push("");
                return n.forEach(function(n) {
                    n.match(/^\d+$/) || r.push(d(t, e, i, s, n, !0))
                }), r
            }

            function d(t, e, i, s, n, r) {
                var o, a, l;
                if (l = Object.getOwnPropertyDescriptor(e, n) || {
                        value: e[n]
                    }, l.get ? a = l.set ? t.stylize("[Getter/Setter]", "special") : t.stylize("[Getter]", "special") : l.set && (a = t.stylize("[Setter]", "special")), R(s, n) || (o = "[" + n + "]"), a || (t.seen.indexOf(l.value) < 0 ? (a = m(i) ? h(t, l.value, null) : h(t, l.value, i - 1), a.indexOf("\n") > -1 && (a = r ? a.split("\n").map(function(t) {
                        return "  " + t
                    }).join("\n").substr(2) : "\n" + a.split("\n").map(function(t) {
                        return "   " + t
                    }).join("\n"))) : a = t.stylize("[Circular]", "special")), _(o)) {
                    if (r && n.match(/^\d+$/)) return a;
                    o = JSON.stringify("" + n), o.match(/^"([a-zA-Z_][a-zA-Z_0-9]*)"$/) ? (o = o.substr(1, o.length - 2), o = t.stylize(o, "name")) : (o = o.replace(/'/g, "\\'").replace(/\\"/g, '"').replace(/(^"|"$)/g, "'"), o = t.stylize(o, "string"))
                }
                return o + ": " + a
            }

            function p(t, e, i) {
                var s = 0,
                    n = t.reduce(function(t, e) {
                        return s++, e.indexOf("\n") >= 0 && s++, t + e.replace(/\u001b\[\d\d?m/g, "").length + 1
                    }, 0);
                return n > 60 ? i[0] + ("" === e ? "" : e + "\n ") + " " + t.join(",\n  ") + " " + i[1] : i[0] + e + " " + t.join(", ") + " " + i[1]
            }

            function f(t) {
                return Array.isArray(t)
            }

            function g(t) {
                return "boolean" == typeof t
            }

            function m(t) {
                return null === t
            }

            function y(t) {
                return null == t
            }

            function v(t) {
                return "number" == typeof t
            }

            function x(t) {
                return "string" == typeof t
            }

            function b(t) {
                return "symbol" == typeof t
            }

            function _(t) {
                return void 0 === t
            }

            function w(t) {
                return P(t) && "[object RegExp]" === E(t)
            }

            function P(t) {
                return "object" == typeof t && null !== t
            }

            function T(t) {
                return P(t) && "[object Date]" === E(t)
            }

            function S(t) {
                return P(t) && ("[object Error]" === E(t) || t instanceof Error)
            }

            function C(t) {
                return "function" == typeof t
            }

            function A(t) {
                return null === t || "boolean" == typeof t || "number" == typeof t || "string" == typeof t || "symbol" == typeof t || "undefined" == typeof t
            }

            function E(t) {
                return Object.prototype.toString.call(t)
            }

            function M(t) {
                return 10 > t ? "0" + t.toString(10) : t.toString(10)
            }

            function L() {
                var t = new Date,
                    e = [M(t.getHours()), M(t.getMinutes()), M(t.getSeconds())].join(":");
                return [t.getDate(), k[t.getMonth()], e].join(" ")
            }

            function R(t, e) {
                return Object.prototype.hasOwnProperty.call(t, e)
            }
            var B = /%[sdj%]/g;
            i.format = function(t) {
                if (!x(t)) {
                    for (var e = [], i = 0; i < arguments.length; i++) e.push(n(arguments[i]));
                    return e.join(" ")
                }
                for (var i = 1, s = arguments, r = s.length, o = String(t).replace(B, function(t) {
                        if ("%%" === t) return "%";
                        if (i >= r) return t;
                        switch (t) {
                            case "%s":
                                return String(s[i++]);
                            case "%d":
                                return Number(s[i++]);
                            case "%j":
                                try {
                                    return JSON.stringify(s[i++])
                                } catch (e) {
                                    return "[Circular]"
                                }
                            default:
                                return t
                        }
                    }), a = s[i]; r > i; a = s[++i]) o += m(a) || !P(a) ? " " + a : " " + n(a);
                return o
            }, i.deprecate = function(t, n) {
                function r() {
                    if (!o) {
                        if (e.throwDeprecation) throw new Error(n);
                        e.traceDeprecation ? console.trace(n) : console.error(n), o = !0
                    }
                    return t.apply(this, arguments)
                }
                if (_(s.process)) return function() {
                    return i.deprecate(t, n).apply(this, arguments)
                };
                if (e.noDeprecation === !0) return t;
                var o = !1;
                return r
            };
            var O, I = {};
            i.debuglog = function(t) {
                if (_(O) && (O = e.env.NODE_DEBUG || ""), t = t.toUpperCase(), !I[t])
                    if (new RegExp("\\b" + t + "\\b", "i").test(O)) {
                        var s = e.pid;
                        I[t] = function() {
                            var e = i.format.apply(i, arguments);
                            console.error("%s %d: %s", t, s, e)
                        }
                    } else I[t] = function() {};
                return I[t]
            }, i.inspect = n, n.colors = {
                bold: [1, 22],
                italic: [3, 23],
                underline: [4, 24],
                inverse: [7, 27],
                white: [37, 39],
                grey: [90, 39],
                black: [30, 39],
                blue: [34, 39],
                cyan: [36, 39],
                green: [32, 39],
                magenta: [35, 39],
                red: [31, 39],
                yellow: [33, 39]
            }, n.styles = {
                special: "cyan",
                number: "yellow",
                "boolean": "yellow",
                undefined: "grey",
                "null": "bold",
                string: "green",
                date: "magenta",
                regexp: "red"
            }, i.isArray = f, i.isBoolean = g, i.isNull = m, i.isNullOrUndefined = y, i.isNumber = v, i.isString = x, i.isSymbol = b, i.isUndefined = _, i.isRegExp = w, i.isObject = P, i.isDate = T, i.isError = S, i.isFunction = C, i.isPrimitive = A, i.isBuffer = t("./support/isBuffer");
            var k = ["Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"];
            i.log = function() {
                console.log("%s - %s", L(), i.format.apply(i, arguments))
            }, i.inherits = t("inherits"), i._extend = function(t, e) {
                if (!e || !P(e)) return t;
                for (var i = Object.keys(e), s = i.length; s--;) t[i[s]] = e[i[s]];
                return t
            }
        }).call(this, t("rH1JPG"), "undefined" != typeof self ? self : "undefined" != typeof window ? window : {})
    }, {
        "./support/isBuffer": 12,
        inherits: 7,
        rH1JPG: 8
    }],
    14: [function(t, e) {
        function i(t) {
            i.super_.call(this, t, 0, 0), t.add.existing(this)
        }
        var s = t("underscore"),
            n = t("phaser"),
            r = t("util"),
            o = t("./sounds"),
            a = t("./colors");
        r.inherits(i, n.Sprite), s.extend(i.prototype, {
            create: function() {
                var t = this.game,
                    e = this.color = a.random("balloon"),
                    i = this.colorIndex = a.index,
                    n = this.balloon = t.add.sprite(0, 0, "balloon");
                n.anchor.set(.5);
                var r = this.balloonShape = t.add.sprite(0, 0, "balloonShape");
                r.anchor.set(.5), r.animations.add("red", [0]), r.animations.add("yellow", [1]), r.animations.add("green", [2]), r.animations.play(e);
                var o = this.balloonString = t.add.sprite(0, 42, "balloonThread");
                o.anchor.set(.5, 0), o.animations.add("fly", s.range(0, 49), 15, !1).onComplete.add(function() {
                    this.balloonString.animations.play("flyBack")
                }, this), o.animations.add("flyBack", s.range(48, -1, -1), 15, !1).onComplete.add(function() {
                    this.balloonString.animations.play("fly")
                }, this), o.animations.play("flyBack");
                var h = this.pieces = t.add.emitter(0, 0, 10);
                h.gravity = 150, h.autoScale = !0, h.setScale(1, 0, 1, 0, 750), h.setXSpeed(-500, 500), h.setYSpeed(-500, 500), h.makeParticles("balloonPiece", i), this.addChild(r), this.addChild(n), this.addChild(o), t.physics.arcade.enable(this), this.body.setSize(60, 74, -30, -37), this.reset()
            },
            reset: function() {
                this.revive(), this.balloonString.animations.play("idle")
            },
            pop: function() {
                var t = this.pieces;
                t.x = this.x, t.y = this.y, t.start(!0, 0, null, 10), o.pop.play(), this.kill()
            }
        }), e.exports = i
    }, {
        "./colors": 18,
        "./sounds": 21,
        phaser: "AqMBDX",
        underscore: 11,
        util: 13
    }],
    15: [function(t, e) {
        function i(t) {
            i.super_.call(this, t, 250, 168), t.physics.arcade.enable(this), this.arms = {
                left: null,
                right: null
            }, this.legs = {
                left: null,
                right: null
            }, t.add.existing(this)
        }
        var s = t("underscore"),
            n = t("phaser"),
            r = t("util"),
            o = t("./sounds"),
            a = t("./colors");
        r.inherits(i, n.Sprite), s.extend(i.prototype, {
            create: function() {
                var t = this.game;
                this.anchor.set(.5);
                var e = this.bodySprite = t.add.sprite(2, 30, "body");
                e.anchor.set(.5, 0);
                var i = this.hat = t.add.sprite(0, 0, "hat");
                i.anchor.set(.5, 0);
                var r = this.hatShape = t.add.sprite(0, 42, "hatShape");
                r.anchor.set(.5), r.animations.add("red", [0]), r.animations.add("yellow", [1]), r.animations.add("green", [2]);
                var a = this.arms.left = t.add.sprite(34, 75, "leftArm");
                a.anchor.set(.5, .9);
                var h = this.arms.right = t.add.sprite(-32, 77, "rightArm");
                h.anchor.set(.5, .9);
                var l = this.legs.left = t.add.sprite(18, 95, "leftLeg");
                l.anchor.set(.1);
                var c = this.legs.right = t.add.sprite(-14, 101, "rightLeg");
                c.anchor.set(.9, .1);
                var u = this.eyes = t.add.sprite(1, 60, "eyes");
                u.anchor.set(.5), u.animations.add("open", [0]), u.animations.add("close", s.range(1, 6)).onComplete.add(function() {
                    u.animations.play("open")
                }), u.animations.play("open");
                var d = this.mouth = t.add.sprite(3, 90, "mouth");
                d.anchor.set(.5), d.animations.add("idle", [0]), d.animations.add("happy", s.range(1, 19), 20).onComplete.add(function() {
                    d.animations.play("idle")
                }), d.animations.add("sad", s.range(19, 35), 20).onComplete.add(function() {
                    d.animations.play("idle")
                }), d.animations.play("idle");
                var p = this.propeller = t.add.sprite(0, 0, "propeller");
                p.anchor.set(.5), p.animations.add("rotate"), p.animations.play("rotate", 8, !0), o.propeller.play(), this.addChild(e), this.addChild(p), this.addChild(r), this.addChild(i), this.addChild(u), this.addChild(d), this.addChild(l), this.addChild(c), this.addChild(a), this.addChild(h), t.time.events.add(n.Timer.SECOND * s.random(2, 4), this.blink, this), t.physics.arcade.enable(this), this.reset()
            },
            reset: function() {
                var t = a.random("character");
                this.color = t, this.hatShape.animations.play(t)
            },
            blink: function() {
                this.eyes.animations.play("close"), this.game.time.events.add(n.Timer.SECOND * s.random(2, 4), this.blink, this)
            },
            happy: function() {
                this.mouth.animations.play("happy"), o.yeah.play()
            },
            sad: function() {
                this.mouth.animations.play("sad"), o.humm.play()
            }
        }), e.exports = i
    }, {
        "./colors": 18,
        "./sounds": 21,
        phaser: "AqMBDX",
        underscore: 11,
        util: 13
    }],
    16: [function(t, e) {
        function i(t) {
            i.super_.call(this, t, 0, -200), this.addCloud(), t.add.existing(this)
        }
        var s = t("underscore"),
            n = t("phaser"),
            r = t("util"),
            o = [],
            a = null;
        r.inherits(i, n.Sprite), s.extend(i.prototype, {
            render: function() {
                for (var t = 0, e = 0, i = this.count; i > t && a[t].y > 600; ++t) ++e;
                e == i && this.addCloud()
            },
            addCloud: function() {
                var t = this.game,
                    e = this.count = Math.ceil(10 * Math.random()) + 4;
                a = [];
                for (var i = null, s = 0; e > s; ++s) i = o.pop() || t.add.sprite(0, 0, "ball"), i.x = Math.random() * e * 40 - 10 * e, i.y = Math.random() * e * 6 - 3 * e, i.scale.y = 2 * Math.random() + 3, i.scale.x = 2 * Math.random() + 1 + i.scale.y, i.alpha = .3 * Math.random() + .1, t.physics.arcade.enable(i), i.body.velocity.y = 20 * i.scale.x, this.addChild(i), a.push(i);
                Array.prototype.push.apply(o, a)
            }
        }), e.exports = i
    }, {
        phaser: "AqMBDX",
        underscore: 11,
        util: 13
    }],
    17: [function(t, e) {
        function i(t) {
            i.super_.call(this, t, 0, 0), this.balloons = null, this.cache = [], t.add.existing(this)
        }
        var s = t("underscore"),
            n = t("phaser"),
            r = t("util"),
            o = t("./Cloud"),
            a = t("./Balloon");
        r.inherits(i, n.Sprite), s.extend(i.prototype, {
            create: function() {
                this.addChild(this.cloud = new o(this.game));
                this.balloons = this.game.add.group();
                this.game.time.events.add(n.Timer.SECOND * s.random(2, 3), this.addBalloon, this)
            },
            render: function() {
                this.cloud.render(), this.balloons.forEach(function(t) {
                    t.y > 600 && this.cache.push(t)
                }, this)
            },
            addBalloon: function() {
                var t = null;
                t ? t.reset() : (t = new a(this.game), this.balloons.add(t), t.create(), t.body.velocity.y = 50 * Math.random() + 100), t.x = 400 * Math.random() + 50, t.y = -150, this.game.time.events.add(n.Timer.SECOND * s.random(2, 3), this.addBalloon, this)
            },
            popBalloon: function(t) {
                t.pop(), this.cache.push(t)
            }
        }), e.exports = i
    }, {
        "./Balloon": 14,
        "./Cloud": 16,
        phaser: "AqMBDX",
        underscore: 11,
        util: 13
    }],
    18: [function(t, e) {
        var i = (t("underscore"), {});
        e.exports = {
            index: 0,
            colors: ["red", "yellow", "green"],
            random: function(t) {
                var e = 0;
                do e = ~~(Math.random() * this.colors.length); while (e == this.index || e == i[t]);
                return this.colors[this.index = i[t] = e]
            }
        }
    }, {
        underscore: 11
    }],
    19: [function(t) {
        function e(t, e) {
            l.popBalloon(e), t.color == e.color ? (t.happy(), t.reset(), u.stars.add()) : (t.sad(), u.stars.reset())
        }

        function i(t, e) {
            return u.stars.hasNext() && e.alive
        }
        var s = (t("underscore"), t("phaser")),
            n = t("Game"),
            r = t("./Scene"),
            o = t("./Character"),
            a = t("./sounds"),
            h = t("./graphics"),
            l = null,
            c = null,
            u = new n({
                info: {
                    id: "Helipopper",
                    name: "Helipopper",
                    fetchData: !1
                },
                sounds: a,
                graphics: h,
                create: function() {
                    u.stage.backgroundColor = 7327999, u.physics.startSystem(s.Physics.ARCADE), l = new r(u), l.create(), c = new o(u), c.create()
                },
                update: function() {
                    if (!u.stars.hasNext()) return u.won(), void 0;
                    u.physics.arcade.overlap(c, l.balloons, e, i), l.render();
                    var t = u.input.activePointer,
                        n = 0,
                        r = 0;
                    u.stars.hasNext() ? (n = (t.x - c.x) / 16, r = (t.y - c.y) / 24, c.x += n, c.y += r) : (n = 0, r = 0), n = s.Math.degToRad(n), r = s.Math.degToRad(r), c.rotation += (2 * n - c.rotation) / 4, c.arms.right.rotation = -2 * n + 2 * r, c.arms.left.rotation = -2 * n - 2 * r, c.legs.right.rotation = -2 * n + 4 * r, c.legs.left.rotation = -2 * n - 4 * r
                }
            })
    }, {
        "./Character": 15,
        "./Scene": 17,
        "./graphics": 20,
        "./sounds": 21,
        Game: "8XCh8k",
        phaser: "AqMBDX",
        underscore: 11
    }],
    20: [function(t, e) {
        var i = t("Graphics");
        e.exports = new i({
            images: ["ball", "balloon", "body", "hat", "leftArm", "rightArm", "leftLeg", "rightLeg"],
            sprites: ["balloonShape", "balloonString", {
                name: "balloonThread",
                path: ["assets/string.png", "assets/string.json"]
            }, "balloonPiece", "hatShape", "eyes", "mouth", "propeller"]
        })
    }, {
        Graphics: "A90zdo"
    }],
    21: [function(t, e) {
        var i = t("Sounds");
        e.exports = new i([{
            name: "humm",
            path: ["assets/humm.mp3", "assets/humm.ogg"]
        }, {
            name: "pop",
            path: ["assets/pop.mp3", "assets/pop.ogg"]
        }, {
            name: "propeller",
            path: ["assets/propeller.mp3", "assets/propeller.ogg"],
            loop: !0,
            volume: .5
        }, {
            name: "yeah",
            path: ["assets/yeah.mp3", "assets/yeah.ogg"]
        }])
    }, {
        Sounds: "+il8EN"
    }],
    Averager: [function(t, e) {
        e.exports = t("CG19iy")
    }, {}],
    CG19iy: [function(t, e) {
        (function(t) {
            (function(t) {
                function e(t) {
                    this.alpha = t || 0 === t ? t : .5, this.current = 0 / 0, this.roundCurrent = 0 / 0
                }
                e.prototype.average = function(t) {
                    return this.current != this.current ? this.current = t : this.current += this.alpha * (t - this.current)
                }, e.prototype.roundAverage = function(t) {
                    return this.roundCurrent = Math.round(this.average(t))
                }, e.prototype.reset = function() {
                    this.current = 0 / 0, this.roundCurrent = 0 / 0
                }, t.exports = e
            }).call(t, e, void 0)
        }).call(this, "undefined" != typeof self ? self : "undefined" != typeof window ? window : {})
    }, {}],
    DeltaTime: [function(t, e) {
        e.exports = t("BeIYEV")
    }, {}],
    BeIYEV: [function(t, e) {
        (function(i) {
            (function(e) {
                function i(t, e) {
                    this.game = t, this.time = e, this.since = t.time.now
                }
                var s = t("underscore");
                s.extend(i.prototype, {
                    passed: function() {
                        var t = this.game.time.elapsedSince(this.since);
                        return t < this.time ? !1 : !0
                    }
                }), e.exports = i
            }).call(i, e, void 0)
        }).call(this, "undefined" != typeof self ? self : "undefined" != typeof window ? window : {})
    }, {
        underscore: 11
    }],
    26: [function(t, e) {
        function i(t, e, s) {
            i.super_.call(this, e, e.width - 18, 18), this.state = t, this.clickHandler = s
        }

        function s() {
            this.clickHandler && this.clickHandler.call(this.state)
        }
        var n = t("underscore"),
            r = t("phaser"),
            o = t("util");
        o.inherits(i, r.Sprite), n.extend(i.prototype, {
            create: function() {
                var t = this.game;
                this.anchor.set(.5), this.fixedToCamera = !0, t.add.existing(this);
                var e = this.doneButton = t.add.button(0, 0, "doneButton", s, this, 0, 0, 1, 0);
                e.anchor.set(.5), this.addChild(e)
            }
        }), e.exports = i
    }, {
        phaser: "AqMBDX",
        underscore: 11,
        util: 13
    }],
    Game: [function(t, e) {
        e.exports = t("8XCh8k")
    }, {}],
    "8XCh8k": [function(t, e) {
        (function(i) {
            (function(e) {
                function i(t) {
                    P = t, E.preloadGame = t.preload, delete t.preload, t.stars = c.defaults(t.stars || {}, {
                        sounds: !0
                    }), t.create = c.wrap(t.create, r), t.update = c.wrap(t.update, o), t.shutdown = c.wrap(t.shutdown, a), i.super_.call(this, t.width || 500, t.height || 330, u.CANVAS, "game_div"), this.state.add("boot", v), this.state.add("preloader", E), this.state.add("game", t), this.state.add("lost", x), this.state.add("won", b);
                    var e = this;
                    m.once("boot", function(t) {
                        P.info.fetchData !== !1 && t && (T = t), e.state.start("boot")
                    }), m.on("restart", function() {
                        e.gameOverActive = !1, e.state.start("game"), A = (new Date).valueOf()
                    })
                }

                function s() {
                    var t = this.game;
                    return new y(function(e, i) {
                        var s = P.info;
                        if (s.category || (s.category = "math"), !T) return S = s, e(), void 0;
                        S = JSON.parse(t.cache.getText("config")), c.extend(S, s), c.isNumber(S.starsTotal) && (P.stars.total = S.starsTotal);
                        var n = funbrain.GameData(S.id, s.category),
                            r = setTimeout(function() {
                                e()
                            }, 5e3);
                        n.getProblemSet(function(t) {
                            C = t, clearTimeout(r), e()
                        }, Number.MAX_VALUE, function(t) {
                            clearTimeout(r), i(t)
                        })
                    })
                }

                function n() {
                    m.emit("loaded", S, C || {}), this.state.start("game"), A = (new Date).valueOf()
                }

                function r(t) {
                    var e = this.game;
                    P.sounds && P.sounds.create(e), e.swiper = new g(e), _ = new p(P, e, function() {
                        m.emit("done", h(e)), e.state.start("lost")
                    }), w = e.stars = new f(e, P.stars), e.stars.create(), t.call(e), e.stars.bringToTop(), _.create(), e.currentTime = e.time.now
                }

                function o(t) {
                    var e = this.game;
                    e.gameOverActive || (e.deltaTime = .06 * e.time.elapsedSince(e.currentTime), e.stars.render(), e.swiper.update(), t.call(e), e.currentTime = e.time.now)
                }

                function a(t) {
                    P.sounds && P.sounds.stopAll(), t && t.call(game)
                }

                function h(t) {
                    return {
                        config: S,
                        data: C,
                        elapsed: (new Date).valueOf() - A,
                        stars: {
                            count: t.stars.count,
                            total: t.stars.total
                        }
                    }
                }

                function l(t, e, i) {
                    var s = 2e3;
                    e && "delay" in e && (s = e.delay), t.time.events.add(s, function() {
                        t.state.start(i || "lost")
                    }, t)
                }
                var c = t("underscore"),
                    u = t("phaser"),
                    d = t("util"),
                    p = t("./DoneButton"),
                    f = t("./Stars"),
                    g = t("./Swiper"),
                    m = t("tracker"),
                    y = t("promise"),
                    v = t("./states/boot"),
                    x = t("./states/lost"),
                    b = t("./states/won"),
                    _ = null,
                    w = null,
                    P = null,
                    T = null,
                    S = null,
                    C = null,
                    A = 0,
                    E = {
                        ready: !1,
                        preload: function() {
                            {
                                var t = this.game,
                                    e = 276,
                                    i = 129,
                                    s = .5 * (t.width - e),
                                    n = .5 * (t.height - i),
                                    r = (t.add.sprite(s, n, "preloaderBackground"), t.add.sprite(s + 35, n + 111.1, "preloader"));
                                t.add.sprite(s + 35, n + 111.1, "preloaderForeground")
                            }
                            t.load.setPreloadSprite(r), P.stars.sounds && (t.load.audio("ding", ["assets/ding.mp3", "assets/ding.ogg"]), t.load.audio("bloop", ["assets/bloop.mp3", "assets/bloop.ogg"])), P.stars.counting && t.load.audio("counting", ["assets/counting.mp3", "assets/counting.ogg"]), t.load.image("puff", "assets/puff.png"), t.load.image("lostScreen", "assets/Lose_1024.png"), t.load.image("wonScreen", "assets/Win_1024.png"), t.load.atlasJSONHash("starPoint", "assets/starPoint.png", "assets/starPoint.json"), t.load.atlasJSONHash("doneButton", "assets/doneButton.png", "assets/doneButton.json"), T && t.load.text("config", T), P.graphics && P.graphics.preload(t), P.sounds && P.sounds.preload(t), this.preloadGame && this.preloadGame.call(t)
                        },
                        update: function() {
                            var t = this.game;
                            if (!this.ready && t.load.hasLoaded && (!P.sounds || P.sounds.decoded(t))) {
                                this.ready = !0;
                                var e = this;
                                s.call(this).then(function() {
                                    n.call(e)
                                }).catch(function(t) {
                                    console.log(t), n.call(e)
                                })
                            }
                        }
                    };
                d.inherits(i, u.Game), c.extend(i.prototype, {
                    won: function(t) {
                        this.gameOverActive || (this.gameOverActive = !0, m.emit("won", h(this)), l(this, t, "won"))
                    },
                    lost: function(t) {
                        this.gameOverActive || (this.gameOverActive = !0, m.emit("lost", h(this)), l(this, t, "lost"))
                    }
                }), m.on("loaded", function(t) {
                    brainEventTracker.logGameEvent({
                        event: "Loaded",
                        game_name: t.id
                    })
                }), m.on("done", function(t) {
                    brainEventTracker.logGameEvent({
                        event: "Done",
                        game_name: t.config.id,
                        time_spent: Math.round(t.elapsed / 1e3),
                        stars: t.stars.count
                    })
                }), m.on("won", function(t) {
                    brainEventTracker.logGameEvent({
                        event: "Won",
                        game_name: t.config.id,
                        time_spent: Math.round(t.elapsed / 1e3),
                        stars: t.stars.count
                    })
                }), m.on("lost", function(t) {
                    brainEventTracker.logGameEvent({
                        event: "Lost",
                        game_name: t.config.id,
                        time_spent: Math.round(t.elapsed / 1e3),
                        stars: t.stars.count
                    })
                }), window.game = m, e.exports = i
            }).call(i, e, void 0)
        }).call(this, "undefined" != typeof self ? self : "undefined" != typeof window ? window : {})
    }, {
        "./DoneButton": 26,
        "./Stars": "Md3YzC",
        "./Swiper": 35,
        "./states/boot": 40,
        "./states/lost": 41,
        "./states/won": 42,
        phaser: "AqMBDX",
        promise: 10,
        tracker: "T1txQX",
        underscore: 11,
        util: 13
    }],
    Graphics: [function(t, e) {
        e.exports = t("A90zdo")
    }, {}],
    A90zdo: [function(t, e) {
        (function(i) {
            (function(e) {
                function i(t) {
                    var e = t.images,
                        i = t.sprites,
                        o = t.physics,
                        h = t.fonts;
                    e = a.map(e, function(t) {
                        return a.isString(t) ? {
                            name: t,
                            path: s(t)
                        } : ("path" in t || (t.path = s(t.name)), t)
                    }), i = a.map(i, function(t) {
                        return a.isString(t) ? {
                            name: t,
                            path: [s(t), n(t)],
                            hash: !0
                        } : ("path" in t || (t.path = [s(t.name), n(t.name)]), a.defaults(t, {
                            hash: !0
                        }))
                    }), o = a.map(o, function(t) {
                        return a.isString(t) ? {
                            name: t,
                            path: n(t)
                        } : ("path" in t || (t.path = n(t.name)), t)
                    }), h = a.map(h, function(t) {
                        return a.isString(t) ? {
                            name: t,
                            path: [s(t), r(t)]
                        } : ("path" in t || (t.path = [s(t.name), r(t.name)]), t)
                    }), this.images = e, this.sprites = i, this.physics = o, this.fonts = h
                }

                function s(t) {
                    return o(t, "png")
                }

                function n(t) {
                    return o(t, "json")
                }

                function r(t) {
                    return o(t, "fnt")
                }

                function o(t, e) {
                    return "assets/" + t + "." + e
                }
                var a = t("underscore");
                a.extend(i.prototype, {
                    preload: function(t) {
                        a.each(this.images, function(e) {
                            t.load.image(e.name, e.path)
                        }), a.each(this.sprites, function(e) {
                            e.hash ? t.load.atlasJSONHash(e.name, e.path[0], e.path[1]) : t.load.atlas(e.name, e.path[0], e.path[1])
                        }), a.each(this.physics, function(e) {
                            t.load.physics(e.name, e.path)
                        }), a.each(this.fonts, function(e) {
                            t.load.bitmapFont(e.name, e.path[0], e.path[1])
                        })
                    }
                }), e.exports = i
            }).call(i, e, void 0)
        }).call(this, "undefined" != typeof self ? self : "undefined" != typeof window ? window : {})
    }, {
        underscore: 11
    }],
    Sounds: [function(t, e) {
        e.exports = t("+il8EN")
    }, {}],
    "+il8EN": [function(t, e) {
        (function(i) {
            (function(e) {
                function i(t) {
                    t = n.map(t, function(t) {
                        return n.isString(t) ? {
                            name: t,
                            path: s(t)
                        } : ("path" in t || (t.path = s(t.name)), t)
                    }), this.sounds = t
                }

                function s(t) {
                    return ["assets/" + t + ".mp3", "assets/" + t + ".ogg"]
                }
                var n = t("underscore");
                n.extend(i.prototype, {
                    preload: function(t) {
                        n.each(this.sounds, function(e) {
                            t.load.audio(e.name, e.path)
                        })
                    },
                    create: function(t) {
                        var e = this;
                        n.each(e.sounds, function(i) {
                            e[i.name] = t.add.audio(i.name, i.volume, i.loop)
                        })
                    },
                    playRandom: function() {
                        var t = n.toArray(arguments),
                            e = n.chain(t).shuffle().find(function(t) {
                                return !this[t].isPlaying
                            }, this).value();
                        return e ? (this[e].play(), this[e]) : null
                    },
                    stopAll: function() {
                        var t = this;
                        n.each(t.sounds, function(e) {
                            t[e.name].stop()
                        })
                    },
                    decoded: function(t) {
                        var e = t.cache;
                        return n.every(this.sounds, function(t) {
                            return e.isSoundDecoded(t.name)
                        })
                    }
                }), e.exports = i
            }).call(i, e, void 0)
        }).call(this, "undefined" != typeof self ? self : "undefined" != typeof window ? window : {})
    }, {
        underscore: 11
    }],
    Md3YzC: [function(t, e) {
        (function(s) {
            (function(e) {
                function s(t, e) {
                    e.x = e.x || 0, e.y = e.y || 0, s.super_.call(this, t, e.x + 21 * c, e.y + 20 * c), this.stars = [], this.positions = [], this.puffs = [], this.count = 0, this.total = a.isNumber(e.total) ? e.total : 5, this.counting = e.counting, this.vertical = e.vertical, this.reverse = e.reverse || !1, this.factory = e.factory || this.makeStar, this.itemSize = e.size || 32, this.offset = e.offset || {
                        x: 0,
                        y: 0
                    }, this.sounds = e.sounds, this.layout = e.layout, this.fixedToCamera = !0
                }

                function r(t) {
                    for (var e = t.offset, i = t.itemSize, s = [], n = null, r = 0, o = t.total; o > r; ++r) n = {
                        x: e.x + 8,
                        y: e.y + 8 + r * i
                    }, s.push(n);
                    return s
                }

                function o(t) {
                    for (var e = t.offset, i = t.itemSize, s = [], n = null, r = 0, o = t.total; o > r; ++r) n = {
                        x: e.x + 8 + r * i,
                        y: e.y + 8
                    }, s.push(n);
                    return s
                }
                var a = t("underscore"),
                    h = t("util"),
                    l = .7,
                    c = .82;
                h.inherits(s, Phaser.Sprite), a.extend(s.prototype, {
                    create: function() {
                        var t = this.game;
                        this.clearing = !1, t.add.existing(this);
                        this.total;
                        if (this.sounds && (this.ding = t.add.audio("ding"), this.bloop = t.add.audio("bloop")), this.counting) {
                            var e = this.counter = t.add.audio("counting");
                            e.addMarker("1", 0, .71), e.addMarker("2", .81, .72), e.addMarker("3", 1.67, .58), e.addMarker("4", 2.5, .67), e.addMarker("5", 3.29, .6), e.addMarker("6", 4.17, .71), e.addMarker("7", 5, .7), e.addMarker("8", 5.95, .46), e.addMarker("9", 6.66, .71), e.addMarker("10", 7.59, .93)
                        }
                        var s = this.stars,
                            h = this.positions;
                        h = a.isFunction(this.layout) ? this.layout(this) : this.vertical ? r(this) : o(this), this.reverse && h.reverse(), this.positions = h, a.each(h, function(t) {
                            var e = this.factory(t);
                            e.animations.play("idle", 24), s.push(e), this.addChild(e)
                        }, this);
                        var l = this.puffs,
                            c = null;
                        if (this.bloop)
                            for (i = 0, n = 20; n > i; ++i) c = t.add.sprite(-100, -100, "puff"), l.push(c), this.addChild(c)
                    },
                    render: function() {
                        if (this.clearing) {
                            var t = !0;
                            a.each(this.puffs, function(e) {
                                e.alive && (t = !1, e.x += e.velX *= l, e.y += e.velY *= l, e.scale.x = e.scale.y -= e.step, e.scale.x <= 0 && e.kill())
                            }, this), t && this.reset()
                        }
                    },
                    makeStar: function(t) {
                        var e = this.game.add.sprite(t.x, t.y, "starPoint");
                        return e.anchor.set(.5), e.scale.set(c), e.animations.add("idle", [0]), e.animations.add("point", a.range(1, 8)), e
                    },
                    hasNext: function() {
                        return this.count < this.total
                    },
                    add: function() {
                        return this.hasNext() ? (this.stars[this.count++].animations.play("point", 24), this.ding && this.ding.play(), this.counter && this.counter.play(this.count.toString()), !0) : !1
                    },
                    resettable: function() {
                        return this.count > 0 && !this.clearing
                    },
                    reset: function() {
                        if (this.count <= 0) return this.clearing = !1, void 0;
                        var t = this.currentStar;
                        t = this.stars[--this.count], t.animations.play("idle", 24), this.bloop && this.bloop.play(), a.each(this.puffs, function(e) {
                            e.x = t.x, e.y = t.y, e.rotation = Math.random() * Math.PI * 2, e.scale.set(.4 * Math.random() + .8), e.velX = 40 * Math.random() - 20, e.velY = 40 * Math.random() - 20, e.step = .2 * Math.random() + .2, e.revive()
                        }, this), this.clearing = !0
                    }
                }), e.exports = s
            }).call(s, e, void 0)
        }).call(this, "undefined" != typeof self ? self : "undefined" != typeof window ? window : {})
    }, {
        underscore: 11,
        util: 13
    }],
    Stars: [function(t, e) {
        e.exports = t("Md3YzC")
    }, {}],
    35: [function(t, e) {
        function i(t) {
            this.game = t, this.pointer = null, this.last = null, this.lastDirection = null, this.swiping = !1, this.x = new o, this.y = new o, t.input.onDown.add(this.down, this), t.input.onUp.add(this.up, this), t.input.onSwipe = new r.Signal
        }

        function s(t) {
            return Math.abs(t.x) > Math.abs(t.y) ? t.x > 0 ? "right" : "left" : t.y > 0 ? "down" : "up"
        }
        var n = t("underscore"),
            r = t("phaser"),
            o = t("Averager");
        n.extend(i.prototype, {
            down: function(t) {
                this.pointer = t, this.last = t.positionDown, this.time = this.game.time.now
            },
            up: function() {
                this.swiping = !1, this.pointer = null, this.lastDirection = null, this.x.reset(), this.y.reset()
            },
            update: function() {
                var t = this.pointer;
                if (t) {
                    if (!t.withinGame) return this.up(t), void 0;
                    var e = this.game.time.elapsedSince(this.time);
                    if (!(50 > e)) {
                        var i = t.position,
                            n = this.last,
                            o = r.Point.subtract(i, n),
                            a = {
                                x: o.x / e || 0,
                                y: o.y / e || 0
                            };
                        a.x = this.x.average(a.x), a.y = this.y.average(a.y);
                        var h = Math.abs(a.x) > .1 || Math.abs(a.y) > .1;
                        if (h) {
                            var l = s(a);
                            l != this.lastDirection && (this.lastDirection = l, this.game.input.onSwipe.dispatch({
                                pointer: t,
                                velocity: a,
                                distance: r.Point.distance(n, i),
                                angle: r.Point.angle(n, i),
                                duration: t.duration,
                                direction: l
                            }))
                        } else this.lastDirection = null;
                        this.swiping = h, this.last = i.clone(), this.time = this.game.time.now
                    }
                }
            }
        }), e.exports = i
    }, {
        Averager: "CG19iy",
        phaser: "AqMBDX",
        underscore: 11
    }],
    Utils: [function(t, e) {
        e.exports = t("7ltE0d")
    }, {}],
    "7ltE0d": [function(t, e) {
        (function(t) {
            (function(t) {
                var e = 2 * Math.PI;
                t.exports = {
                    normalizeAngle: function(t, i) {
                        return t - e * Math.floor((t + Math.PI - i) / e)
                    },
                    moveToPointer: function(t, e, i, s, n, r, o) {
                        i || (i = 60), s = s || t.input.activePointer, n || (n = 0);
                        var a = t.physics.arcade.angleToPointer(e, s);
                        return n > 0 && (i = (t.physics.arcade.distanceToPointer(e, s) / (n / 1e3)).toFixed(2)), r || (e.body.velocity.x = Math.cos(a) * i), o || (e.body.velocity.y = Math.sin(a) * i), a
                    }
                }
            }).call(t, e, void 0)
        }).call(this, "undefined" != typeof self ? self : "undefined" != typeof window ? window : {})
    }, {}],
    random: [function(t, e) {
        e.exports = t("Blhpsb")
    }, {}],
    Blhpsb: [function(t, e) {
        (function(t) {
            (function(t) {
                t.exports = function(t, e) {
                    return t + Math.random() * (e - t)
                }
            }).call(t, e, void 0)
        }).call(this, "undefined" != typeof self ? self : "undefined" != typeof window ? window : {})
    }, {}],
    40: [function(t, e) {
        var i = (t("underscore"), t("phaser"));
        e.exports = {
            ready: !1,
            preload: function() {
                var t = this.game;
                t.stage.backgroundColor = 16777215, t.load.image("preloader", "assets/preloader.png"), t.load.image("preloaderBackground", "assets/preloaderBackground.png"), t.load.image("preloaderForeground", "assets/preloaderForeground.png")
            },
            create: function() {
                var t = this.game;
                t.stage.disableVisibilityChange = !0;
                var e = t.scale;
                e.scaleMode = i.ScaleManager.SHOW_ALL, e.fullScreenScaleMode = i.ScaleManager.SHOW_ALL, e.refresh()
            },
            update: function() {
                !this.ready && this.game.load.hasLoaded && (this.ready = !0, this.state.start("preloader"))
            },
            gameResized: function() {},
            enterIncorrectOrientation: function() {},
            leaveIncorrectOrientation: function() {}
        }
    }, {
        phaser: "AqMBDX",
        underscore: 11
    }],
    41: [function(t, e) {
        var i = (t("underscore"), t("phaser"), t("tracker"));
        e.exports = {
            create: function() {
                var t = this.game,
                    e = t.add.sprite(.5 * t.width, .5 * t.height, "lostScreen");
                e.anchor.set(.5), e.scale.set(t.width / 1024), t.input.onUp.add(function() {
                    i.emit("restart")
                })
            }
        }
    }, {
        phaser: "AqMBDX",
        tracker: "T1txQX",
        underscore: 11
    }],
    42: [function(t, e) {
        var i = (t("underscore"), t("phaser"), t("tracker"));
        e.exports = {
            create: function() {
                var t = this.game,
                    e = t.add.sprite(.5 * t.width, .5 * t.height, "wonScreen");
                e.anchor.set(.5), e.scale.set(t.width / 1024), t.input.onUp.add(function() {
                    i.emit("restart")
                })
            }
        }
    }, {
        phaser: "AqMBDX",
        tracker: "T1txQX",
        underscore: 11
    }],
    tracker: [function(t, e) {
        e.exports = t("T1txQX")
    }, {}],
    T1txQX: [function(t, e) {
        (function(i) {
            (function(e) {
                var i = t("events").EventEmitter;
                e.exports = new i
            }).call(i, e, void 0)
        }).call(this, "undefined" != typeof self ? self : "undefined" != typeof window ? window : {})
    }, {
        events: 6
    }]
}, {}, [19]);